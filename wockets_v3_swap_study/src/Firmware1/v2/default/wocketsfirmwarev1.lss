
wocketsfirmwarev1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00001c46  00001cda  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001c46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000013f  00800104  00800104  00001cde  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00001cde  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000a79  00000000  00000000  00001d9e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000211f  00000000  00000000  00002817  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000008ee  00000000  00000000  00004936  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000025ce  00000000  00000000  00005224  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000570  00000000  00000000  000077f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000009fe  00000000  00000000  00007d64  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000008fd  00000000  00000000  00008762  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000003a8  00000000  00000000  0000905f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__ctors_end>
       4:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
       8:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
       c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      10:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      14:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      18:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      1c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      20:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      24:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      28:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      2c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__vector_11>
      30:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      34:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      38:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      3c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      40:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      44:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      48:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      4c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      50:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      54:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      58:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      5c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      60:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      64:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      68:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      6c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      70:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      74:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      78:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
      7c:	18 01       	movw	r2, r16
      7e:	18 01       	movw	r2, r16
      80:	1f 01       	movw	r2, r30
      82:	1f 01       	movw	r2, r30
      84:	1a 01       	movw	r2, r20
      86:	1f 01       	movw	r2, r30
      88:	18 01       	movw	r2, r16
      8a:	1a 01       	movw	r2, r20
      8c:	18 01       	movw	r2, r16
      8e:	1c 01       	movw	r2, r24
      90:	1f 01       	movw	r2, r30
      92:	1f 01       	movw	r2, r30
      94:	18 01       	movw	r2, r16
      96:	1a 01       	movw	r2, r20
      98:	1f 01       	movw	r2, r30
      9a:	1f 01       	movw	r2, r30
      9c:	1f 01       	movw	r2, r30
      9e:	1f 01       	movw	r2, r30
      a0:	18 01       	movw	r2, r16
      a2:	1a 01       	movw	r2, r20
      a4:	18 01       	movw	r2, r16
      a6:	1a 01       	movw	r2, r20
      a8:	18 01       	movw	r2, r16
      aa:	1f 01       	movw	r2, r30
      ac:	1f 01       	movw	r2, r30
      ae:	18 01       	movw	r2, r16
      b0:	1a 01       	movw	r2, r20
      b2:	18 01       	movw	r2, r16
      b4:	18 01       	movw	r2, r16
      b6:	18 01       	movw	r2, r16

000000b8 <__ctors_end>:
      b8:	11 24       	eor	r1, r1
      ba:	1f be       	out	0x3f, r1	; 63
      bc:	cf ef       	ldi	r28, 0xFF	; 255
      be:	d8 e0       	ldi	r29, 0x08	; 8
      c0:	de bf       	out	0x3e, r29	; 62
      c2:	cd bf       	out	0x3d, r28	; 61

000000c4 <__do_copy_data>:
      c4:	11 e0       	ldi	r17, 0x01	; 1
      c6:	a0 e0       	ldi	r26, 0x00	; 0
      c8:	b1 e0       	ldi	r27, 0x01	; 1
      ca:	e6 e4       	ldi	r30, 0x46	; 70
      cc:	fc e1       	ldi	r31, 0x1C	; 28
      ce:	02 c0       	rjmp	.+4      	; 0xd4 <.do_copy_data_start>

000000d0 <.do_copy_data_loop>:
      d0:	05 90       	lpm	r0, Z+
      d2:	0d 92       	st	X+, r0

000000d4 <.do_copy_data_start>:
      d4:	a4 30       	cpi	r26, 0x04	; 4
      d6:	b1 07       	cpc	r27, r17
      d8:	d9 f7       	brne	.-10     	; 0xd0 <.do_copy_data_loop>

000000da <__do_clear_bss>:
      da:	12 e0       	ldi	r17, 0x02	; 2
      dc:	a4 e0       	ldi	r26, 0x04	; 4
      de:	b1 e0       	ldi	r27, 0x01	; 1
      e0:	01 c0       	rjmp	.+2      	; 0xe4 <.do_clear_bss_start>

000000e2 <.do_clear_bss_loop>:
      e2:	1d 92       	st	X+, r1

000000e4 <.do_clear_bss_start>:
      e4:	a3 34       	cpi	r26, 0x43	; 67
      e6:	b1 07       	cpc	r27, r17
      e8:	e1 f7       	brne	.-8      	; 0xe2 <.do_clear_bss_loop>
      ea:	0e 94 9d 04 	call	0x93a	; 0x93a <main>
      ee:	0c 94 21 0e 	jmp	0x1c42	; 0x1c42 <_exit>

000000f2 <__bad_interrupt>:
      f2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f6 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
      f6:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
      f8:	f9 99       	sbic	0x1f, 1	; 31
      fa:	fe cf       	rjmp	.-4      	; 0xf8 <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
      fc:	32 bd       	out	0x22, r19	; 34
      fe:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
     100:	f8 9a       	sbi	0x1f, 0	; 31
     102:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
     104:	08 95       	ret

00000106 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
     106:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
     108:	f9 99       	sbic	0x1f, 1	; 31
     10a:	fe cf       	rjmp	.-4      	; 0x108 <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
     10c:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
     10e:	32 bd       	out	0x22, r19	; 34
     110:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
     112:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
     114:	0f b6       	in	r0, 0x3f	; 63
     116:	f8 94       	cli
     118:	fa 9a       	sbi	0x1f, 2	; 31
     11a:	f9 9a       	sbi	0x1f, 1	; 31
     11c:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
     11e:	08 95       	ret

00000120 <TransmitFrame>:
unsigned char response_length=0;
unsigned char disconnected_reset=1;
unsigned short sequence=0;


void TransmitFrame(WOCKETS_UNCOMPRESSED_FRAME f){
     120:	df 93       	push	r29
     122:	cf 93       	push	r28
     124:	00 d0       	rcall	.+0      	; 0x126 <TransmitFrame+0x6>
     126:	00 d0       	rcall	.+0      	; 0x128 <TransmitFrame+0x8>
     128:	0f 92       	push	r0
     12a:	cd b7       	in	r28, 0x3d	; 61
     12c:	de b7       	in	r29, 0x3e	; 62
     12e:	49 83       	std	Y+1, r20	; 0x01
     130:	5a 83       	std	Y+2, r21	; 0x02
     132:	6b 83       	std	Y+3, r22	; 0x03
     134:	7c 83       	std	Y+4, r23	; 0x04
     136:	8d 83       	std	Y+5, r24	; 0x05
	
	TransmitByte(f.byte1);
     138:	84 2f       	mov	r24, r20
     13a:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TransmitByte>
	TransmitByte(f.byte2);
     13e:	8a 81       	ldd	r24, Y+2	; 0x02
     140:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TransmitByte>
	TransmitByte(f.byte3);
     144:	8b 81       	ldd	r24, Y+3	; 0x03
     146:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TransmitByte>
	TransmitByte(f.byte4);
     14a:	8c 81       	ldd	r24, Y+4	; 0x04
     14c:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TransmitByte>
	TransmitByte(f.byte5);
     150:	8d 81       	ldd	r24, Y+5	; 0x05
     152:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TransmitByte>

}
     156:	0f 90       	pop	r0
     158:	0f 90       	pop	r0
     15a:	0f 90       	pop	r0
     15c:	0f 90       	pop	r0
     15e:	0f 90       	pop	r0
     160:	cf 91       	pop	r28
     162:	df 91       	pop	r29
     164:	08 95       	ret

00000166 <__vector_11>:

	return 0;
}


ISR(TIMER2_OVF_vect){
     166:	1f 92       	push	r1
     168:	0f 92       	push	r0
     16a:	0f b6       	in	r0, 0x3f	; 63
     16c:	0f 92       	push	r0
     16e:	11 24       	eor	r1, r1
     170:	0f 93       	push	r16
     172:	1f 93       	push	r17
     174:	2f 93       	push	r18
     176:	3f 93       	push	r19
     178:	4f 93       	push	r20
     17a:	5f 93       	push	r21
     17c:	6f 93       	push	r22
     17e:	7f 93       	push	r23
     180:	8f 93       	push	r24
     182:	9f 93       	push	r25
     184:	af 93       	push	r26
     186:	bf 93       	push	r27
     188:	ef 93       	push	r30
     18a:	ff 93       	push	r31
     18c:	df 93       	push	r29
     18e:	cf 93       	push	r28
     190:	cd b7       	in	r28, 0x3d	; 61
     192:	de b7       	in	r29, 0x3e	; 62
     194:	2f 97       	sbiw	r28, 0x0f	; 15
     196:	de bf       	out	0x3e, r29	; 62
     198:	cd bf       	out	0x3d, r28	; 61

		//When the counter wraps around the timer
		TCNT2=170;
     19a:	8a ea       	ldi	r24, 0xAA	; 170
     19c:	80 93 b2 00 	sts	0x00B2, r24

		if (sleep==0){
     1a0:	80 91 0b 01 	lds	r24, 0x010B
     1a4:	90 91 0c 01 	lds	r25, 0x010C
     1a8:	89 2b       	or	r24, r25
     1aa:	09 f0       	breq	.+2      	; 0x1ae <__vector_11+0x48>
     1ac:	ae c3       	rjmp	.+1884   	; 0x90a <__stack+0xb>

			 if (_rn41_is_connected()){
     1ae:	0e 94 6d 05 	call	0xada	; 0xada <_rn41_is_connected>
     1b2:	88 23       	and	r24, r24
     1b4:	09 f4       	brne	.+2      	; 0x1b8 <__vector_11+0x52>
     1b6:	6b c3       	rjmp	.+1750   	; 0x88e <__vector_11+0x728>

				sleep_counter=0;
     1b8:	10 92 08 01 	sts	0x0108, r1
     1bc:	10 92 07 01 	sts	0x0107, r1
				sleep_counter2=0;
     1c0:	10 92 0a 01 	sts	0x010A, r1
     1c4:	10 92 09 01 	sts	0x0109, r1
				disconnected_reset=0;
     1c8:	10 92 02 01 	sts	0x0102, r1
		
				/* 	Receive a byte on each timer interrupt only if no command is being received or
					if a command has been received in full */
				if ( ((command_counter==0)||(command_counter<command_length))  && (ReceiveByte(&aByte)==0) )
     1cc:	90 91 12 01 	lds	r25, 0x0112
     1d0:	99 23       	and	r25, r25
     1d2:	29 f0       	breq	.+10     	; 0x1de <__vector_11+0x78>
     1d4:	80 91 13 01 	lds	r24, 0x0113
     1d8:	98 17       	cp	r25, r24
     1da:	08 f0       	brcs	.+2      	; 0x1de <__vector_11+0x78>
     1dc:	41 c0       	rjmp	.+130    	; 0x260 <__vector_11+0xfa>
     1de:	80 e1       	ldi	r24, 0x10	; 16
     1e0:	91 e0       	ldi	r25, 0x01	; 1
     1e2:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <ReceiveByte>
     1e6:	88 23       	and	r24, r24
     1e8:	d9 f5       	brne	.+118    	; 0x260 <__vector_11+0xfa>
				{				
					aBuffer[command_counter++]=aByte;
     1ea:	80 91 12 01 	lds	r24, 0x0112
     1ee:	e8 2f       	mov	r30, r24
     1f0:	f0 e0       	ldi	r31, 0x00	; 0
     1f2:	eb 5c       	subi	r30, 0xCB	; 203
     1f4:	fd 4f       	sbci	r31, 0xFD	; 253
     1f6:	90 91 10 01 	lds	r25, 0x0110
     1fa:	90 83       	st	Z, r25
     1fc:	8f 5f       	subi	r24, 0xFF	; 255
     1fe:	80 93 12 01 	sts	0x0112, r24

//			TransmitFrame(encode(1,1023,1023, 1023));
					//for the first byte set the opcode and set the commands length and reset timer
					if ((aByte>>5)==COMMAND_PREFIX)
     202:	89 2f       	mov	r24, r25
     204:	82 95       	swap	r24
     206:	86 95       	lsr	r24
     208:	87 70       	andi	r24, 0x07	; 7
     20a:	85 30       	cpi	r24, 0x05	; 5
     20c:	49 f5       	brne	.+82     	; 0x260 <__vector_11+0xfa>
					{
						opcode=aByte&0x1f;						
     20e:	89 2f       	mov	r24, r25
     210:	8f 71       	andi	r24, 0x1F	; 31
     212:	80 93 11 01 	sts	0x0111, r24
						switch (opcode)
     216:	e8 2f       	mov	r30, r24
     218:	f0 e0       	ldi	r31, 0x00	; 0
     21a:	ee 31       	cpi	r30, 0x1E	; 30
     21c:	f1 05       	cpc	r31, r1
     21e:	78 f4       	brcc	.+30     	; 0x23e <__vector_11+0xd8>
     220:	e2 5c       	subi	r30, 0xC2	; 194
     222:	ff 4f       	sbci	r31, 0xFF	; 255
     224:	ee 0f       	add	r30, r30
     226:	ff 1f       	adc	r31, r31
     228:	05 90       	lpm	r0, Z+
     22a:	f4 91       	lpm	r31, Z+
     22c:	e0 2d       	mov	r30, r0
     22e:	09 94       	ijmp
								case (unsigned char)RESET_WOCKET:
								case (unsigned char)GET_BAUD_RATE:
								case (unsigned char)ALIVE:			
								case (unsigned char)PAUSE:
								case (unsigned char)RESUME:
									command_length=1;
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	03 c0       	rjmp	.+6      	; 0x23a <__vector_11+0xd4>
								case (unsigned char)SET_SENSOR_SENSITIVITY:		
								case (unsigned char)SET_SAMPLING_RATE:
								case (unsigned char)SET_ALIVE_TIMER:
								case (unsigned char)SET_POWER_DOWN_TIMER:
								case (unsigned char)SET_BAUD_RATE:						
									command_length=2;
     234:	82 e0       	ldi	r24, 0x02	; 2
     236:	01 c0       	rjmp	.+2      	; 0x23a <__vector_11+0xd4>
									break;
								case (unsigned char)SET_CALIBRATION_VALUES:
									command_length=10;								
     238:	8a e0       	ldi	r24, 0x0A	; 10
     23a:	80 93 13 01 	sts	0x0113, r24
									break;								

						}
						command_counter=1;
     23e:	81 e0       	ldi	r24, 0x01	; 1
     240:	80 93 12 01 	sts	0x0112, r24
						command_timer=0;
     244:	10 92 15 01 	sts	0x0115, r1
     248:	10 92 14 01 	sts	0x0114, r1
						processed_counter=0;						
     24c:	10 92 16 01 	sts	0x0116, r1
						address=0xffff;
     250:	8f ef       	ldi	r24, 0xFF	; 255
     252:	9f ef       	ldi	r25, 0xFF	; 255
     254:	90 93 01 01 	sts	0x0101, r25
     258:	80 93 00 01 	sts	0x0100, r24
						response_length=0;
     25c:	10 92 1e 01 	sts	0x011E, r1
					}

				}

				// increment timer as long as the command is still being received
				if (command_counter>0)
     260:	10 91 12 01 	lds	r17, 0x0112
     264:	11 23       	and	r17, r17
     266:	09 f4       	brne	.+2      	; 0x26a <__vector_11+0x104>
     268:	79 c2       	rjmp	.+1266   	; 0x75c <__vector_11+0x5f6>
					command_timer++;
     26a:	80 91 14 01 	lds	r24, 0x0114
     26e:	90 91 15 01 	lds	r25, 0x0115
     272:	01 96       	adiw	r24, 0x01	; 1
     274:	90 93 15 01 	sts	0x0115, r25
     278:	80 93 14 01 	sts	0x0114, r24

				//if all command is received, start processing it
				if ((command_counter>0) && (command_counter==command_length))
     27c:	80 91 13 01 	lds	r24, 0x0113
     280:	18 17       	cp	r17, r24
     282:	09 f0       	breq	.+2      	; 0x286 <__vector_11+0x120>
     284:	6b c2       	rjmp	.+1238   	; 0x75c <__vector_11+0x5f6>
				{					
					switch (opcode)
     286:	80 91 11 01 	lds	r24, 0x0111
     28a:	89 31       	cpi	r24, 0x19	; 25
     28c:	09 f4       	brne	.+2      	; 0x290 <__vector_11+0x12a>
     28e:	62 c0       	rjmp	.+196    	; 0x354 <__vector_11+0x1ee>
     290:	8a 31       	cpi	r24, 0x1A	; 26
     292:	48 f4       	brcc	.+18     	; 0x2a6 <__vector_11+0x140>
     294:	88 30       	cpi	r24, 0x08	; 8
     296:	09 f4       	brne	.+2      	; 0x29a <__vector_11+0x134>
     298:	6a c1       	rjmp	.+724    	; 0x56e <__vector_11+0x408>
     29a:	89 30       	cpi	r24, 0x09	; 9
     29c:	09 f4       	brne	.+2      	; 0x2a0 <__vector_11+0x13a>
     29e:	73 c0       	rjmp	.+230    	; 0x386 <__vector_11+0x220>
     2a0:	88 23       	and	r24, r24
     2a2:	c9 f0       	breq	.+50     	; 0x2d6 <__vector_11+0x170>
     2a4:	40 c2       	rjmp	.+1152   	; 0x726 <__vector_11+0x5c0>
     2a6:	8b 31       	cpi	r24, 0x1B	; 27
     2a8:	89 f0       	breq	.+34     	; 0x2cc <__vector_11+0x166>
     2aa:	8b 31       	cpi	r24, 0x1B	; 27
     2ac:	88 f1       	brcs	.+98     	; 0x310 <__vector_11+0x1aa>
     2ae:	8c 31       	cpi	r24, 0x1C	; 28
     2b0:	21 f0       	breq	.+8      	; 0x2ba <__vector_11+0x154>
     2b2:	8d 31       	cpi	r24, 0x1D	; 29
     2b4:	09 f0       	breq	.+2      	; 0x2b8 <__vector_11+0x152>
     2b6:	37 c2       	rjmp	.+1134   	; 0x726 <__vector_11+0x5c0>
     2b8:	04 c0       	rjmp	.+8      	; 0x2c2 <__vector_11+0x15c>
					{
						case (unsigned char)PAUSE:							
							paused=1;
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	80 93 0f 01 	sts	0x010F, r24
     2c0:	02 c0       	rjmp	.+4      	; 0x2c6 <__vector_11+0x160>
							processed_counter=command_counter;							
							break;
						case (unsigned char)RESUME:							
							paused=0;
     2c2:	10 92 0f 01 	sts	0x010F, r1
							processed_counter=command_counter;							
     2c6:	10 93 16 01 	sts	0x0116, r17
     2ca:	2d c2       	rjmp	.+1114   	; 0x726 <__vector_11+0x5c0>
							break;
						//reset alive timer if it is alive
						case (unsigned char)ALIVE:							
							alive_timer=0;
     2cc:	10 92 18 01 	sts	0x0118, r1
     2d0:	10 92 17 01 	sts	0x0117, r1
     2d4:	f8 cf       	rjmp	.-16     	; 0x2c6 <__vector_11+0x160>
							processed_counter=command_counter;							
							break;
						//setup battery buffer
					    case (unsigned char) GET_BATTERY_LEVEL:		
							word=_atmega324p_a2dConvert10bit(ADC4);
     2d6:	84 e0       	ldi	r24, 0x04	; 4
     2d8:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     2dc:	90 93 1d 01 	sts	0x011D, r25
     2e0:	80 93 1c 01 	sts	0x011C, r24
							aBuffer[0]=m_BATTERY_LEVEL_BYTE0;
     2e4:	20 ec       	ldi	r18, 0xC0	; 192
     2e6:	20 93 35 02 	sts	0x0235, r18
							aBuffer[1]=m_BATTERY_LEVEL_BYTE1(word);
     2ea:	9c 01       	movw	r18, r24
     2ec:	13 e0       	ldi	r17, 0x03	; 3
     2ee:	36 95       	lsr	r19
     2f0:	27 95       	ror	r18
     2f2:	1a 95       	dec	r17
     2f4:	e1 f7       	brne	.-8      	; 0x2ee <__vector_11+0x188>
     2f6:	20 93 36 02 	sts	0x0236, r18
							aBuffer[2]=m_BATTERY_LEVEL_BYTE2(word);
     2fa:	87 70       	andi	r24, 0x07	; 7
     2fc:	82 95       	swap	r24
     2fe:	80 7f       	andi	r24, 0xF0	; 240
     300:	80 93 37 02 	sts	0x0237, r24
							processed_counter=command_counter;
     304:	80 91 12 01 	lds	r24, 0x0112
     308:	80 93 16 01 	sts	0x0116, r24
							response_length=3;										
     30c:	83 e0       	ldi	r24, 0x03	; 3
     30e:	38 c0       	rjmp	.+112    	; 0x380 <__vector_11+0x21a>
							break;
						case (unsigned char) SET_BAUD_RATE:
							if (_atmega324p_a2dConvert10bit(ADC4)<350)
     310:	84 e0       	ldi	r24, 0x04	; 4
     312:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     316:	8e 55       	subi	r24, 0x5E	; 94
     318:	91 40       	sbci	r25, 0x01	; 1
     31a:	08 f4       	brcc	.+2      	; 0x31e <__vector_11+0x1b8>
     31c:	04 c2       	rjmp	.+1032   	; 0x726 <__vector_11+0x5c0>
								break;
							else if (eeprom_is_ready())
     31e:	f9 99       	sbic	0x1f, 1	; 31
     320:	02 c2       	rjmp	.+1028   	; 0x726 <__vector_11+0x5c0>
							{
								word=m_BAUD_RATE_BYTE2_TO_BR(aBuffer[1]);
     322:	60 91 36 02 	lds	r22, 0x0236
     326:	70 e0       	ldi	r23, 0x00	; 0
     328:	68 77       	andi	r22, 0x78	; 120
     32a:	70 70       	andi	r23, 0x00	; 0
     32c:	b3 e0       	ldi	r27, 0x03	; 3
     32e:	76 95       	lsr	r23
     330:	67 95       	ror	r22
     332:	ba 95       	dec	r27
     334:	e1 f7       	brne	.-8      	; 0x32e <__vector_11+0x1c8>
     336:	70 93 1d 01 	sts	0x011D, r23
     33a:	60 93 1c 01 	sts	0x011C, r22
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
     33e:	8c e0       	ldi	r24, 0x0C	; 12
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	43 e8       	ldi	r20, 0x83	; 131
     344:	50 e0       	ldi	r21, 0x00	; 0
     346:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <__eewr_word>
								eeprom_write_word((uint16_t *)BAUD_RATE_ADDRESS,word);
								processed_counter=command_counter;
     34a:	80 91 12 01 	lds	r24, 0x0112
     34e:	80 93 16 01 	sts	0x0116, r24
     352:	e9 c1       	rjmp	.+978    	; 0x726 <__vector_11+0x5c0>
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
     354:	8c e0       	ldi	r24, 0x0C	; 12
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	6b e7       	ldi	r22, 0x7B	; 123
     35a:	70 e0       	ldi	r23, 0x00	; 0
     35c:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <__eerd_word>
							}
							break;
						case (unsigned char) GET_BAUD_RATE:
							word=eeprom_read_word((uint16_t *)((uint16_t)BAUD_RATE_ADDRESS));
     360:	80 93 1c 01 	sts	0x011C, r24
     364:	90 93 1d 01 	sts	0x011D, r25
							aBuffer[0]=m_BAUD_RATE_BYTE0;
     368:	98 ec       	ldi	r25, 0xC8	; 200
     36a:	90 93 35 02 	sts	0x0235, r25
							aBuffer[1]=m_BAUD_RATE_BYTE1(word);				
     36e:	88 0f       	add	r24, r24
     370:	88 0f       	add	r24, r24
     372:	88 0f       	add	r24, r24
     374:	88 77       	andi	r24, 0x78	; 120
     376:	80 93 36 02 	sts	0x0236, r24
							processed_counter=command_counter;
     37a:	10 93 16 01 	sts	0x0116, r17
							response_length=2;										
     37e:	82 e0       	ldi	r24, 0x02	; 2
     380:	80 93 1e 01 	sts	0x011E, r24
     384:	d0 c1       	rjmp	.+928    	; 0x726 <__vector_11+0x5c0>
							break;
						case (unsigned char) SET_CALIBRATION_VALUES:									
							if (eeprom_is_ready())
     386:	f9 99       	sbic	0x1f, 1	; 31
     388:	ce c1       	rjmp	.+924    	; 0x726 <__vector_11+0x5c0>
							{
								//do nothing if battery is low
								if (_atmega324p_a2dConvert10bit(ADC4)<350)
     38a:	84 e0       	ldi	r24, 0x04	; 4
     38c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     390:	8e 55       	subi	r24, 0x5E	; 94
     392:	91 40       	sbci	r25, 0x01	; 1
     394:	08 f4       	brcc	.+2      	; 0x398 <__vector_11+0x232>
     396:	c7 c1       	rjmp	.+910    	; 0x726 <__vector_11+0x5c0>
									break;
								else
								{	switch(address)
     398:	80 91 00 01 	lds	r24, 0x0100
     39c:	90 91 01 01 	lds	r25, 0x0101
     3a0:	84 30       	cpi	r24, 0x04	; 4
     3a2:	91 05       	cpc	r25, r1
     3a4:	09 f4       	brne	.+2      	; 0x3a8 <__vector_11+0x242>
     3a6:	55 c0       	rjmp	.+170    	; 0x452 <__vector_11+0x2ec>
     3a8:	85 30       	cpi	r24, 0x05	; 5
     3aa:	91 05       	cpc	r25, r1
     3ac:	30 f4       	brcc	.+12     	; 0x3ba <__vector_11+0x254>
     3ae:	00 97       	sbiw	r24, 0x00	; 0
     3b0:	61 f0       	breq	.+24     	; 0x3ca <__vector_11+0x264>
     3b2:	02 97       	sbiw	r24, 0x02	; 2
     3b4:	09 f0       	breq	.+2      	; 0x3b8 <__vector_11+0x252>
     3b6:	b0 c0       	rjmp	.+352    	; 0x518 <__vector_11+0x3b2>
     3b8:	22 c0       	rjmp	.+68     	; 0x3fe <__vector_11+0x298>
     3ba:	86 30       	cpi	r24, 0x06	; 6
     3bc:	91 05       	cpc	r25, r1
     3be:	09 f4       	brne	.+2      	; 0x3c2 <__vector_11+0x25c>
     3c0:	64 c0       	rjmp	.+200    	; 0x48a <__vector_11+0x324>
     3c2:	08 97       	sbiw	r24, 0x08	; 8
     3c4:	09 f0       	breq	.+2      	; 0x3c8 <__vector_11+0x262>
     3c6:	a8 c0       	rjmp	.+336    	; 0x518 <__vector_11+0x3b2>
     3c8:	82 c0       	rjmp	.+260    	; 0x4ce <__vector_11+0x368>
									{
										case X1G_ADDRESS:
											word=m_CALIBRATION_BYTE2_TO_XN1G(aBuffer[2]) | m_CALIBRATION_BYTE3_TO_XN1G(aBuffer[3]);
     3ca:	80 91 38 02 	lds	r24, 0x0238
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	8e 77       	andi	r24, 0x7E	; 126
     3d2:	90 70       	andi	r25, 0x00	; 0
     3d4:	96 95       	lsr	r25
     3d6:	87 95       	ror	r24
     3d8:	20 91 37 02 	lds	r18, 0x0237
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	2f 70       	andi	r18, 0x0F	; 15
     3e0:	30 70       	andi	r19, 0x00	; 0
     3e2:	f6 e0       	ldi	r31, 0x06	; 6
     3e4:	22 0f       	add	r18, r18
     3e6:	33 1f       	adc	r19, r19
     3e8:	fa 95       	dec	r31
     3ea:	e1 f7       	brne	.-8      	; 0x3e4 <__vector_11+0x27e>
     3ec:	82 2b       	or	r24, r18
     3ee:	93 2b       	or	r25, r19
     3f0:	90 93 1d 01 	sts	0x011D, r25
     3f4:	80 93 1c 01 	sts	0x011C, r24
											address=X1NG_ADDRESS;
     3f8:	82 e0       	ldi	r24, 0x02	; 2
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	25 c0       	rjmp	.+74     	; 0x448 <__vector_11+0x2e2>
											break;
										case X1NG_ADDRESS:
											word=m_CALIBRATION_BYTE3_TO_Y1G(aBuffer[3])|m_CALIBRATION_BYTE4_TO_Y1G(aBuffer[4])|m_CALIBRATION_BYTE5_TO_Y1G(aBuffer[5]);
     3fe:	20 91 39 02 	lds	r18, 0x0239
     402:	30 e0       	ldi	r19, 0x00	; 0
     404:	2f 77       	andi	r18, 0x7F	; 127
     406:	30 70       	andi	r19, 0x00	; 0
     408:	22 0f       	add	r18, r18
     40a:	33 1f       	adc	r19, r19
     40c:	22 0f       	add	r18, r18
     40e:	33 1f       	adc	r19, r19
     410:	80 91 38 02 	lds	r24, 0x0238
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	81 70       	andi	r24, 0x01	; 1
     418:	90 70       	andi	r25, 0x00	; 0
     41a:	98 2f       	mov	r25, r24
     41c:	88 27       	eor	r24, r24
     41e:	99 0f       	add	r25, r25
     420:	28 2b       	or	r18, r24
     422:	39 2b       	or	r19, r25
     424:	80 91 3a 02 	lds	r24, 0x023A
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	80 76       	andi	r24, 0x60	; 96
     42c:	90 70       	andi	r25, 0x00	; 0
     42e:	65 e0       	ldi	r22, 0x05	; 5
     430:	96 95       	lsr	r25
     432:	87 95       	ror	r24
     434:	6a 95       	dec	r22
     436:	e1 f7       	brne	.-8      	; 0x430 <__vector_11+0x2ca>
     438:	28 2b       	or	r18, r24
     43a:	39 2b       	or	r19, r25
     43c:	30 93 1d 01 	sts	0x011D, r19
     440:	20 93 1c 01 	sts	0x011C, r18
											address=Y1G_ADDRESS;
     444:	84 e0       	ldi	r24, 0x04	; 4
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	90 93 01 01 	sts	0x0101, r25
     44c:	80 93 00 01 	sts	0x0100, r24
     450:	81 c0       	rjmp	.+258    	; 0x554 <__vector_11+0x3ee>
											break;
										case Y1G_ADDRESS:
											word=m_CALIBRATION_BYTE5_TO_YN1G(aBuffer[5])|m_CALIBRATION_BYTE6_TO_YN1G(aBuffer[6]);//(((unsigned short)(aBuffer[5]&0x1f))<<5) | (((unsigned short)(aBuffer[6]&0x7c))>>2);
     452:	80 91 3b 02 	lds	r24, 0x023B
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	8c 77       	andi	r24, 0x7C	; 124
     45a:	90 70       	andi	r25, 0x00	; 0
     45c:	96 95       	lsr	r25
     45e:	87 95       	ror	r24
     460:	96 95       	lsr	r25
     462:	87 95       	ror	r24
     464:	20 91 3a 02 	lds	r18, 0x023A
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	2f 71       	andi	r18, 0x1F	; 31
     46c:	30 70       	andi	r19, 0x00	; 0
     46e:	45 e0       	ldi	r20, 0x05	; 5
     470:	22 0f       	add	r18, r18
     472:	33 1f       	adc	r19, r19
     474:	4a 95       	dec	r20
     476:	e1 f7       	brne	.-8      	; 0x470 <__vector_11+0x30a>
     478:	82 2b       	or	r24, r18
     47a:	93 2b       	or	r25, r19
     47c:	90 93 1d 01 	sts	0x011D, r25
     480:	80 93 1c 01 	sts	0x011C, r24
											address=Y1NG_ADDRESS;
     484:	86 e0       	ldi	r24, 0x06	; 6
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	df cf       	rjmp	.-66     	; 0x448 <__vector_11+0x2e2>
											break;
										case Y1NG_ADDRESS:
											word= m_CALIBRATION_BYTE6_TO_Z1G(aBuffer[6]) | m_CALIBRATION_BYTE7_TO_Z1G(aBuffer[7]) | m_CALIBRATION_BYTE8_TO_Z1G(aBuffer[8]) ;//(((unsigned short)(aBuffer[6]&0x03))<<8) | (((unsigned short)(aBuffer[7]&0x7f))<<1) | (((unsigned short)(aBuffer[8]&0x40))>>6);
     48a:	20 91 3c 02 	lds	r18, 0x023C
     48e:	30 e0       	ldi	r19, 0x00	; 0
     490:	22 0f       	add	r18, r18
     492:	33 1f       	adc	r19, r19
     494:	30 70       	andi	r19, 0x00	; 0
     496:	80 91 3b 02 	lds	r24, 0x023B
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	83 70       	andi	r24, 0x03	; 3
     49e:	90 70       	andi	r25, 0x00	; 0
     4a0:	98 2f       	mov	r25, r24
     4a2:	88 27       	eor	r24, r24
     4a4:	28 2b       	or	r18, r24
     4a6:	39 2b       	or	r19, r25
     4a8:	80 91 3d 02 	lds	r24, 0x023D
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	80 74       	andi	r24, 0x40	; 64
     4b0:	90 70       	andi	r25, 0x00	; 0
     4b2:	16 e0       	ldi	r17, 0x06	; 6
     4b4:	96 95       	lsr	r25
     4b6:	87 95       	ror	r24
     4b8:	1a 95       	dec	r17
     4ba:	e1 f7       	brne	.-8      	; 0x4b4 <__vector_11+0x34e>
     4bc:	28 2b       	or	r18, r24
     4be:	39 2b       	or	r19, r25
     4c0:	30 93 1d 01 	sts	0x011D, r19
     4c4:	20 93 1c 01 	sts	0x011C, r18
											address=Z1G_ADDRESS;
     4c8:	88 e0       	ldi	r24, 0x08	; 8
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	bd cf       	rjmp	.-134    	; 0x448 <__vector_11+0x2e2>
											break;
										case Z1G_ADDRESS:
											word= m_CALIBRATION_BYTE8_TO_ZN1G(aBuffer[8]) |m_CALIBRATION_BYTE9_TO_ZN1G(aBuffer[9]);
     4ce:	20 91 3e 02 	lds	r18, 0x023E
     4d2:	30 e0       	ldi	r19, 0x00	; 0
     4d4:	28 77       	andi	r18, 0x78	; 120
     4d6:	30 70       	andi	r19, 0x00	; 0
     4d8:	b3 e0       	ldi	r27, 0x03	; 3
     4da:	36 95       	lsr	r19
     4dc:	27 95       	ror	r18
     4de:	ba 95       	dec	r27
     4e0:	e1 f7       	brne	.-8      	; 0x4da <__vector_11+0x374>
     4e2:	80 91 3d 02 	lds	r24, 0x023D
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	8f 73       	andi	r24, 0x3F	; 63
     4ea:	90 70       	andi	r25, 0x00	; 0
     4ec:	a4 e0       	ldi	r26, 0x04	; 4
     4ee:	88 0f       	add	r24, r24
     4f0:	99 1f       	adc	r25, r25
     4f2:	aa 95       	dec	r26
     4f4:	e1 f7       	brne	.-8      	; 0x4ee <__vector_11+0x388>
     4f6:	28 2b       	or	r18, r24
     4f8:	39 2b       	or	r19, r25
     4fa:	30 93 1d 01 	sts	0x011D, r19
     4fe:	20 93 1c 01 	sts	0x011C, r18
											address=Z1NG_ADDRESS;
     502:	8a e0       	ldi	r24, 0x0A	; 10
     504:	90 e0       	ldi	r25, 0x00	; 0
     506:	90 93 01 01 	sts	0x0101, r25
     50a:	80 93 00 01 	sts	0x0100, r24
											processed_counter=command_counter;
     50e:	80 91 12 01 	lds	r24, 0x0112
     512:	80 93 16 01 	sts	0x0116, r24
     516:	1e c0       	rjmp	.+60     	; 0x554 <__vector_11+0x3ee>
											break;
										default:
											word=m_CALIBRATION_BYTE1_TO_X1G(aBuffer[1])| m_CALIBRATION_BYTE2_TO_X1G(aBuffer[2]);																		
     518:	20 91 37 02 	lds	r18, 0x0237
     51c:	30 e0       	ldi	r19, 0x00	; 0
     51e:	20 77       	andi	r18, 0x70	; 112
     520:	30 70       	andi	r19, 0x00	; 0
     522:	f4 e0       	ldi	r31, 0x04	; 4
     524:	36 95       	lsr	r19
     526:	27 95       	ror	r18
     528:	fa 95       	dec	r31
     52a:	e1 f7       	brne	.-8      	; 0x524 <__vector_11+0x3be>
     52c:	80 91 36 02 	lds	r24, 0x0236
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	8f 77       	andi	r24, 0x7F	; 127
     534:	90 70       	andi	r25, 0x00	; 0
     536:	e3 e0       	ldi	r30, 0x03	; 3
     538:	88 0f       	add	r24, r24
     53a:	99 1f       	adc	r25, r25
     53c:	ea 95       	dec	r30
     53e:	e1 f7       	brne	.-8      	; 0x538 <__vector_11+0x3d2>
     540:	28 2b       	or	r18, r24
     542:	39 2b       	or	r19, r25
     544:	30 93 1d 01 	sts	0x011D, r19
     548:	20 93 1c 01 	sts	0x011C, r18
											address=X1G_ADDRESS;
     54c:	10 92 01 01 	sts	0x0101, r1
     550:	10 92 00 01 	sts	0x0100, r1
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
     554:	60 91 1c 01 	lds	r22, 0x011C
     558:	70 91 1d 01 	lds	r23, 0x011D
     55c:	80 91 00 01 	lds	r24, 0x0100
     560:	90 91 01 01 	lds	r25, 0x0101
     564:	43 e8       	ldi	r20, 0x83	; 131
     566:	50 e0       	ldi	r21, 0x00	; 0
     568:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <__eewr_word>
     56c:	dc c0       	rjmp	.+440    	; 0x726 <__vector_11+0x5c0>
							}															
							//enable global interrupts
							break;
						case (unsigned char) GET_CALIBRATION_VALUES:	
												
							if (eeprom_is_ready())
     56e:	f9 99       	sbic	0x1f, 1	; 31
     570:	da c0       	rjmp	.+436    	; 0x726 <__vector_11+0x5c0>
							{								
								//do nothing if battery is low
								if (_atmega324p_a2dConvert10bit(ADC4)<350)
     572:	84 e0       	ldi	r24, 0x04	; 4
     574:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     578:	8e 55       	subi	r24, 0x5E	; 94
     57a:	91 40       	sbci	r25, 0x01	; 1
     57c:	08 f4       	brcc	.+2      	; 0x580 <__vector_11+0x41a>
     57e:	d3 c0       	rjmp	.+422    	; 0x726 <__vector_11+0x5c0>
									break;
								else								
								{
									switch(address)
     580:	80 91 00 01 	lds	r24, 0x0100
     584:	90 91 01 01 	lds	r25, 0x0101
     588:	84 30       	cpi	r24, 0x04	; 4
     58a:	91 05       	cpc	r25, r1
     58c:	09 f4       	brne	.+2      	; 0x590 <__vector_11+0x42a>
     58e:	46 c0       	rjmp	.+140    	; 0x61c <__vector_11+0x4b6>
     590:	85 30       	cpi	r24, 0x05	; 5
     592:	91 05       	cpc	r25, r1
     594:	30 f4       	brcc	.+12     	; 0x5a2 <__vector_11+0x43c>
     596:	00 97       	sbiw	r24, 0x00	; 0
     598:	81 f0       	breq	.+32     	; 0x5ba <__vector_11+0x454>
     59a:	02 97       	sbiw	r24, 0x02	; 2
     59c:	09 f0       	breq	.+2      	; 0x5a0 <__vector_11+0x43a>
     59e:	b0 c0       	rjmp	.+352    	; 0x700 <__vector_11+0x59a>
     5a0:	21 c0       	rjmp	.+66     	; 0x5e4 <__vector_11+0x47e>
     5a2:	88 30       	cpi	r24, 0x08	; 8
     5a4:	91 05       	cpc	r25, r1
     5a6:	09 f4       	brne	.+2      	; 0x5aa <__vector_11+0x444>
     5a8:	70 c0       	rjmp	.+224    	; 0x68a <__vector_11+0x524>
     5aa:	8a 30       	cpi	r24, 0x0A	; 10
     5ac:	91 05       	cpc	r25, r1
     5ae:	09 f4       	brne	.+2      	; 0x5b2 <__vector_11+0x44c>
     5b0:	88 c0       	rjmp	.+272    	; 0x6c2 <__vector_11+0x55c>
     5b2:	06 97       	sbiw	r24, 0x06	; 6
     5b4:	09 f0       	breq	.+2      	; 0x5b8 <__vector_11+0x452>
     5b6:	a4 c0       	rjmp	.+328    	; 0x700 <__vector_11+0x59a>
     5b8:	4f c0       	rjmp	.+158    	; 0x658 <__vector_11+0x4f2>
									{
										case X1G_ADDRESS:
											aBuffer[1]= m_CALIBRATION_X1G_TO_BYTE1(word);									
     5ba:	80 91 1c 01 	lds	r24, 0x011C
     5be:	90 91 1d 01 	lds	r25, 0x011D
     5c2:	73 e0       	ldi	r23, 0x03	; 3
     5c4:	96 95       	lsr	r25
     5c6:	87 95       	ror	r24
     5c8:	7a 95       	dec	r23
     5ca:	e1 f7       	brne	.-8      	; 0x5c4 <__vector_11+0x45e>
     5cc:	8f 77       	andi	r24, 0x7F	; 127
     5ce:	80 93 36 02 	sts	0x0236, r24
											aBuffer[2]= m_CALIBRATION_X1G_TO_BYTE2(word);
     5d2:	80 91 1c 01 	lds	r24, 0x011C
     5d6:	82 95       	swap	r24
     5d8:	80 77       	andi	r24, 0x70	; 112
     5da:	80 93 37 02 	sts	0x0237, r24
											address=X1NG_ADDRESS;
     5de:	82 e0       	ldi	r24, 0x02	; 2
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	17 c0       	rjmp	.+46     	; 0x612 <__vector_11+0x4ac>
											break;
										case X1NG_ADDRESS:
											aBuffer[2]|= m_CALIBRATION_XN1G_TO_BYTE2(word);
     5e4:	80 91 1c 01 	lds	r24, 0x011C
     5e8:	90 91 1d 01 	lds	r25, 0x011D
     5ec:	66 e0       	ldi	r22, 0x06	; 6
     5ee:	96 95       	lsr	r25
     5f0:	87 95       	ror	r24
     5f2:	6a 95       	dec	r22
     5f4:	e1 f7       	brne	.-8      	; 0x5ee <__vector_11+0x488>
     5f6:	8f 70       	andi	r24, 0x0F	; 15
     5f8:	20 91 37 02 	lds	r18, 0x0237
     5fc:	82 2b       	or	r24, r18
     5fe:	80 93 37 02 	sts	0x0237, r24
											aBuffer[3] =m_CALIBRATION_XN1G_TO_BYTE3(word);
     602:	80 91 1c 01 	lds	r24, 0x011C
     606:	88 0f       	add	r24, r24
     608:	8e 77       	andi	r24, 0x7E	; 126
     60a:	80 93 38 02 	sts	0x0238, r24
											address=Y1G_ADDRESS;
     60e:	84 e0       	ldi	r24, 0x04	; 4
     610:	90 e0       	ldi	r25, 0x00	; 0
     612:	90 93 01 01 	sts	0x0101, r25
     616:	80 93 00 01 	sts	0x0100, r24
     61a:	79 c0       	rjmp	.+242    	; 0x70e <__vector_11+0x5a8>
											break;
										case Y1G_ADDRESS:
											aBuffer[3]|= m_CALIBRATION_Y1G_TO_BYTE3(word);
     61c:	80 91 1d 01 	lds	r24, 0x011D
     620:	86 95       	lsr	r24
     622:	81 70       	andi	r24, 0x01	; 1
     624:	90 91 38 02 	lds	r25, 0x0238
     628:	89 2b       	or	r24, r25
     62a:	80 93 38 02 	sts	0x0238, r24
											aBuffer[4] = m_CALIBRATION_Y1G_TO_BYTE4(word);
     62e:	80 91 1c 01 	lds	r24, 0x011C
     632:	90 91 1d 01 	lds	r25, 0x011D
     636:	96 95       	lsr	r25
     638:	87 95       	ror	r24
     63a:	96 95       	lsr	r25
     63c:	87 95       	ror	r24
     63e:	8f 77       	andi	r24, 0x7F	; 127
     640:	80 93 39 02 	sts	0x0239, r24
											aBuffer[5] =  m_CALIBRATION_Y1G_TO_BYTE5(word);
     644:	80 91 1c 01 	lds	r24, 0x011C
     648:	82 95       	swap	r24
     64a:	88 0f       	add	r24, r24
     64c:	80 76       	andi	r24, 0x60	; 96
     64e:	80 93 3a 02 	sts	0x023A, r24
											address=Y1NG_ADDRESS;
     652:	86 e0       	ldi	r24, 0x06	; 6
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	dd cf       	rjmp	.-70     	; 0x612 <__vector_11+0x4ac>
											break;
										case Y1NG_ADDRESS:
											aBuffer[5]|= m_CALIBRATION_YN1G_TO_BYTE5(word);
     658:	80 91 1c 01 	lds	r24, 0x011C
     65c:	90 91 1d 01 	lds	r25, 0x011D
     660:	45 e0       	ldi	r20, 0x05	; 5
     662:	96 95       	lsr	r25
     664:	87 95       	ror	r24
     666:	4a 95       	dec	r20
     668:	e1 f7       	brne	.-8      	; 0x662 <__vector_11+0x4fc>
     66a:	8f 71       	andi	r24, 0x1F	; 31
     66c:	20 91 3a 02 	lds	r18, 0x023A
     670:	82 2b       	or	r24, r18
     672:	80 93 3a 02 	sts	0x023A, r24
											aBuffer[6] = m_CALIBRATION_YN1G_TO_BYTE6(word);
     676:	80 91 1c 01 	lds	r24, 0x011C
     67a:	88 0f       	add	r24, r24
     67c:	88 0f       	add	r24, r24
     67e:	8c 77       	andi	r24, 0x7C	; 124
     680:	80 93 3b 02 	sts	0x023B, r24
											address=Z1G_ADDRESS;
     684:	88 e0       	ldi	r24, 0x08	; 8
     686:	90 e0       	ldi	r25, 0x00	; 0
     688:	c4 cf       	rjmp	.-120    	; 0x612 <__vector_11+0x4ac>
											break;
										case Z1G_ADDRESS:
											aBuffer[6] |= m_CALIBRATION_Z1G_TO_BYTE6(word);
     68a:	80 91 1d 01 	lds	r24, 0x011D
     68e:	83 70       	andi	r24, 0x03	; 3
     690:	90 91 3b 02 	lds	r25, 0x023B
     694:	89 2b       	or	r24, r25
     696:	80 93 3b 02 	sts	0x023B, r24
											aBuffer[7] = m_CALIBRATION_Z1G_TO_BYTE7(word);
     69a:	80 91 1c 01 	lds	r24, 0x011C
     69e:	90 91 1d 01 	lds	r25, 0x011D
     6a2:	96 95       	lsr	r25
     6a4:	87 95       	ror	r24
     6a6:	8f 77       	andi	r24, 0x7F	; 127
     6a8:	80 93 3c 02 	sts	0x023C, r24
											aBuffer[8] = m_CALIBRATION_Z1G_TO_BYTE8(word);
     6ac:	80 91 1c 01 	lds	r24, 0x011C
     6b0:	82 95       	swap	r24
     6b2:	88 0f       	add	r24, r24
     6b4:	88 0f       	add	r24, r24
     6b6:	80 74       	andi	r24, 0x40	; 64
     6b8:	80 93 3d 02 	sts	0x023D, r24
											address=Z1NG_ADDRESS;
     6bc:	8a e0       	ldi	r24, 0x0A	; 10
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	a8 cf       	rjmp	.-176    	; 0x612 <__vector_11+0x4ac>
											break;
										case Z1NG_ADDRESS:
											aBuffer[8] |= m_CALIBRATION_ZN1G_TO_BYTE8(word);
     6c2:	80 91 1c 01 	lds	r24, 0x011C
     6c6:	90 91 1d 01 	lds	r25, 0x011D
     6ca:	24 e0       	ldi	r18, 0x04	; 4
     6cc:	96 95       	lsr	r25
     6ce:	87 95       	ror	r24
     6d0:	2a 95       	dec	r18
     6d2:	e1 f7       	brne	.-8      	; 0x6cc <__vector_11+0x566>
     6d4:	8f 73       	andi	r24, 0x3F	; 63
     6d6:	20 91 3d 02 	lds	r18, 0x023D
     6da:	82 2b       	or	r24, r18
     6dc:	80 93 3d 02 	sts	0x023D, r24
											aBuffer[9] = m_CALIBRATION_ZN1G_TO_BYTE9(word);
     6e0:	80 91 1c 01 	lds	r24, 0x011C
     6e4:	88 0f       	add	r24, r24
     6e6:	88 0f       	add	r24, r24
     6e8:	88 0f       	add	r24, r24
     6ea:	88 77       	andi	r24, 0x78	; 120
     6ec:	80 93 3e 02 	sts	0x023E, r24
											processed_counter=command_counter;
     6f0:	80 91 12 01 	lds	r24, 0x0112
     6f4:	80 93 16 01 	sts	0x0116, r24
											response_length=10;
     6f8:	8a e0       	ldi	r24, 0x0A	; 10
     6fa:	80 93 1e 01 	sts	0x011E, r24
     6fe:	07 c0       	rjmp	.+14     	; 0x70e <__vector_11+0x5a8>
											break;
										default:
											aBuffer[0]=m_CALIBRATION_BYTE0;	
     700:	84 ec       	ldi	r24, 0xC4	; 196
     702:	80 93 35 02 	sts	0x0235, r24
											address=X1G_ADDRESS;
     706:	10 92 01 01 	sts	0x0101, r1
     70a:	10 92 00 01 	sts	0x0100, r1
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    return __eerd_word (__p, eeprom_read_byte);
     70e:	80 91 00 01 	lds	r24, 0x0100
     712:	90 91 01 01 	lds	r25, 0x0101
     716:	6b e7       	ldi	r22, 0x7B	; 123
     718:	70 e0       	ldi	r23, 0x00	; 0
     71a:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <__eerd_word>
											break;																						
									}
									word=eeprom_read_word((uint16_t *)((uint16_t)address));
     71e:	90 93 1d 01 	sts	0x011D, r25
     722:	80 93 1c 01 	sts	0x011C, r24
						default:	
							break;

					}

					if (processed_counter==command_counter){					
     726:	90 91 16 01 	lds	r25, 0x0116
     72a:	80 91 12 01 	lds	r24, 0x0112
     72e:	98 17       	cp	r25, r24
     730:	71 f5       	brne	.+92     	; 0x78e <__vector_11+0x628>
							
				
						for (i=0;(i<response_length);i++)											
     732:	10 92 2f 01 	sts	0x012F, r1
     736:	0b c0       	rjmp	.+22     	; 0x74e <__vector_11+0x5e8>
							TransmitByte(aBuffer[i]);										
     738:	f0 e0       	ldi	r31, 0x00	; 0
     73a:	eb 5c       	subi	r30, 0xCB	; 203
     73c:	fd 4f       	sbci	r31, 0xFD	; 253
     73e:	80 81       	ld	r24, Z
     740:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TransmitByte>
					}

					if (processed_counter==command_counter){					
							
				
						for (i=0;(i<response_length);i++)											
     744:	80 91 2f 01 	lds	r24, 0x012F
     748:	8f 5f       	subi	r24, 0xFF	; 255
     74a:	80 93 2f 01 	sts	0x012F, r24
     74e:	e0 91 2f 01 	lds	r30, 0x012F
     752:	80 91 1e 01 	lds	r24, 0x011E
     756:	e8 17       	cp	r30, r24
     758:	78 f3       	brcs	.-34     	; 0x738 <__vector_11+0x5d2>
     75a:	07 c0       	rjmp	.+14     	; 0x76a <__vector_11+0x604>
						address=0xffff;
						response_length=0;
						
					}
				} //if command timed out
				else if (command_timer>=MAX_COMMAND_TIMER)
     75c:	80 91 14 01 	lds	r24, 0x0114
     760:	90 91 15 01 	lds	r25, 0x0115
     764:	8f 3f       	cpi	r24, 0xFF	; 255
     766:	91 05       	cpc	r25, r1
     768:	90 f0       	brcs	.+36     	; 0x78e <__vector_11+0x628>
				{
							
					command_length=0;
     76a:	10 92 13 01 	sts	0x0113, r1
					command_counter=0;
     76e:	10 92 12 01 	sts	0x0112, r1
					command_timer=0;
     772:	10 92 15 01 	sts	0x0115, r1
     776:	10 92 14 01 	sts	0x0114, r1
					processed_counter=0;				
     77a:	10 92 16 01 	sts	0x0116, r1
					address=0xffff;
     77e:	8f ef       	ldi	r24, 0xFF	; 255
     780:	9f ef       	ldi	r25, 0xFF	; 255
     782:	90 93 01 01 	sts	0x0101, r25
     786:	80 93 00 01 	sts	0x0100, r24
					response_length=0;
     78a:	10 92 1e 01 	sts	0x011E, r1
				}
					
				if (paused==0){
     78e:	80 91 0f 01 	lds	r24, 0x010F
     792:	88 23       	and	r24, r24
     794:	09 f0       	breq	.+2      	; 0x798 <__vector_11+0x632>
     796:	b9 c0       	rjmp	.+370    	; 0x90a <__stack+0xb>
					alive_timer++;					
     798:	80 91 17 01 	lds	r24, 0x0117
     79c:	90 91 18 01 	lds	r25, 0x0118
     7a0:	01 96       	adiw	r24, 0x01	; 1
     7a2:	90 93 18 01 	sts	0x0118, r25
     7a6:	80 93 17 01 	sts	0x0117, r24
					if (alive_timer>=2730) //if no acks for approx 30 seconds, reset radio
     7aa:	8a 5a       	subi	r24, 0xAA	; 170
     7ac:	9a 40       	sbci	r25, 0x0A	; 10
     7ae:	98 f0       	brcs	.+38     	; 0x7d6 <__vector_11+0x670>
					{
					
						//NEVER RESET						
						//_atmega324p_reset();
						_bluetooth_turn_off();
     7b0:	0e 94 0f 0a 	call	0x141e	; 0x141e <_bluetooth_turn_off>
     7b4:	80 e0       	ldi	r24, 0x00	; 0
     7b6:	90 e0       	ldi	r25, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     7b8:	20 e1       	ldi	r18, 0x10	; 16
     7ba:	37 e2       	ldi	r19, 0x27	; 39
     7bc:	f9 01       	movw	r30, r18
     7be:	31 97       	sbiw	r30, 0x01	; 1
     7c0:	f1 f7       	brne	.-4      	; 0x7be <__vector_11+0x658>
						for (int zz=0;(zz<100);zz++)
     7c2:	01 96       	adiw	r24, 0x01	; 1
     7c4:	84 36       	cpi	r24, 0x64	; 100
     7c6:	91 05       	cpc	r25, r1
     7c8:	c9 f7       	brne	.-14     	; 0x7bc <__vector_11+0x656>
							_delay_ms(5);
						_bluetooth_turn_on();
     7ca:	0e 94 04 0a 	call	0x1408	; 0x1408 <_bluetooth_turn_on>
						alive_timer=0;					
     7ce:	10 92 18 01 	sts	0x0118, r1
     7d2:	10 92 17 01 	sts	0x0117, r1
					}
					 					
					adc_result[ADC1]=_atmega324p_a2dConvert10bit(ADC1);
     7d6:	81 e0       	ldi	r24, 0x01	; 1
     7d8:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     7dc:	90 93 27 01 	sts	0x0127, r25
     7e0:	80 93 26 01 	sts	0x0126, r24
					adc_result[ADC2]=_atmega324p_a2dConvert10bit(ADC2);
     7e4:	82 e0       	ldi	r24, 0x02	; 2
     7e6:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     7ea:	90 93 29 01 	sts	0x0129, r25
     7ee:	80 93 28 01 	sts	0x0128, r24
					adc_result[ADC3]=_atmega324p_a2dConvert10bit(ADC3);
     7f2:	83 e0       	ldi	r24, 0x03	; 3
     7f4:	0e 94 ac 0c 	call	0x1958	; 0x1958 <_atmega324p_a2dConvert10bit>
     7f8:	bc 01       	movw	r22, r24
     7fa:	90 93 2b 01 	sts	0x012B, r25
     7fe:	80 93 2a 01 	sts	0x012A, r24
				
				//tag if close to ack
					if (ack==0xff)
     802:	80 91 22 01 	lds	r24, 0x0122
     806:	40 91 28 01 	lds	r20, 0x0128
     80a:	50 91 29 01 	lds	r21, 0x0129
     80e:	20 91 26 01 	lds	r18, 0x0126
     812:	30 91 27 01 	lds	r19, 0x0127
     816:	8e 01       	movw	r16, r28
     818:	05 5f       	subi	r16, 0xF5	; 245
     81a:	1f 4f       	sbci	r17, 0xFF	; 255
     81c:	8f 3f       	cpi	r24, 0xFF	; 255
     81e:	b1 f4       	brne	.+44     	; 0x84c <__vector_11+0x6e6>
						TransmitFrame(encode(0,adc_result[ADC3], adc_result[ADC2], adc_result[ADC1]));
     820:	80 e0       	ldi	r24, 0x00	; 0
     822:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <encode>
     826:	2b 87       	std	Y+11, r18	; 0x0b
     828:	3c 87       	std	Y+12, r19	; 0x0c
     82a:	4d 87       	std	Y+13, r20	; 0x0d
     82c:	5e 87       	std	Y+14, r21	; 0x0e
     82e:	6f 87       	std	Y+15, r22	; 0x0f
     830:	de 01       	movw	r26, r28
     832:	11 96       	adiw	r26, 0x01	; 1
     834:	f8 01       	movw	r30, r16
     836:	85 e0       	ldi	r24, 0x05	; 5
     838:	01 90       	ld	r0, Z+
     83a:	0d 92       	st	X+, r0
     83c:	81 50       	subi	r24, 0x01	; 1
     83e:	e1 f7       	brne	.-8      	; 0x838 <__vector_11+0x6d2>
     840:	49 81       	ldd	r20, Y+1	; 0x01
     842:	5a 81       	ldd	r21, Y+2	; 0x02
     844:	6b 81       	ldd	r22, Y+3	; 0x03
     846:	7c 81       	ldd	r23, Y+4	; 0x04
     848:	8d 81       	ldd	r24, Y+5	; 0x05
     84a:	15 c0       	rjmp	.+42     	; 0x876 <__vector_11+0x710>
					//	TransmitFrame(encode(1,sequence & 0xff,(sequence>>8)&0xff,0));//adc_result[ADC3], adc_result[ADC2], adc_result[ADC1]));
					else  //otherwise dont tag
						TransmitFrame(encode(0,adc_result[ADC3], adc_result[ADC2], adc_result[ADC1]));
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <encode>
     852:	2b 87       	std	Y+11, r18	; 0x0b
     854:	3c 87       	std	Y+12, r19	; 0x0c
     856:	4d 87       	std	Y+13, r20	; 0x0d
     858:	5e 87       	std	Y+14, r21	; 0x0e
     85a:	6f 87       	std	Y+15, r22	; 0x0f
     85c:	de 01       	movw	r26, r28
     85e:	16 96       	adiw	r26, 0x06	; 6
     860:	f8 01       	movw	r30, r16
     862:	85 e0       	ldi	r24, 0x05	; 5
     864:	01 90       	ld	r0, Z+
     866:	0d 92       	st	X+, r0
     868:	81 50       	subi	r24, 0x01	; 1
     86a:	e1 f7       	brne	.-8      	; 0x864 <__vector_11+0x6fe>
     86c:	4e 81       	ldd	r20, Y+6	; 0x06
     86e:	5f 81       	ldd	r21, Y+7	; 0x07
     870:	68 85       	ldd	r22, Y+8	; 0x08
     872:	79 85       	ldd	r23, Y+9	; 0x09
     874:	8a 85       	ldd	r24, Y+10	; 0x0a
     876:	0e 94 90 00 	call	0x120	; 0x120 <TransmitFrame>
					//	TransmitFrame(encode(0,sequence & 0xff,(sequence>>8)&0xff,0));///adc_result[ADC3], adc_result[ADC2], adc_result[ADC1]));
	
					sequence++;
     87a:	80 91 1f 01 	lds	r24, 0x011F
     87e:	90 91 20 01 	lds	r25, 0x0120
     882:	01 96       	adiw	r24, 0x01	; 1
     884:	90 93 20 01 	sts	0x0120, r25
     888:	80 93 1f 01 	sts	0x011F, r24
     88c:	3e c0       	rjmp	.+124    	; 0x90a <__stack+0xb>
				}

			}else{  //not connected

				paused=0;
     88e:	10 92 0f 01 	sts	0x010F, r1
				//reset the radio once
				if (disconnected_reset==0){
     892:	80 91 02 01 	lds	r24, 0x0102
     896:	88 23       	and	r24, r24
     898:	91 f4       	brne	.+36     	; 0x8be <__vector_11+0x758>

					// DON'T RESET 
					//_atmega324p_reset();

					_bluetooth_turn_off();
     89a:	0e 94 0f 0a 	call	0x141e	; 0x141e <_bluetooth_turn_off>
     89e:	80 e0       	ldi	r24, 0x00	; 0
     8a0:	90 e0       	ldi	r25, 0x00	; 0
     8a2:	20 e1       	ldi	r18, 0x10	; 16
     8a4:	37 e2       	ldi	r19, 0x27	; 39
     8a6:	f9 01       	movw	r30, r18
     8a8:	31 97       	sbiw	r30, 0x01	; 1
     8aa:	f1 f7       	brne	.-4      	; 0x8a8 <__vector_11+0x742>
					for (int zz=0;(zz<100);zz++)
     8ac:	01 96       	adiw	r24, 0x01	; 1
     8ae:	84 36       	cpi	r24, 0x64	; 100
     8b0:	91 05       	cpc	r25, r1
     8b2:	c9 f7       	brne	.-14     	; 0x8a6 <__vector_11+0x740>
						_delay_ms(5);
					_bluetooth_turn_on();
     8b4:	0e 94 04 0a 	call	0x1408	; 0x1408 <_bluetooth_turn_on>
					disconnected_reset=1;
     8b8:	81 e0       	ldi	r24, 0x01	; 1
     8ba:	80 93 02 01 	sts	0x0102, r24
				}

				sleep_counter++;
     8be:	80 91 07 01 	lds	r24, 0x0107
     8c2:	90 91 08 01 	lds	r25, 0x0108
     8c6:	01 96       	adiw	r24, 0x01	; 1
     8c8:	90 93 08 01 	sts	0x0108, r25
     8cc:	80 93 07 01 	sts	0x0107, r24

				if (sleep_counter>=91)
     8d0:	8b 35       	cpi	r24, 0x5B	; 91
     8d2:	91 05       	cpc	r25, r1
     8d4:	68 f0       	brcs	.+26     	; 0x8f0 <__vector_11+0x78a>
				{
					sleep_counter=0;
     8d6:	10 92 08 01 	sts	0x0108, r1
     8da:	10 92 07 01 	sts	0x0107, r1
					sleep_counter2++;
     8de:	80 91 09 01 	lds	r24, 0x0109
     8e2:	90 91 0a 01 	lds	r25, 0x010A
     8e6:	01 96       	adiw	r24, 0x01	; 1
     8e8:	90 93 0a 01 	sts	0x010A, r25
     8ec:	80 93 09 01 	sts	0x0109, r24
				}
				
				//sleep after 1 hour
				if (sleep_counter2>3600)				
     8f0:	80 91 09 01 	lds	r24, 0x0109
     8f4:	90 91 0a 01 	lds	r25, 0x010A
     8f8:	81 51       	subi	r24, 0x11	; 17
     8fa:	9e 40       	sbci	r25, 0x0E	; 14
     8fc:	30 f0       	brcs	.+12     	; 0x90a <__stack+0xb>
					sleep=1;					
     8fe:	81 e0       	ldi	r24, 0x01	; 1
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	90 93 0c 01 	sts	0x010C, r25
     906:	80 93 0b 01 	sts	0x010B, r24
			}
				
		}

}
     90a:	2f 96       	adiw	r28, 0x0f	; 15
     90c:	de bf       	out	0x3e, r29	; 62
     90e:	cd bf       	out	0x3d, r28	; 61
     910:	cf 91       	pop	r28
     912:	df 91       	pop	r29
     914:	ff 91       	pop	r31
     916:	ef 91       	pop	r30
     918:	bf 91       	pop	r27
     91a:	af 91       	pop	r26
     91c:	9f 91       	pop	r25
     91e:	8f 91       	pop	r24
     920:	7f 91       	pop	r23
     922:	6f 91       	pop	r22
     924:	5f 91       	pop	r21
     926:	4f 91       	pop	r20
     928:	3f 91       	pop	r19
     92a:	2f 91       	pop	r18
     92c:	1f 91       	pop	r17
     92e:	0f 91       	pop	r16
     930:	0f 90       	pop	r0
     932:	0f be       	out	0x3f, r0	; 63
     934:	0f 90       	pop	r0
     936:	1f 90       	pop	r1
     938:	18 95       	reti

0000093a <main>:




int main()
{
     93a:	0f 93       	push	r16
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
	//disable watchdog to avoid reset
	MCUSR = 0;
     942:	14 be       	out	0x34, r1	; 52
	wdt_disable();
     944:	88 e1       	ldi	r24, 0x18	; 24
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	80 93 60 00 	sts	0x0060, r24
     94e:	10 92 60 00 	sts	0x0060, r1
     952:	0f be       	out	0x3f, r0	; 63
	_atmega_initialize(CPU_CLK_PRESCALAR_1024);
     954:	86 e0       	ldi	r24, 0x06	; 6
     956:	0e 94 55 0a 	call	0x14aa	; 0x14aa <_atmega_initialize>
     95a:	8c e0       	ldi	r24, 0x0C	; 12
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	6b e7       	ldi	r22, 0x7B	; 123
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	0e 94 f6 0d 	call	0x1bec	; 0x1bec <__eerd_word>
	
	word=eeprom_read_word((uint16_t *)((uint16_t)BAUD_RATE_ADDRESS));
	if (word==BAUD_9600)
     966:	83 30       	cpi	r24, 0x03	; 3
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <main+0x38>
		word=ATMEGA324P_BAUD_9600;
     96c:	83 e3       	ldi	r24, 0x33	; 51
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	05 c0       	rjmp	.+10     	; 0x97c <main+0x42>
	else if (word==BAUD_19200)
     972:	84 30       	cpi	r24, 0x04	; 4
     974:	91 05       	cpc	r25, r1
     976:	39 f4       	brne	.+14     	; 0x986 <main+0x4c>
		word=ATMEGA324P_BAUD_19200;
     978:	89 e1       	ldi	r24, 0x19	; 25
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	90 93 1d 01 	sts	0x011D, r25
     980:	80 93 1c 01 	sts	0x011C, r24
     984:	1d c0       	rjmp	.+58     	; 0x9c0 <main+0x86>
	else if (word==BAUD_28800)
     986:	85 30       	cpi	r24, 0x05	; 5
     988:	91 05       	cpc	r25, r1
     98a:	19 f4       	brne	.+6      	; 0x992 <main+0x58>
		word=ATMEGA324P_BAUD_28800;
     98c:	80 e1       	ldi	r24, 0x10	; 16
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	f5 cf       	rjmp	.-22     	; 0x97c <main+0x42>
	else if (word==BAUD_38400)
     992:	86 30       	cpi	r24, 0x06	; 6
     994:	91 05       	cpc	r25, r1
     996:	19 f4       	brne	.+6      	; 0x99e <main+0x64>
		word=ATMEGA324P_BAUD_38400;
     998:	8c e0       	ldi	r24, 0x0C	; 12
     99a:	90 e0       	ldi	r25, 0x00	; 0
     99c:	ef cf       	rjmp	.-34     	; 0x97c <main+0x42>
	else if (word==BAUD_57600)
     99e:	07 97       	sbiw	r24, 0x07	; 7
     9a0:	19 f4       	brne	.+6      	; 0x9a8 <main+0x6e>
		word=ATMEGA324P_BAUD_57600;
     9a2:	88 e0       	ldi	r24, 0x08	; 8
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	ea cf       	rjmp	.-44     	; 0x97c <main+0x42>
	else
	{
		word=ATMEGA324P_BAUD_38400;
     9a8:	8c e0       	ldi	r24, 0x0C	; 12
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	90 93 1d 01 	sts	0x011D, r25
     9b0:	80 93 1c 01 	sts	0x011C, r24
    Write a word \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_word (__p, __value, eeprom_write_byte);
     9b4:	66 e0       	ldi	r22, 0x06	; 6
     9b6:	70 e0       	ldi	r23, 0x00	; 0
     9b8:	43 e8       	ldi	r20, 0x83	; 131
     9ba:	50 e0       	ldi	r21, 0x00	; 0
     9bc:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <__eewr_word>
		eeprom_write_word((uint16_t *)BAUD_RATE_ADDRESS,BAUD_38400);
	}	
	_atmega324p_init(word);
     9c0:	80 91 1c 01 	lds	r24, 0x011C
     9c4:	90 91 1d 01 	lds	r25, 0x011D
     9c8:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <_atmega324p_init>
	_atmega324p_green_led_off();
     9cc:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <_atmega324p_green_led_off>

	led_counter=0;
     9d0:	10 92 06 01 	sts	0x0106, r1
     9d4:	10 92 05 01 	sts	0x0105, r1
	_rn41_on();
     9d8:	0e 94 78 05 	call	0xaf0	; 0xaf0 <_rn41_on>
	_mma7260qt_wakeup();
     9dc:	0e 94 75 0d 	call	0x1aea	; 0x1aea <_mma7260qt_wakeup>
     9e0:	00 e1       	ldi	r16, 0x10	; 16
     9e2:	17 e2       	ldi	r17, 0x27	; 39
   	 //MCUCR = 0x40;
	 //sleep_cpu();     
	 //sleep_disable();
	 	_delay_ms(5);
		if (!_atmega324p_shutdown())
			sleep=1;		 
     9e4:	c1 e0       	ldi	r28, 0x01	; 1
     9e6:	d0 e0       	ldi	r29, 0x00	; 0
     9e8:	41 c0       	rjmp	.+130    	; 0xa6c <main+0x132>
     9ea:	c8 01       	movw	r24, r16
     9ec:	01 97       	sbiw	r24, 0x01	; 1
     9ee:	f1 f7       	brne	.-4      	; 0x9ec <main+0xb2>
	 //MCUCR = 0x60;            // Disable BOD during sleep to reduce power consumption (used to monitor supply voltage) 
   	 //MCUCR = 0x40;
	 //sleep_cpu();     
	 //sleep_disable();
	 	_delay_ms(5);
		if (!_atmega324p_shutdown())
     9f0:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <_atmega324p_shutdown>
     9f4:	88 23       	and	r24, r24
     9f6:	21 f4       	brne	.+8      	; 0xa00 <main+0xc6>
			sleep=1;		 
     9f8:	d0 93 0c 01 	sts	0x010C, r29
     9fc:	c0 93 0b 01 	sts	0x010B, r28

		led_counter++;
     a00:	80 91 05 01 	lds	r24, 0x0105
     a04:	90 91 06 01 	lds	r25, 0x0106
     a08:	01 96       	adiw	r24, 0x01	; 1
     a0a:	90 93 06 01 	sts	0x0106, r25
     a0e:	80 93 05 01 	sts	0x0105, r24
		if (_rn41_is_connected()){
     a12:	0e 94 6d 05 	call	0xada	; 0xada <_rn41_is_connected>
     a16:	88 23       	and	r24, r24
     a18:	91 f0       	breq	.+36     	; 0xa3e <main+0x104>
			_atmega324p_yellow_led_off();
     a1a:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <_atmega324p_yellow_led_off>
			if (led_counter==1)
     a1e:	80 91 05 01 	lds	r24, 0x0105
     a22:	90 91 06 01 	lds	r25, 0x0106
     a26:	81 30       	cpi	r24, 0x01	; 1
     a28:	91 05       	cpc	r25, r1
     a2a:	19 f4       	brne	.+6      	; 0xa32 <main+0xf8>
					_atmega324p_green_led_on();
     a2c:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <_atmega324p_green_led_on>
     a30:	1d c0       	rjmp	.+58     	; 0xa6c <main+0x132>
			else if (led_counter==2)
     a32:	82 30       	cpi	r24, 0x02	; 2
     a34:	91 05       	cpc	r25, r1
     a36:	99 f4       	brne	.+38     	; 0xa5e <main+0x124>
				_atmega324p_green_led_off();
     a38:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <_atmega324p_green_led_off>
     a3c:	17 c0       	rjmp	.+46     	; 0xa6c <main+0x132>
			else if (led_counter>=2000)
				led_counter=0;	
		}else{	 				
			if (led_counter==1)
     a3e:	80 91 05 01 	lds	r24, 0x0105
     a42:	90 91 06 01 	lds	r25, 0x0106
     a46:	81 30       	cpi	r24, 0x01	; 1
     a48:	91 05       	cpc	r25, r1
     a4a:	19 f4       	brne	.+6      	; 0xa52 <main+0x118>
				_atmega324p_yellow_led_on();
     a4c:	0e 94 df 0c 	call	0x19be	; 0x19be <_atmega324p_yellow_led_on>
     a50:	0d c0       	rjmp	.+26     	; 0xa6c <main+0x132>
			else if (led_counter==2)
     a52:	82 30       	cpi	r24, 0x02	; 2
     a54:	91 05       	cpc	r25, r1
     a56:	19 f4       	brne	.+6      	; 0xa5e <main+0x124>
				_atmega324p_yellow_led_off();
     a58:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <_atmega324p_yellow_led_off>
     a5c:	07 c0       	rjmp	.+14     	; 0xa6c <main+0x132>
			else if (led_counter>=2000)
     a5e:	80 5d       	subi	r24, 0xD0	; 208
     a60:	97 40       	sbci	r25, 0x07	; 7
     a62:	20 f0       	brcs	.+8      	; 0xa6c <main+0x132>
				led_counter=0;    
     a64:	10 92 06 01 	sts	0x0106, r1
     a68:	10 92 05 01 	sts	0x0105, r1
	_mma7260qt_wakeup();
	

	
	
    while(sleep==0)  {            /* Forever */
     a6c:	80 91 0b 01 	lds	r24, 0x010B
     a70:	90 91 0c 01 	lds	r25, 0x010C
     a74:	89 2b       	or	r24, r25
     a76:	09 f4       	brne	.+2      	; 0xa7a <main+0x140>
     a78:	b8 cf       	rjmp	.-144    	; 0x9ea <main+0xb0>
		}           
	 
	}  


	_atmega_finalize();
     a7a:	0e 94 32 0b 	call	0x1664	; 0x1664 <_atmega_finalize>
	//shutdown to minimize power
	//_atmega324p_reset();
	//make sure watchdog timer is disabled
	MCUSR = 0;
     a7e:	14 be       	out	0x34, r1	; 52
	wdt_disable();
     a80:	88 e1       	ldi	r24, 0x18	; 24
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	80 93 60 00 	sts	0x0060, r24
     a8a:	10 92 60 00 	sts	0x0060, r1
     a8e:	0f be       	out	0x3f, r0	; 63

	cli();
     a90:	f8 94       	cli
	TIMSK2=0;	
     a92:	10 92 70 00 	sts	0x0070, r1
	_atmega324p_yellow_led_off();
     a96:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <_atmega324p_yellow_led_off>
	_atmega324p_green_led_off();
     a9a:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <_atmega324p_green_led_off>
	//_rn41_off();	
	_mma7260qt_sleep();	
     a9e:	0e 94 77 0d 	call	0x1aee	; 0x1aee <_mma7260qt_sleep>
	sleep_enable();	
     aa2:	83 b7       	in	r24, 0x33	; 51
     aa4:	81 60       	ori	r24, 0x01	; 1
     aa6:	83 bf       	out	0x33, r24	; 51
	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
     aa8:	83 b7       	in	r24, 0x33	; 51
     aaa:	81 7f       	andi	r24, 0xF1	; 241
     aac:	86 60       	ori	r24, 0x06	; 6
     aae:	83 bf       	out	0x33, r24	; 51
	sleep_cpu();
     ab0:	88 95       	sleep


	//won't be executed as long as the power save is entered correctly
	_atmega324p_yellow_led_on();
     ab2:	0e 94 df 0c 	call	0x19be	; 0x19be <_atmega324p_yellow_led_on>
	_atmega324p_green_led_on();
     ab6:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <_atmega324p_green_led_on>

	return 0;
}
     aba:	80 e0       	ldi	r24, 0x00	; 0
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	df 91       	pop	r29
     ac0:	cf 91       	pop	r28
     ac2:	1f 91       	pop	r17
     ac4:	0f 91       	pop	r16
     ac6:	08 95       	ret

00000ac8 <_rn41_init>:
#include "avr_general.h"
#include "bt_rn41.h"

void _rn41_init(){
	//set status pins as input
	cbi(DDRD,BT_DISCOVERABLE_PIN);
     ac8:	55 98       	cbi	0x0a, 5	; 10
	cbi(DDRD,BT_CONNECTED_PIN);
     aca:	54 98       	cbi	0x0a, 4	; 10
	cbi(DDRD,BT_RX_PIN);
     acc:	50 98       	cbi	0x0a, 0	; 10
	
	sbi(DDRD,BT_TX_PIN);
     ace:	51 9a       	sbi	0x0a, 1	; 10
	sbi(DDRD,BT_RESET_PIN);
     ad0:	52 9a       	sbi	0x0a, 2	; 10

	//set RX and Reset PINS as output
	sbi(PORTD,BT_RESET_PIN);  //turn on bt	
     ad2:	5a 9a       	sbi	0x0b, 2	; 11
	sbi(DDRB,BT_SW);
     ad4:	24 9a       	sbi	0x04, 4	; 4
	cbi(PINB,BT_SW);
     ad6:	1c 98       	cbi	0x03, 4	; 3

}
     ad8:	08 95       	ret

00000ada <_rn41_is_connected>:


unsigned char _rn41_is_connected(){

	return (0x01 & (PIND>>BT_CONNECTED_PIN));
     ada:	89 b1       	in	r24, 0x09	; 9
     adc:	82 95       	swap	r24


}
     ade:	81 70       	andi	r24, 0x01	; 1
     ae0:	08 95       	ret

00000ae2 <_rn41_is_discoverable>:


unsigned char _rn41_is_discoverable(){

	return (0x01 & (PIND>>BT_DISCOVERABLE_PIN));
     ae2:	89 b1       	in	r24, 0x09	; 9
     ae4:	82 95       	swap	r24
     ae6:	86 95       	lsr	r24
}
     ae8:	81 70       	andi	r24, 0x01	; 1
     aea:	08 95       	ret

00000aec <_rn41_off>:


void _rn41_off(){		
	sbi(PINB,BT_SW);	
     aec:	1c 9a       	sbi	0x03, 4	; 3
}
     aee:	08 95       	ret

00000af0 <_rn41_on>:

void _rn41_on(){
	//sbi(PORTD,BT_RESET_PIN);
	cbi(PINB,BT_SW);
     af0:	1c 98       	cbi	0x03, 4	; 3
}
     af2:	08 95       	ret

00000af4 <_rn41_reset>:
	return (0x01 & (PIND>>BT_DISCOVERABLE_PIN));
}


void _rn41_off(){		
	sbi(PINB,BT_SW);	
     af4:	1c 9a       	sbi	0x03, 4	; 3
     af6:	80 e1       	ldi	r24, 0x10	; 16
     af8:	97 e2       	ldi	r25, 0x27	; 39
     afa:	28 ec       	ldi	r18, 0xC8	; 200
     afc:	30 e0       	ldi	r19, 0x00	; 0
     afe:	f9 01       	movw	r30, r18
     b00:	31 97       	sbiw	r30, 0x01	; 1
     b02:	f1 f7       	brne	.-4      	; 0xb00 <_rn41_reset+0xc>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     b04:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     b06:	d9 f7       	brne	.-10     	; 0xafe <_rn41_reset+0xa>
}

void _rn41_on(){
	//sbi(PORTD,BT_RESET_PIN);
	cbi(PINB,BT_SW);
     b08:	1c 98       	cbi	0x03, 4	; 3
	_delay_ms(1000);	
	_rn41_on();
	//cbi(PORTD,BT_RESET_PIN);
	//_delay_ms(100);
	//sbi(PORTD,BT_RESET_PIN);
}
     b0a:	08 95       	ret

00000b0c <_atmega_set_adc_clock>:
#include <stdlib.h>
#include <avr/eeprom.h> 


void _atmega_set_adc_clock(unsigned char prescalar){
        if (prescalar==ADC_PRESCALAR_2){
     b0c:	88 23       	and	r24, r24
     b0e:	21 f4       	brne	.+8      	; 0xb18 <_atmega_set_adc_clock+0xc>
                ADCSRA &= ~((1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0));
     b10:	80 91 7a 00 	lds	r24, 0x007A
     b14:	88 7f       	andi	r24, 0xF8	; 248
     b16:	36 c0       	rjmp	.+108    	; 0xb84 <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_4){
     b18:	81 30       	cpi	r24, 0x01	; 1
     b1a:	49 f4       	brne	.+18     	; 0xb2e <_atmega_set_adc_clock+0x22>
                ADCSRA &= ~((1 << ADPS2) | (1 << ADPS0));
     b1c:	80 91 7a 00 	lds	r24, 0x007A
     b20:	8a 7f       	andi	r24, 0xFA	; 250
     b22:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= (1 << ADPS1);
     b26:	80 91 7a 00 	lds	r24, 0x007A
     b2a:	82 60       	ori	r24, 0x02	; 2
     b2c:	2b c0       	rjmp	.+86     	; 0xb84 <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_8){
     b2e:	82 30       	cpi	r24, 0x02	; 2
     b30:	49 f4       	brne	.+18     	; 0xb44 <_atmega_set_adc_clock+0x38>
                ADCSRA &= ~(1 << ADPS2);
     b32:	80 91 7a 00 	lds	r24, 0x007A
     b36:	8b 7f       	andi	r24, 0xFB	; 251
     b38:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= ((1 << ADPS1) |(1 << ADPS0)) ;
     b3c:	80 91 7a 00 	lds	r24, 0x007A
     b40:	83 60       	ori	r24, 0x03	; 3
     b42:	20 c0       	rjmp	.+64     	; 0xb84 <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_16){
     b44:	83 30       	cpi	r24, 0x03	; 3
     b46:	49 f4       	brne	.+18     	; 0xb5a <_atmega_set_adc_clock+0x4e>
                ADCSRA &= ~((1 << ADPS1) |(1 << ADPS0));
     b48:	80 91 7a 00 	lds	r24, 0x007A
     b4c:	8c 7f       	andi	r24, 0xFC	; 252
     b4e:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= (1 << ADPS2);
     b52:	80 91 7a 00 	lds	r24, 0x007A
     b56:	84 60       	ori	r24, 0x04	; 4
     b58:	15 c0       	rjmp	.+42     	; 0xb84 <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_32){
     b5a:	84 30       	cpi	r24, 0x04	; 4
     b5c:	49 f4       	brne	.+18     	; 0xb70 <_atmega_set_adc_clock+0x64>
                ADCSRA &= ~(1 << ADPS1);
     b5e:	80 91 7a 00 	lds	r24, 0x007A
     b62:	8d 7f       	andi	r24, 0xFD	; 253
     b64:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= ((1 << ADPS2)|(1 << ADPS0));
     b68:	80 91 7a 00 	lds	r24, 0x007A
     b6c:	85 60       	ori	r24, 0x05	; 5
     b6e:	0a c0       	rjmp	.+20     	; 0xb84 <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_64){
     b70:	85 30       	cpi	r24, 0x05	; 5
     b72:	59 f4       	brne	.+22     	; 0xb8a <_atmega_set_adc_clock+0x7e>
                ADCSRA &= ~(1 << ADPS0);
     b74:	80 91 7a 00 	lds	r24, 0x007A
     b78:	8e 7f       	andi	r24, 0xFE	; 254
     b7a:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= ((1 << ADPS2)|(1 << ADPS1));
     b7e:	80 91 7a 00 	lds	r24, 0x007A
     b82:	86 60       	ori	r24, 0x06	; 6
     b84:	80 93 7a 00 	sts	0x007A, r24
     b88:	08 95       	ret
        }else if (prescalar==ADC_PRESCALAR_128){            
     b8a:	86 30       	cpi	r24, 0x06	; 6
     b8c:	29 f4       	brne	.+10     	; 0xb98 <_atmega_set_adc_clock+0x8c>
                ADCSRA |= ((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
     b8e:	80 91 7a 00 	lds	r24, 0x007A
     b92:	87 60       	ori	r24, 0x07	; 7
     b94:	80 93 7a 00 	sts	0x007A, r24
     b98:	08 95       	ret

00000b9a <_atmega_adc_turn_on>:


void _atmega_adc_turn_on()
{

	sbi(ADCSRA,ADEN);
     b9a:	ea e7       	ldi	r30, 0x7A	; 122
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	80 81       	ld	r24, Z
     ba0:	80 68       	ori	r24, 0x80	; 128
     ba2:	80 83       	st	Z, r24
}
     ba4:	08 95       	ret

00000ba6 <_atmega_adc_turn_off>:


void _atmega_adc_turn_off()
{
	cbi(ADCSRA,ADEN);
     ba6:	ea e7       	ldi	r30, 0x7A	; 122
     ba8:	f0 e0       	ldi	r31, 0x00	; 0
     baa:	80 81       	ld	r24, Z
     bac:	8f 77       	andi	r24, 0x7F	; 127
     bae:	80 83       	st	Z, r24
}
     bb0:	08 95       	ret

00000bb2 <_atmega_select_adc>:


void _atmega_select_adc(unsigned char channel){
        if (channel==ADC0){
     bb2:	88 23       	and	r24, r24
     bb4:	21 f4       	brne	.+8      	; 0xbbe <_atmega_select_adc+0xc>
                cbi(ADMUX,0);
     bb6:	80 91 7c 00 	lds	r24, 0x007C
     bba:	8e 7f       	andi	r24, 0xFE	; 254
     bbc:	05 c0       	rjmp	.+10     	; 0xbc8 <_atmega_select_adc+0x16>
                cbi(ADMUX,1);
                cbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }
        else if (channel==ADC1){
     bbe:	81 30       	cpi	r24, 0x01	; 1
     bc0:	71 f4       	brne	.+28     	; 0xbde <_atmega_select_adc+0x2c>
                sbi(ADMUX,0);
     bc2:	80 91 7c 00 	lds	r24, 0x007C
     bc6:	81 60       	ori	r24, 0x01	; 1
     bc8:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,1);
     bcc:	80 91 7c 00 	lds	r24, 0x007C
     bd0:	8d 7f       	andi	r24, 0xFD	; 253
     bd2:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,2);
     bd6:	80 91 7c 00 	lds	r24, 0x007C
     bda:	8b 7f       	andi	r24, 0xFB	; 251
     bdc:	2b c0       	rjmp	.+86     	; 0xc34 <_atmega_select_adc+0x82>
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC2){
     bde:	82 30       	cpi	r24, 0x02	; 2
     be0:	21 f4       	brne	.+8      	; 0xbea <_atmega_select_adc+0x38>
                cbi(ADMUX,0);
     be2:	80 91 7c 00 	lds	r24, 0x007C
     be6:	8e 7f       	andi	r24, 0xFE	; 254
     be8:	05 c0       	rjmp	.+10     	; 0xbf4 <_atmega_select_adc+0x42>
                sbi(ADMUX,1);
                cbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC3){
     bea:	83 30       	cpi	r24, 0x03	; 3
     bec:	49 f4       	brne	.+18     	; 0xc00 <_atmega_select_adc+0x4e>
                sbi(ADMUX,0);
     bee:	80 91 7c 00 	lds	r24, 0x007C
     bf2:	81 60       	ori	r24, 0x01	; 1
     bf4:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,1);
     bf8:	80 91 7c 00 	lds	r24, 0x007C
     bfc:	82 60       	ori	r24, 0x02	; 2
     bfe:	e9 cf       	rjmp	.-46     	; 0xbd2 <_atmega_select_adc+0x20>
                cbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC4){
     c00:	84 30       	cpi	r24, 0x04	; 4
     c02:	49 f4       	brne	.+18     	; 0xc16 <_atmega_select_adc+0x64>
                cbi(ADMUX,0);
     c04:	80 91 7c 00 	lds	r24, 0x007C
     c08:	8e 7f       	andi	r24, 0xFE	; 254
     c0a:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,1);
     c0e:	80 91 7c 00 	lds	r24, 0x007C
     c12:	8d 7f       	andi	r24, 0xFD	; 253
     c14:	0a c0       	rjmp	.+20     	; 0xc2a <_atmega_select_adc+0x78>
                sbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC6)
     c16:	86 30       	cpi	r24, 0x06	; 6
     c18:	d1 f4       	brne	.+52     	; 0xc4e <_atmega_select_adc+0x9c>
        {
                cbi(ADMUX,0);
     c1a:	80 91 7c 00 	lds	r24, 0x007C
     c1e:	8e 7f       	andi	r24, 0xFE	; 254
     c20:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,1);
     c24:	80 91 7c 00 	lds	r24, 0x007C
     c28:	82 60       	ori	r24, 0x02	; 2
     c2a:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,2);
     c2e:	80 91 7c 00 	lds	r24, 0x007C
     c32:	84 60       	ori	r24, 0x04	; 4
     c34:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,3);
     c38:	80 91 7c 00 	lds	r24, 0x007C
     c3c:	87 7f       	andi	r24, 0xF7	; 247
     c3e:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,4);
     c42:	80 91 7c 00 	lds	r24, 0x007C
     c46:	8f 7e       	andi	r24, 0xEF	; 239
     c48:	80 93 7c 00 	sts	0x007C, r24
     c4c:	08 95       	ret
        }
        else if (channel==ADC7)
     c4e:	87 30       	cpi	r24, 0x07	; 7
     c50:	c9 f4       	brne	.+50     	; 0xc84 <_atmega_select_adc+0xd2>
        {
                sbi(ADMUX,0);
     c52:	80 91 7c 00 	lds	r24, 0x007C
     c56:	81 60       	ori	r24, 0x01	; 1
     c58:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,1);
     c5c:	80 91 7c 00 	lds	r24, 0x007C
     c60:	82 60       	ori	r24, 0x02	; 2
     c62:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,2);
     c66:	80 91 7c 00 	lds	r24, 0x007C
     c6a:	84 60       	ori	r24, 0x04	; 4
     c6c:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,3);
     c70:	80 91 7c 00 	lds	r24, 0x007C
     c74:	87 7f       	andi	r24, 0xF7	; 247
     c76:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,4);
     c7a:	80 91 7c 00 	lds	r24, 0x007C
     c7e:	8f 7e       	andi	r24, 0xEF	; 239
     c80:	80 93 7c 00 	sts	0x007C, r24
     c84:	08 95       	ret

00000c86 <_atmega_a2dConvert10bit>:


unsigned short _atmega_a2dConvert10bit(unsigned char channel){
	
	// Select channel
	_atmega_select_adc(channel);
     c86:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <_atmega_select_adc>
	

	//Start ADC Conversion
	sbi(ADCSRA, ADIF);   // clear hardware "conversion complete" flag 
     c8a:	80 91 7a 00 	lds	r24, 0x007A
     c8e:	80 61       	ori	r24, 0x10	; 16
     c90:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSRA,ADSC);
     c94:	80 91 7a 00 	lds	r24, 0x007A
     c98:	80 64       	ori	r24, 0x40	; 64
     c9a:	80 93 7a 00 	sts	0x007A, r24
	
	// ADSC is 1 while converting, 0 when it is done
	while(bit_is_set(ADCSRA, ADSC)); 
     c9e:	80 91 7a 00 	lds	r24, 0x007A
     ca2:	86 fd       	sbrc	r24, 6
     ca4:	fc cf       	rjmp	.-8      	; 0xc9e <_atmega_a2dConvert10bit+0x18>

	return ((ADCL)|((ADCH)<<8));
     ca6:	20 91 78 00 	lds	r18, 0x0078
     caa:	40 91 79 00 	lds	r20, 0x0079
     cae:	94 2f       	mov	r25, r20
     cb0:	80 e0       	ldi	r24, 0x00	; 0
     cb2:	30 e0       	ldi	r19, 0x00	; 0
     cb4:	28 2b       	or	r18, r24
     cb6:	39 2b       	or	r19, r25
}
     cb8:	c9 01       	movw	r24, r18
     cba:	08 95       	ret

00000cbc <_atmega_initialize_uart0>:
	
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
     cbc:	90 93 c5 00 	sts	0x00C5, r25
        UBRR0L = (unsigned char)baud;
     cc0:	80 93 c4 00 	sts	0x00C4, r24
        /* Enable receiver and/or transmitter */
		switch(mode)
     cc4:	66 23       	and	r22, r22
     cc6:	19 f0       	breq	.+6      	; 0xcce <_atmega_initialize_uart0+0x12>
     cc8:	61 30       	cpi	r22, 0x01	; 1
     cca:	29 f4       	brne	.+10     	; 0xcd6 <_atmega_initialize_uart0+0x1a>
     ccc:	02 c0       	rjmp	.+4      	; 0xcd2 <_atmega_initialize_uart0+0x16>
		{
			case TX_UART_MODE:
        		UCSR0B = (1<<TXEN0);
     cce:	88 e0       	ldi	r24, 0x08	; 8
     cd0:	03 c0       	rjmp	.+6      	; 0xcd8 <_atmega_initialize_uart0+0x1c>
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
     cd2:	80 e1       	ldi	r24, 0x10	; 16
     cd4:	01 c0       	rjmp	.+2      	; 0xcd8 <_atmega_initialize_uart0+0x1c>
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
     cd6:	88 e1       	ldi	r24, 0x18	; 24
     cd8:	80 93 c1 00 	sts	0x00C1, r24
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
     cdc:	86 e0       	ldi	r24, 0x06	; 6
     cde:	80 93 c2 00 	sts	0x00C2, r24
}
     ce2:	08 95       	ret

00000ce4 <_atmega_initialize_uart1>:
	
*/
void _atmega_initialize_uart1(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR1H = (unsigned char)(baud>>8);
     ce4:	90 93 cd 00 	sts	0x00CD, r25
        UBRR1L = (unsigned char)baud;
     ce8:	80 93 cc 00 	sts	0x00CC, r24
        /* Enable receiver and transmitter */
		switch(mode)
     cec:	66 23       	and	r22, r22
     cee:	19 f0       	breq	.+6      	; 0xcf6 <_atmega_initialize_uart1+0x12>
     cf0:	61 30       	cpi	r22, 0x01	; 1
     cf2:	29 f4       	brne	.+10     	; 0xcfe <_atmega_initialize_uart1+0x1a>
     cf4:	02 c0       	rjmp	.+4      	; 0xcfa <_atmega_initialize_uart1+0x16>
		{
			case TX_UART_MODE:
        		UCSR1B = (1<<TXEN1);
     cf6:	88 e0       	ldi	r24, 0x08	; 8
     cf8:	03 c0       	rjmp	.+6      	; 0xd00 <_atmega_initialize_uart1+0x1c>
				break;
			case RX_UART_MODE:
        		UCSR1B = (1<<RXEN1);
     cfa:	80 e1       	ldi	r24, 0x10	; 16
     cfc:	01 c0       	rjmp	.+2      	; 0xd00 <_atmega_initialize_uart1+0x1c>
				break;
			default:
        		UCSR1B = (1<<TXEN1)|(1<<RXEN1);
     cfe:	88 e1       	ldi	r24, 0x18	; 24
     d00:	80 93 c9 00 	sts	0x00C9, r24
				break;
		}        
        /* Set frame format: 8data, 2stop bit */
        UCSR1C =(3<<UCSZ10);  //change 1 to 0 and &
     d04:	86 e0       	ldi	r24, 0x06	; 6
     d06:	80 93 ca 00 	sts	0x00CA, r24
}
     d0a:	08 95       	ret

00000d0c <_atmega_disable_JTAG>:
*/
void _atmega_disable_JTAG(void)
{
	unsigned char sreg;

	sreg = SREG;
     d0c:	8f b7       	in	r24, 0x3f	; 63
	cli();
     d0e:	f8 94       	cli
	MCUCR |= ( 1 <<JTD );
     d10:	95 b7       	in	r25, 0x35	; 53
     d12:	90 68       	ori	r25, 0x80	; 128
     d14:	95 bf       	out	0x35, r25	; 53
	MCUCR |= ( 1 <<JTD );
     d16:	95 b7       	in	r25, 0x35	; 53
     d18:	90 68       	ori	r25, 0x80	; 128
     d1a:	95 bf       	out	0x35, r25	; 53
	SREG = sreg;
     d1c:	8f bf       	out	0x3f, r24	; 63
}
     d1e:	08 95       	ret

00000d20 <_atmega_set_timer2_prescalar>:


void _atmega_set_timer2_prescalar(unsigned char prescalar)
{
	switch(prescalar)
     d20:	82 30       	cpi	r24, 0x02	; 2
     d22:	b1 f0       	breq	.+44     	; 0xd50 <_atmega_set_timer2_prescalar+0x30>
     d24:	83 30       	cpi	r24, 0x03	; 3
     d26:	28 f4       	brcc	.+10     	; 0xd32 <_atmega_set_timer2_prescalar+0x12>
     d28:	88 23       	and	r24, r24
     d2a:	51 f0       	breq	.+20     	; 0xd40 <_atmega_set_timer2_prescalar+0x20>
     d2c:	81 30       	cpi	r24, 0x01	; 1
     d2e:	01 f5       	brne	.+64     	; 0xd70 <_atmega_set_timer2_prescalar+0x50>
     d30:	0b c0       	rjmp	.+22     	; 0xd48 <_atmega_set_timer2_prescalar+0x28>
     d32:	84 30       	cpi	r24, 0x04	; 4
     d34:	a9 f0       	breq	.+42     	; 0xd60 <_atmega_set_timer2_prescalar+0x40>
     d36:	84 30       	cpi	r24, 0x04	; 4
     d38:	78 f0       	brcs	.+30     	; 0xd58 <_atmega_set_timer2_prescalar+0x38>
     d3a:	85 30       	cpi	r24, 0x05	; 5
     d3c:	c9 f4       	brne	.+50     	; 0xd70 <_atmega_set_timer2_prescalar+0x50>
     d3e:	14 c0       	rjmp	.+40     	; 0xd68 <_atmega_set_timer2_prescalar+0x48>
	{
		case CPU_CLK_PRESCALAR_NONE:
			TCCR2B |= (1 << CS20);
     d40:	80 91 b1 00 	lds	r24, 0x00B1
     d44:	81 60       	ori	r24, 0x01	; 1
     d46:	17 c0       	rjmp	.+46     	; 0xd76 <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_8:
			TCCR2B |= (1 << CS21); 
     d48:	80 91 b1 00 	lds	r24, 0x00B1
     d4c:	82 60       	ori	r24, 0x02	; 2
     d4e:	13 c0       	rjmp	.+38     	; 0xd76 <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_32:
			TCCR2B |= ((1 << CS20) | (1 << CS21));
     d50:	80 91 b1 00 	lds	r24, 0x00B1
     d54:	83 60       	ori	r24, 0x03	; 3
     d56:	0f c0       	rjmp	.+30     	; 0xd76 <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_64:
			TCCR2B |= (1 << CS22) ;
     d58:	80 91 b1 00 	lds	r24, 0x00B1
     d5c:	84 60       	ori	r24, 0x04	; 4
     d5e:	0b c0       	rjmp	.+22     	; 0xd76 <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_128:
			TCCR2B |= ((1 << CS20) |(1 << CS22));
     d60:	80 91 b1 00 	lds	r24, 0x00B1
     d64:	85 60       	ori	r24, 0x05	; 5
     d66:	07 c0       	rjmp	.+14     	; 0xd76 <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_256:
			TCCR2B |= ((1 << CS22) |(1 << CS21));
     d68:	80 91 b1 00 	lds	r24, 0x00B1
     d6c:	86 60       	ori	r24, 0x06	; 6
     d6e:	03 c0       	rjmp	.+6      	; 0xd76 <_atmega_set_timer2_prescalar+0x56>
			break;
		default:
			TCCR2B |= ((1 << CS20) |(1 << CS21) | (1 << CS22)); 
     d70:	80 91 b1 00 	lds	r24, 0x00B1
     d74:	87 60       	ori	r24, 0x07	; 7
     d76:	80 93 b1 00 	sts	0x00B1, r24
     d7a:	08 95       	ret

00000d7c <_atmega_enable_timer2>:
*/
void _atmega_enable_timer2(unsigned char timer_prescalar)
{

	// Setup the prescaler to 1024		 
	_atmega_set_timer2_prescalar(timer_prescalar);
     d7c:	0e 94 90 06 	call	0xd20	; 0xd20 <_atmega_set_timer2_prescalar>
	// Set the counter to 0
	TCNT2=0;
     d80:	10 92 b2 00 	sts	0x00B2, r1
	//Enable the overflow interrupt
	TIMSK2 |= (1 << TOIE2); // Enable CTC interrupt
     d84:	e0 e7       	ldi	r30, 0x70	; 112
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	80 81       	ld	r24, Z
     d8a:	81 60       	ori	r24, 0x01	; 1
     d8c:	80 83       	st	Z, r24
	// Enable global interrupts
	sei(); 
     d8e:	78 94       	sei
}
     d90:	08 95       	ret

00000d92 <_atmega_disable_timer2>:
	
*/
void _atmega_disable_timer2(void)
{	
	//disable timer interrupt
	TIMSK2=0;
     d92:	10 92 70 00 	sts	0x0070, r1
	// reset counter unit
	TCCR2B=0;
     d96:	10 92 b1 00 	sts	0x00B1, r1
}
     d9a:	08 95       	ret

00000d9c <_atmega_reset>:



void _atmega_reset(void)
{               
        cli(); //irq's off
     d9c:	f8 94       	cli
        wdt_enable(WDTO_15MS); //wd on,15ms
     d9e:	28 e0       	ldi	r18, 0x08	; 8
     da0:	88 e1       	ldi	r24, 0x18	; 24
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	0f b6       	in	r0, 0x3f	; 63
     da6:	f8 94       	cli
     da8:	a8 95       	wdr
     daa:	80 93 60 00 	sts	0x0060, r24
     dae:	0f be       	out	0x3f, r0	; 63
     db0:	20 93 60 00 	sts	0x0060, r18
     db4:	ff cf       	rjmp	.-2      	; 0xdb4 <_atmega_reset+0x18>

00000db6 <_atmega_disable_watchdog>:
	This has to be done at the begining of an application
	
*/
void _atmega_disable_watchdog(void)
{
	MCUSR = 0;
     db6:	14 be       	out	0x34, r1	; 52
	wdt_disable();
     db8:	88 e1       	ldi	r24, 0x18	; 24
     dba:	0f b6       	in	r0, 0x3f	; 63
     dbc:	f8 94       	cli
     dbe:	80 93 60 00 	sts	0x0060, r24
     dc2:	10 92 60 00 	sts	0x0060, r1
     dc6:	0f be       	out	0x3f, r0	; 63
}
     dc8:	08 95       	ret

00000dca <_bluetooth_enter_command_mode>:


/* Bluetooth Functions */

unsigned char _bluetooth_enter_command_mode(void)
{
     dca:	40 e0       	ldi	r20, 0x00	; 0
void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
  UCSR0A=UCSR0A & 0xdf;
  
  UDR0 =  data;  /* Start transmission   */
     dcc:	54 e2       	ldi	r21, 0x24	; 36
     dce:	20 e1       	ldi	r18, 0x10	; 16
     dd0:	37 e2       	ldi	r19, 0x27	; 39
     dd2:	6d e0       	ldi	r22, 0x0D	; 13
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     dd4:	80 91 c0 00 	lds	r24, 0x00C0
     dd8:	85 ff       	sbrs	r24, 5
     dda:	fc cf       	rjmp	.-8      	; 0xdd4 <_bluetooth_enter_command_mode+0xa>
  UCSR0A=UCSR0A & 0xdf;
     ddc:	80 91 c0 00 	lds	r24, 0x00C0
     de0:	8f 7d       	andi	r24, 0xDF	; 223
     de2:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     de6:	50 93 c6 00 	sts	0x00C6, r21
     dea:	c9 01       	movw	r24, r18
     dec:	01 97       	sbiw	r24, 0x01	; 1
     dee:	f1 f7       	brne	.-4      	; 0xdec <_bluetooth_enter_command_mode+0x22>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     df0:	80 91 c0 00 	lds	r24, 0x00C0
     df4:	85 ff       	sbrs	r24, 5
     df6:	fc cf       	rjmp	.-8      	; 0xdf0 <_bluetooth_enter_command_mode+0x26>
  UCSR0A=UCSR0A & 0xdf;
     df8:	80 91 c0 00 	lds	r24, 0x00C0
     dfc:	8f 7d       	andi	r24, 0xDF	; 223
     dfe:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     e02:	50 93 c6 00 	sts	0x00C6, r21
     e06:	c9 01       	movw	r24, r18
     e08:	01 97       	sbiw	r24, 0x01	; 1
     e0a:	f1 f7       	brne	.-4      	; 0xe08 <_bluetooth_enter_command_mode+0x3e>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     e0c:	80 91 c0 00 	lds	r24, 0x00C0
     e10:	85 ff       	sbrs	r24, 5
     e12:	fc cf       	rjmp	.-8      	; 0xe0c <_bluetooth_enter_command_mode+0x42>
  UCSR0A=UCSR0A & 0xdf;
     e14:	80 91 c0 00 	lds	r24, 0x00C0
     e18:	8f 7d       	andi	r24, 0xDF	; 223
     e1a:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     e1e:	50 93 c6 00 	sts	0x00C6, r21
     e22:	c9 01       	movw	r24, r18
     e24:	01 97       	sbiw	r24, 0x01	; 1
     e26:	f1 f7       	brne	.-4      	; 0xe24 <_bluetooth_enter_command_mode+0x5a>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     e28:	80 91 c0 00 	lds	r24, 0x00C0
     e2c:	85 ff       	sbrs	r24, 5
     e2e:	fc cf       	rjmp	.-8      	; 0xe28 <_bluetooth_enter_command_mode+0x5e>
  UCSR0A=UCSR0A & 0xdf;
     e30:	80 91 c0 00 	lds	r24, 0x00C0
     e34:	8f 7d       	andi	r24, 0xDF	; 223
     e36:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     e3a:	60 93 c6 00 	sts	0x00C6, r22
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     e3e:	80 91 c0 00 	lds	r24, 0x00C0
     e42:	85 ff       	sbrs	r24, 5
     e44:	fc cf       	rjmp	.-8      	; 0xe3e <_bluetooth_enter_command_mode+0x74>
  UCSR0A=UCSR0A & 0xdf;
     e46:	80 91 c0 00 	lds	r24, 0x00C0
     e4a:	8f 7d       	andi	r24, 0xDF	; 223
     e4c:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     e50:	60 93 c6 00 	sts	0x00C6, r22


unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
     e54:	80 91 c0 00 	lds	r24, 0x00C0
     e58:	87 fd       	sbrc	r24, 7
     e5a:	04 c0       	rjmp	.+8      	; 0xe64 <_bluetooth_enter_command_mode+0x9a>
     e5c:	80 91 c0 00 	lds	r24, 0x00C0
     e60:	87 ff       	sbrs	r24, 7
     e62:	25 c0       	rjmp	.+74     	; 0xeae <_bluetooth_enter_command_mode+0xe4>
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
     e64:	80 91 c6 00 	lds	r24, 0x00C6

		attempts++;

		if (_bluetooth_receive_uart0_byte(&aByte))
		{		
				if (aByte=='C'){					
     e68:	83 34       	cpi	r24, 0x43	; 67
     e6a:	09 f5       	brne	.+66     	; 0xeae <_bluetooth_enter_command_mode+0xe4>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     e6c:	80 91 c0 00 	lds	r24, 0x00C0
     e70:	85 ff       	sbrs	r24, 5
     e72:	fc cf       	rjmp	.-8      	; 0xe6c <_bluetooth_enter_command_mode+0xa2>
  UCSR0A=UCSR0A & 0xdf;
     e74:	80 91 c0 00 	lds	r24, 0x00C0
     e78:	8f 7d       	andi	r24, 0xDF	; 223
     e7a:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     e7e:	8d e0       	ldi	r24, 0x0D	; 13
     e80:	80 93 c6 00 	sts	0x00C6, r24
     e84:	20 e0       	ldi	r18, 0x00	; 0
     e86:	30 e0       	ldi	r19, 0x00	; 0
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     e88:	9d e0       	ldi	r25, 0x0D	; 13
     e8a:	80 91 c0 00 	lds	r24, 0x00C0
     e8e:	85 ff       	sbrs	r24, 5
     e90:	fc cf       	rjmp	.-8      	; 0xe8a <_bluetooth_enter_command_mode+0xc0>
  UCSR0A=UCSR0A & 0xdf;
     e92:	80 91 c0 00 	lds	r24, 0x00C0
     e96:	8f 7d       	andi	r24, 0xDF	; 223
     e98:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     e9c:	90 93 c6 00 	sts	0x00C6, r25

		if (_bluetooth_receive_uart0_byte(&aByte))
		{		
				if (aByte=='C'){					
					_bluetooth_transmit_uart0_byte(13);						
					for (int i=0;(i<10);i++)        		
     ea0:	2f 5f       	subi	r18, 0xFF	; 255
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	2a 30       	cpi	r18, 0x0A	; 10
     ea6:	31 05       	cpc	r19, r1
     ea8:	81 f7       	brne	.-32     	; 0xe8a <_bluetooth_enter_command_mode+0xc0>
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	08 95       	ret
		_bluetooth_transmit_uart0_byte(13);
		/*_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);*/

		attempts++;
     eae:	4f 5f       	subi	r20, 0xFF	; 255
						_bluetooth_transmit_uart0_byte(13);
					return 1;	
				}
		}

 		if (attempts>=255) 
     eb0:	4f 3f       	cpi	r20, 0xFF	; 255
     eb2:	09 f0       	breq	.+2      	; 0xeb6 <_bluetooth_enter_command_mode+0xec>
     eb4:	8f cf       	rjmp	.-226    	; 0xdd4 <_bluetooth_enter_command_mode+0xa>
     eb6:	80 e0       	ldi	r24, 0x00	; 0
			break;				
	}

	
	return 0;
}
     eb8:	08 95       	ret

00000eba <_bluetooth_exit_command_mode>:


unsigned char _bluetooth_exit_command_mode(void)
{
     eba:	40 e0       	ldi	r20, 0x00	; 0
void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
  UCSR0A=UCSR0A & 0xdf;
  
  UDR0 =  data;  /* Start transmission   */
     ebc:	5d e2       	ldi	r21, 0x2D	; 45
     ebe:	20 e1       	ldi	r18, 0x10	; 16
     ec0:	37 e2       	ldi	r19, 0x27	; 39
     ec2:	6d e0       	ldi	r22, 0x0D	; 13
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     ec4:	80 91 c0 00 	lds	r24, 0x00C0
     ec8:	85 ff       	sbrs	r24, 5
     eca:	fc cf       	rjmp	.-8      	; 0xec4 <_bluetooth_exit_command_mode+0xa>
  UCSR0A=UCSR0A & 0xdf;
     ecc:	80 91 c0 00 	lds	r24, 0x00C0
     ed0:	8f 7d       	andi	r24, 0xDF	; 223
     ed2:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     ed6:	50 93 c6 00 	sts	0x00C6, r21
     eda:	c9 01       	movw	r24, r18
     edc:	01 97       	sbiw	r24, 0x01	; 1
     ede:	f1 f7       	brne	.-4      	; 0xedc <_bluetooth_exit_command_mode+0x22>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     ee0:	80 91 c0 00 	lds	r24, 0x00C0
     ee4:	85 ff       	sbrs	r24, 5
     ee6:	fc cf       	rjmp	.-8      	; 0xee0 <_bluetooth_exit_command_mode+0x26>
  UCSR0A=UCSR0A & 0xdf;
     ee8:	80 91 c0 00 	lds	r24, 0x00C0
     eec:	8f 7d       	andi	r24, 0xDF	; 223
     eee:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     ef2:	50 93 c6 00 	sts	0x00C6, r21
     ef6:	c9 01       	movw	r24, r18
     ef8:	01 97       	sbiw	r24, 0x01	; 1
     efa:	f1 f7       	brne	.-4      	; 0xef8 <_bluetooth_exit_command_mode+0x3e>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     efc:	80 91 c0 00 	lds	r24, 0x00C0
     f00:	85 ff       	sbrs	r24, 5
     f02:	fc cf       	rjmp	.-8      	; 0xefc <_bluetooth_exit_command_mode+0x42>
  UCSR0A=UCSR0A & 0xdf;
     f04:	80 91 c0 00 	lds	r24, 0x00C0
     f08:	8f 7d       	andi	r24, 0xDF	; 223
     f0a:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     f0e:	50 93 c6 00 	sts	0x00C6, r21
     f12:	c9 01       	movw	r24, r18
     f14:	01 97       	sbiw	r24, 0x01	; 1
     f16:	f1 f7       	brne	.-4      	; 0xf14 <_bluetooth_exit_command_mode+0x5a>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     f18:	80 91 c0 00 	lds	r24, 0x00C0
     f1c:	85 ff       	sbrs	r24, 5
     f1e:	fc cf       	rjmp	.-8      	; 0xf18 <_bluetooth_exit_command_mode+0x5e>
  UCSR0A=UCSR0A & 0xdf;
     f20:	80 91 c0 00 	lds	r24, 0x00C0
     f24:	8f 7d       	andi	r24, 0xDF	; 223
     f26:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     f2a:	60 93 c6 00 	sts	0x00C6, r22
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     f2e:	80 91 c0 00 	lds	r24, 0x00C0
     f32:	85 ff       	sbrs	r24, 5
     f34:	fc cf       	rjmp	.-8      	; 0xf2e <_bluetooth_exit_command_mode+0x74>
  UCSR0A=UCSR0A & 0xdf;
     f36:	80 91 c0 00 	lds	r24, 0x00C0
     f3a:	8f 7d       	andi	r24, 0xDF	; 223
     f3c:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
     f40:	60 93 c6 00 	sts	0x00C6, r22
		_bluetooth_transmit_uart0_byte('-');		
		_delay_ms(5);
				
		_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);
		attempts++;
     f44:	4f 5f       	subi	r20, 0xFF	; 255

 		if ((attempts>=255) || (_bluetooth_receive_uart0_byte(&aByte)==0))
     f46:	4f 3f       	cpi	r20, 0xFF	; 255
     f48:	69 f0       	breq	.+26     	; 0xf64 <_bluetooth_exit_command_mode+0xaa>


unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
     f4a:	80 91 c0 00 	lds	r24, 0x00C0
     f4e:	87 fd       	sbrc	r24, 7
     f50:	06 c0       	rjmp	.+12     	; 0xf5e <_bluetooth_exit_command_mode+0xa4>
     f52:	80 91 c0 00 	lds	r24, 0x00C0
     f56:	87 fd       	sbrc	r24, 7
     f58:	02 c0       	rjmp	.+4      	; 0xf5e <_bluetooth_exit_command_mode+0xa4>
     f5a:	81 e0       	ldi	r24, 0x01	; 1
     f5c:	08 95       	ret
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
     f5e:	80 91 c6 00 	lds	r24, 0x00C6
     f62:	b0 cf       	rjmp	.-160    	; 0xec4 <_bluetooth_exit_command_mode+0xa>
     f64:	80 e0       	ldi	r24, 0x00	; 0
	// succeeded in entering command mode
	if (attempts<255)
		return 1;
	
	return 0;
}
     f66:	08 95       	ret

00000f68 <_bluetooth_reset>:
	
*/
void _bluetooth_turn_off(void)
{
	// Set the direction of TX, RESET and switch pins as input
	cbi(DDRD,OUT_BT_TXD_PD1);
     f68:	51 98       	cbi	0x0a, 1	; 10
	cbi(DDRD,OUT_BT_RESET_N_PD2);
     f6a:	52 98       	cbi	0x0a, 2	; 10
	cbi(DDRB,OUT_BT_SW_N_PB4);		 
     f6c:	24 98       	cbi	0x04, 4	; 4
     f6e:	80 e1       	ldi	r24, 0x10	; 16
     f70:	97 e2       	ldi	r25, 0x27	; 39
     f72:	01 97       	sbiw	r24, 0x01	; 1
     f74:	f1 f7       	brne	.-4      	; 0xf72 <_bluetooth_reset+0xa>
	
*/
void _bluetooth_turn_on(void)
{
	// Set the direction of TX pin as output
	sbi(DDRD,OUT_BT_TXD_PD1);
     f76:	51 9a       	sbi	0x0a, 1	; 10

	// Set the direction of the RESET pin as output and high
	sbi(DDRD,OUT_BT_RESET_N_PD2);	
     f78:	52 9a       	sbi	0x0a, 2	; 10
	sbi(PORTD,OUT_BT_RESET_N_PD2);  
     f7a:	5a 9a       	sbi	0x0b, 2	; 11

	// Set the direction of the switch pin as output and low
	sbi(DDRB,OUT_BT_SW_N_PB4);
     f7c:	24 9a       	sbi	0x04, 4	; 4
	cbi(PORTB,OUT_BT_SW_N_PB4);
     f7e:	2c 98       	cbi	0x05, 4	; 5

	// Set the status of the bluetooth to true
	sbi(wocket_status, BIT0_BLUETOOTH_STATUS);
     f80:	80 91 23 01 	lds	r24, 0x0123
     f84:	81 60       	ori	r24, 0x01	; 1
     f86:	80 93 23 01 	sts	0x0123, r24
{
	_bluetooth_turn_off();
	_delay_ms(5);
	_bluetooth_turn_on();

}
     f8a:	08 95       	ret

00000f8c <_bluetooth_set_baud_rate>:

unsigned char _bluetooth_set_baud_rate(unsigned char baudrate)
{
     f8c:	9f 92       	push	r9
     f8e:	af 92       	push	r10
     f90:	bf 92       	push	r11
     f92:	cf 92       	push	r12
     f94:	df 92       	push	r13
     f96:	ef 92       	push	r14
     f98:	ff 92       	push	r15
     f9a:	0f 93       	push	r16
     f9c:	1f 93       	push	r17
     f9e:	48 2f       	mov	r20, r24
     fa0:	50 e0       	ldi	r21, 0x00	; 0
void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
  UCSR0A=UCSR0A & 0xdf;
  
  UDR0 =  data;  /* Start transmission   */
     fa2:	fd e0       	ldi	r31, 0x0D	; 13
     fa4:	60 e1       	ldi	r22, 0x10	; 16
     fa6:	77 e2       	ldi	r23, 0x27	; 39
     fa8:	b3 e5       	ldi	r27, 0x53	; 83
     faa:	bb 2e       	mov	r11, r27
	_bluetooth_turn_on();

}

unsigned char _bluetooth_set_baud_rate(unsigned char baudrate)
{
     fac:	a5 e5       	ldi	r26, 0x55	; 85
     fae:	aa 2e       	mov	r10, r26
     fb0:	ec e2       	ldi	r30, 0x2C	; 44
     fb2:	9e 2e       	mov	r9, r30
     fb4:	03 e3       	ldi	r16, 0x33	; 51
     fb6:	e8 e3       	ldi	r30, 0x38	; 56
     fb8:	39 e3       	ldi	r19, 0x39	; 57
     fba:	f3 2e       	mov	r15, r19
     fbc:	26 e3       	ldi	r18, 0x36	; 54
     fbe:	e2 2e       	mov	r14, r18
     fc0:	14 e3       	ldi	r17, 0x34	; 52
     fc2:	a2 e3       	ldi	r26, 0x32	; 50
     fc4:	b1 e3       	ldi	r27, 0x31	; 49
     fc6:	95 e3       	ldi	r25, 0x35	; 53
     fc8:	c9 2e       	mov	r12, r25
     fca:	87 e3       	ldi	r24, 0x37	; 55
     fcc:	d8 2e       	mov	r13, r24
     fce:	20 e0       	ldi	r18, 0x00	; 0
     fd0:	30 e0       	ldi	r19, 0x00	; 0


unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
     fd2:	80 91 c0 00 	lds	r24, 0x00C0
     fd6:	87 fd       	sbrc	r24, 7
     fd8:	04 c0       	rjmp	.+8      	; 0xfe2 <_bluetooth_set_baud_rate+0x56>
     fda:	80 91 c0 00 	lds	r24, 0x00C0
     fde:	87 ff       	sbrs	r24, 7
     fe0:	02 c0       	rjmp	.+4      	; 0xfe6 <_bluetooth_set_baud_rate+0x5a>
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
     fe2:	80 91 c6 00 	lds	r24, 0x00C6
	unsigned char attempts=0;
	unsigned char aByte=0;

	while(1)  
	{   
		for (int i=0;(i<100);i++)
     fe6:	2f 5f       	subi	r18, 0xFF	; 255
     fe8:	3f 4f       	sbci	r19, 0xFF	; 255
     fea:	24 36       	cpi	r18, 0x64	; 100
     fec:	31 05       	cpc	r19, r1
     fee:	89 f7       	brne	.-30     	; 0xfd2 <_bluetooth_set_baud_rate+0x46>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
     ff0:	80 91 c0 00 	lds	r24, 0x00C0
     ff4:	85 ff       	sbrs	r24, 5
     ff6:	fc cf       	rjmp	.-8      	; 0xff0 <_bluetooth_set_baud_rate+0x64>
  UCSR0A=UCSR0A & 0xdf;
     ff8:	80 91 c0 00 	lds	r24, 0x00C0
     ffc:	8f 7d       	andi	r24, 0xDF	; 223
     ffe:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1002:	f0 93 c6 00 	sts	0x00C6, r31
    1006:	cb 01       	movw	r24, r22
    1008:	01 97       	sbiw	r24, 0x01	; 1
    100a:	f1 f7       	brne	.-4      	; 0x1008 <_bluetooth_set_baud_rate+0x7c>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    100c:	80 91 c0 00 	lds	r24, 0x00C0
    1010:	85 ff       	sbrs	r24, 5
    1012:	fc cf       	rjmp	.-8      	; 0x100c <_bluetooth_set_baud_rate+0x80>
  UCSR0A=UCSR0A & 0xdf;
    1014:	80 91 c0 00 	lds	r24, 0x00C0
    1018:	8f 7d       	andi	r24, 0xDF	; 223
    101a:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    101e:	f0 93 c6 00 	sts	0x00C6, r31
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1022:	80 91 c0 00 	lds	r24, 0x00C0
    1026:	85 ff       	sbrs	r24, 5
    1028:	fc cf       	rjmp	.-8      	; 0x1022 <_bluetooth_set_baud_rate+0x96>
  UCSR0A=UCSR0A & 0xdf;
    102a:	80 91 c0 00 	lds	r24, 0x00C0
    102e:	8f 7d       	andi	r24, 0xDF	; 223
    1030:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1034:	b0 92 c6 00 	sts	0x00C6, r11
    1038:	cb 01       	movw	r24, r22
    103a:	01 97       	sbiw	r24, 0x01	; 1
    103c:	f1 f7       	brne	.-4      	; 0x103a <_bluetooth_set_baud_rate+0xae>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    103e:	80 91 c0 00 	lds	r24, 0x00C0
    1042:	85 ff       	sbrs	r24, 5
    1044:	fc cf       	rjmp	.-8      	; 0x103e <_bluetooth_set_baud_rate+0xb2>
  UCSR0A=UCSR0A & 0xdf;
    1046:	80 91 c0 00 	lds	r24, 0x00C0
    104a:	8f 7d       	andi	r24, 0xDF	; 223
    104c:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1050:	a0 92 c6 00 	sts	0x00C6, r10
    1054:	cb 01       	movw	r24, r22
    1056:	01 97       	sbiw	r24, 0x01	; 1
    1058:	f1 f7       	brne	.-4      	; 0x1056 <_bluetooth_set_baud_rate+0xca>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    105a:	80 91 c0 00 	lds	r24, 0x00C0
    105e:	85 ff       	sbrs	r24, 5
    1060:	fc cf       	rjmp	.-8      	; 0x105a <_bluetooth_set_baud_rate+0xce>
  UCSR0A=UCSR0A & 0xdf;
    1062:	80 91 c0 00 	lds	r24, 0x00C0
    1066:	8f 7d       	andi	r24, 0xDF	; 223
    1068:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    106c:	90 92 c6 00 	sts	0x00C6, r9
    1070:	cb 01       	movw	r24, r22
    1072:	01 97       	sbiw	r24, 0x01	; 1
    1074:	f1 f7       	brne	.-4      	; 0x1072 <_bluetooth_set_baud_rate+0xe6>
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte('U');
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(',');
		_delay_ms(5);
		switch(baudrate){
    1076:	4c 30       	cpi	r20, 0x0C	; 12
    1078:	09 f4       	brne	.+2      	; 0x107c <_bluetooth_set_baud_rate+0xf0>
    107a:	7d c0       	rjmp	.+250    	; 0x1176 <_bluetooth_set_baud_rate+0x1ea>
    107c:	4d 30       	cpi	r20, 0x0D	; 13
    107e:	68 f4       	brcc	.+26     	; 0x109a <_bluetooth_set_baud_rate+0x10e>
    1080:	41 30       	cpi	r20, 0x01	; 1
    1082:	09 f4       	brne	.+2      	; 0x1086 <_bluetooth_set_baud_rate+0xfa>
    1084:	c3 c0       	rjmp	.+390    	; 0x120c <_bluetooth_set_baud_rate+0x280>
    1086:	41 30       	cpi	r20, 0x01	; 1
    1088:	08 f4       	brcc	.+2      	; 0x108c <_bluetooth_set_baud_rate+0x100>
    108a:	d7 c0       	rjmp	.+430    	; 0x123a <_bluetooth_set_baud_rate+0x2ae>
    108c:	43 30       	cpi	r20, 0x03	; 3
    108e:	09 f4       	brne	.+2      	; 0x1092 <_bluetooth_set_baud_rate+0x106>
    1090:	a6 c0       	rjmp	.+332    	; 0x11de <_bluetooth_set_baud_rate+0x252>
    1092:	48 30       	cpi	r20, 0x08	; 8
    1094:	09 f0       	breq	.+2      	; 0x1098 <_bluetooth_set_baud_rate+0x10c>
    1096:	e8 c0       	rjmp	.+464    	; 0x1268 <_bluetooth_set_baud_rate+0x2dc>
    1098:	8b c0       	rjmp	.+278    	; 0x11b0 <_bluetooth_set_baud_rate+0x224>
    109a:	43 33       	cpi	r20, 0x33	; 51
    109c:	a9 f1       	breq	.+106    	; 0x1108 <_bluetooth_set_baud_rate+0x17c>
    109e:	44 33       	cpi	r20, 0x34	; 52
    10a0:	38 f4       	brcc	.+14     	; 0x10b0 <_bluetooth_set_baud_rate+0x124>
    10a2:	40 31       	cpi	r20, 0x10	; 16
    10a4:	09 f4       	brne	.+2      	; 0x10a8 <_bluetooth_set_baud_rate+0x11c>
    10a6:	57 c0       	rjmp	.+174    	; 0x1156 <_bluetooth_set_baud_rate+0x1ca>
    10a8:	49 31       	cpi	r20, 0x19	; 25
    10aa:	09 f0       	breq	.+2      	; 0x10ae <_bluetooth_set_baud_rate+0x122>
    10ac:	dd c0       	rjmp	.+442    	; 0x1268 <_bluetooth_set_baud_rate+0x2dc>
    10ae:	3c c0       	rjmp	.+120    	; 0x1128 <_bluetooth_set_baud_rate+0x19c>
    10b0:	47 36       	cpi	r20, 0x67	; 103
    10b2:	d1 f0       	breq	.+52     	; 0x10e8 <_bluetooth_set_baud_rate+0x15c>
    10b4:	4f 3c       	cpi	r20, 0xCF	; 207
    10b6:	09 f0       	breq	.+2      	; 0x10ba <_bluetooth_set_baud_rate+0x12e>
    10b8:	d7 c0       	rjmp	.+430    	; 0x1268 <_bluetooth_set_baud_rate+0x2dc>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    10ba:	80 91 c0 00 	lds	r24, 0x00C0
    10be:	85 ff       	sbrs	r24, 5
    10c0:	fc cf       	rjmp	.-8      	; 0x10ba <_bluetooth_set_baud_rate+0x12e>
  UCSR0A=UCSR0A & 0xdf;
    10c2:	80 91 c0 00 	lds	r24, 0x00C0
    10c6:	8f 7d       	andi	r24, 0xDF	; 223
    10c8:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    10cc:	a0 93 c6 00 	sts	0x00C6, r26
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    10d0:	80 91 c0 00 	lds	r24, 0x00C0
    10d4:	85 ff       	sbrs	r24, 5
    10d6:	fc cf       	rjmp	.-8      	; 0x10d0 <_bluetooth_set_baud_rate+0x144>
  UCSR0A=UCSR0A & 0xdf;
    10d8:	80 91 c0 00 	lds	r24, 0x00C0
    10dc:	8f 7d       	andi	r24, 0xDF	; 223
    10de:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    10e2:	10 93 c6 00 	sts	0x00C6, r17
    10e6:	d6 c0       	rjmp	.+428    	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    10e8:	80 91 c0 00 	lds	r24, 0x00C0
    10ec:	85 ff       	sbrs	r24, 5
    10ee:	fc cf       	rjmp	.-8      	; 0x10e8 <_bluetooth_set_baud_rate+0x15c>
  UCSR0A=UCSR0A & 0xdf;
    10f0:	80 91 c0 00 	lds	r24, 0x00C0
    10f4:	8f 7d       	andi	r24, 0xDF	; 223
    10f6:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    10fa:	10 93 c6 00 	sts	0x00C6, r17
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    10fe:	80 91 c0 00 	lds	r24, 0x00C0
    1102:	85 ff       	sbrs	r24, 5
    1104:	fc cf       	rjmp	.-8      	; 0x10fe <_bluetooth_set_baud_rate+0x172>
    1106:	bf c0       	rjmp	.+382    	; 0x1286 <_bluetooth_set_baud_rate+0x2fa>
    1108:	80 91 c0 00 	lds	r24, 0x00C0
    110c:	85 ff       	sbrs	r24, 5
    110e:	fc cf       	rjmp	.-8      	; 0x1108 <_bluetooth_set_baud_rate+0x17c>
  UCSR0A=UCSR0A & 0xdf;
    1110:	80 91 c0 00 	lds	r24, 0x00C0
    1114:	8f 7d       	andi	r24, 0xDF	; 223
    1116:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    111a:	f0 92 c6 00 	sts	0x00C6, r15
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    111e:	80 91 c0 00 	lds	r24, 0x00C0
    1122:	85 ff       	sbrs	r24, 5
    1124:	fc cf       	rjmp	.-8      	; 0x111e <_bluetooth_set_baud_rate+0x192>
    1126:	98 c0       	rjmp	.+304    	; 0x1258 <_bluetooth_set_baud_rate+0x2cc>
    1128:	80 91 c0 00 	lds	r24, 0x00C0
    112c:	85 ff       	sbrs	r24, 5
    112e:	fc cf       	rjmp	.-8      	; 0x1128 <_bluetooth_set_baud_rate+0x19c>
  UCSR0A=UCSR0A & 0xdf;
    1130:	80 91 c0 00 	lds	r24, 0x00C0
    1134:	8f 7d       	andi	r24, 0xDF	; 223
    1136:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    113a:	b0 93 c6 00 	sts	0x00C6, r27
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    113e:	80 91 c0 00 	lds	r24, 0x00C0
    1142:	85 ff       	sbrs	r24, 5
    1144:	fc cf       	rjmp	.-8      	; 0x113e <_bluetooth_set_baud_rate+0x1b2>
  UCSR0A=UCSR0A & 0xdf;
    1146:	80 91 c0 00 	lds	r24, 0x00C0
    114a:	8f 7d       	andi	r24, 0xDF	; 223
    114c:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1150:	f0 92 c6 00 	sts	0x00C6, r15
    1154:	9f c0       	rjmp	.+318    	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1156:	80 91 c0 00 	lds	r24, 0x00C0
    115a:	85 ff       	sbrs	r24, 5
    115c:	fc cf       	rjmp	.-8      	; 0x1156 <_bluetooth_set_baud_rate+0x1ca>
  UCSR0A=UCSR0A & 0xdf;
    115e:	80 91 c0 00 	lds	r24, 0x00C0
    1162:	8f 7d       	andi	r24, 0xDF	; 223
    1164:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1168:	a0 93 c6 00 	sts	0x00C6, r26
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    116c:	80 91 c0 00 	lds	r24, 0x00C0
    1170:	85 ff       	sbrs	r24, 5
    1172:	fc cf       	rjmp	.-8      	; 0x116c <_bluetooth_set_baud_rate+0x1e0>
    1174:	88 c0       	rjmp	.+272    	; 0x1286 <_bluetooth_set_baud_rate+0x2fa>
    1176:	80 91 c0 00 	lds	r24, 0x00C0
    117a:	85 ff       	sbrs	r24, 5
    117c:	fc cf       	rjmp	.-8      	; 0x1176 <_bluetooth_set_baud_rate+0x1ea>
  UCSR0A=UCSR0A & 0xdf;
    117e:	80 91 c0 00 	lds	r24, 0x00C0
    1182:	8f 7d       	andi	r24, 0xDF	; 223
    1184:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1188:	00 93 c6 00 	sts	0x00C6, r16
    118c:	cb 01       	movw	r24, r22
    118e:	01 97       	sbiw	r24, 0x01	; 1
    1190:	f1 f7       	brne	.-4      	; 0x118e <_bluetooth_set_baud_rate+0x202>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1192:	80 91 c0 00 	lds	r24, 0x00C0
    1196:	85 ff       	sbrs	r24, 5
    1198:	fc cf       	rjmp	.-8      	; 0x1192 <_bluetooth_set_baud_rate+0x206>
  UCSR0A=UCSR0A & 0xdf;
    119a:	80 91 c0 00 	lds	r24, 0x00C0
    119e:	8f 7d       	andi	r24, 0xDF	; 223
    11a0:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    11a4:	e0 93 c6 00 	sts	0x00C6, r30
    11a8:	cb 01       	movw	r24, r22
    11aa:	01 97       	sbiw	r24, 0x01	; 1
    11ac:	f1 f7       	brne	.-4      	; 0x11aa <_bluetooth_set_baud_rate+0x21e>
    11ae:	72 c0       	rjmp	.+228    	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    11b0:	80 91 c0 00 	lds	r24, 0x00C0
    11b4:	85 ff       	sbrs	r24, 5
    11b6:	fc cf       	rjmp	.-8      	; 0x11b0 <_bluetooth_set_baud_rate+0x224>
  UCSR0A=UCSR0A & 0xdf;
    11b8:	80 91 c0 00 	lds	r24, 0x00C0
    11bc:	8f 7d       	andi	r24, 0xDF	; 223
    11be:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    11c2:	c0 92 c6 00 	sts	0x00C6, r12
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    11c6:	80 91 c0 00 	lds	r24, 0x00C0
    11ca:	85 ff       	sbrs	r24, 5
    11cc:	fc cf       	rjmp	.-8      	; 0x11c6 <_bluetooth_set_baud_rate+0x23a>
  UCSR0A=UCSR0A & 0xdf;
    11ce:	80 91 c0 00 	lds	r24, 0x00C0
    11d2:	8f 7d       	andi	r24, 0xDF	; 223
    11d4:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    11d8:	d0 92 c6 00 	sts	0x00C6, r13
    11dc:	5b c0       	rjmp	.+182    	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    11de:	80 91 c0 00 	lds	r24, 0x00C0
    11e2:	85 ff       	sbrs	r24, 5
    11e4:	fc cf       	rjmp	.-8      	; 0x11de <_bluetooth_set_baud_rate+0x252>
  UCSR0A=UCSR0A & 0xdf;
    11e6:	80 91 c0 00 	lds	r24, 0x00C0
    11ea:	8f 7d       	andi	r24, 0xDF	; 223
    11ec:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    11f0:	b0 93 c6 00 	sts	0x00C6, r27
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    11f4:	80 91 c0 00 	lds	r24, 0x00C0
    11f8:	85 ff       	sbrs	r24, 5
    11fa:	fc cf       	rjmp	.-8      	; 0x11f4 <_bluetooth_set_baud_rate+0x268>
  UCSR0A=UCSR0A & 0xdf;
    11fc:	80 91 c0 00 	lds	r24, 0x00C0
    1200:	8f 7d       	andi	r24, 0xDF	; 223
    1202:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1206:	b0 93 c6 00 	sts	0x00C6, r27
    120a:	44 c0       	rjmp	.+136    	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    120c:	80 91 c0 00 	lds	r24, 0x00C0
    1210:	85 ff       	sbrs	r24, 5
    1212:	fc cf       	rjmp	.-8      	; 0x120c <_bluetooth_set_baud_rate+0x280>
  UCSR0A=UCSR0A & 0xdf;
    1214:	80 91 c0 00 	lds	r24, 0x00C0
    1218:	8f 7d       	andi	r24, 0xDF	; 223
    121a:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    121e:	a0 93 c6 00 	sts	0x00C6, r26
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1222:	80 91 c0 00 	lds	r24, 0x00C0
    1226:	85 ff       	sbrs	r24, 5
    1228:	fc cf       	rjmp	.-8      	; 0x1222 <_bluetooth_set_baud_rate+0x296>
  UCSR0A=UCSR0A & 0xdf;
    122a:	80 91 c0 00 	lds	r24, 0x00C0
    122e:	8f 7d       	andi	r24, 0xDF	; 223
    1230:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1234:	00 93 c6 00 	sts	0x00C6, r16
    1238:	2d c0       	rjmp	.+90     	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    123a:	80 91 c0 00 	lds	r24, 0x00C0
    123e:	85 ff       	sbrs	r24, 5
    1240:	fc cf       	rjmp	.-8      	; 0x123a <_bluetooth_set_baud_rate+0x2ae>
  UCSR0A=UCSR0A & 0xdf;
    1242:	80 91 c0 00 	lds	r24, 0x00C0
    1246:	8f 7d       	andi	r24, 0xDF	; 223
    1248:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    124c:	10 93 c6 00 	sts	0x00C6, r17
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1250:	80 91 c0 00 	lds	r24, 0x00C0
    1254:	85 ff       	sbrs	r24, 5
    1256:	fc cf       	rjmp	.-8      	; 0x1250 <_bluetooth_set_baud_rate+0x2c4>
  UCSR0A=UCSR0A & 0xdf;
    1258:	80 91 c0 00 	lds	r24, 0x00C0
    125c:	8f 7d       	andi	r24, 0xDF	; 223
    125e:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1262:	e0 92 c6 00 	sts	0x00C6, r14
    1266:	16 c0       	rjmp	.+44     	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1268:	80 91 c0 00 	lds	r24, 0x00C0
    126c:	85 ff       	sbrs	r24, 5
    126e:	fc cf       	rjmp	.-8      	; 0x1268 <_bluetooth_set_baud_rate+0x2dc>
  UCSR0A=UCSR0A & 0xdf;
    1270:	80 91 c0 00 	lds	r24, 0x00C0
    1274:	8f 7d       	andi	r24, 0xDF	; 223
    1276:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    127a:	00 93 c6 00 	sts	0x00C6, r16
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    127e:	80 91 c0 00 	lds	r24, 0x00C0
    1282:	85 ff       	sbrs	r24, 5
    1284:	fc cf       	rjmp	.-8      	; 0x127e <_bluetooth_set_baud_rate+0x2f2>
  UCSR0A=UCSR0A & 0xdf;
    1286:	80 91 c0 00 	lds	r24, 0x00C0
    128a:	8f 7d       	andi	r24, 0xDF	; 223
    128c:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1290:	e0 93 c6 00 	sts	0x00C6, r30
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1294:	80 91 c0 00 	lds	r24, 0x00C0
    1298:	85 ff       	sbrs	r24, 5
    129a:	fc cf       	rjmp	.-8      	; 0x1294 <_bluetooth_set_baud_rate+0x308>
  UCSR0A=UCSR0A & 0xdf;
    129c:	80 91 c0 00 	lds	r24, 0x00C0
    12a0:	8f 7d       	andi	r24, 0xDF	; 223
    12a2:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    12a6:	f0 93 c6 00 	sts	0x00C6, r31
    12aa:	cb 01       	movw	r24, r22
    12ac:	01 97       	sbiw	r24, 0x01	; 1
    12ae:	f1 f7       	brne	.-4      	; 0x12ac <_bluetooth_set_baud_rate+0x320>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    12b0:	80 91 c0 00 	lds	r24, 0x00C0
    12b4:	85 ff       	sbrs	r24, 5
    12b6:	fc cf       	rjmp	.-8      	; 0x12b0 <_bluetooth_set_baud_rate+0x324>
  UCSR0A=UCSR0A & 0xdf;
    12b8:	80 91 c0 00 	lds	r24, 0x00C0
    12bc:	8f 7d       	andi	r24, 0xDF	; 223
    12be:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    12c2:	f0 93 c6 00 	sts	0x00C6, r31
    12c6:	cb 01       	movw	r24, r22
    12c8:	01 97       	sbiw	r24, 0x01	; 1
    12ca:	f1 f7       	brne	.-4      	; 0x12c8 <_bluetooth_set_baud_rate+0x33c>


unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
    12cc:	80 91 c0 00 	lds	r24, 0x00C0
    12d0:	87 fd       	sbrc	r24, 7
    12d2:	04 c0       	rjmp	.+8      	; 0x12dc <_bluetooth_set_baud_rate+0x350>
    12d4:	80 91 c0 00 	lds	r24, 0x00C0
    12d8:	87 ff       	sbrs	r24, 7
    12da:	06 c0       	rjmp	.+12     	; 0x12e8 <_bluetooth_set_baud_rate+0x35c>
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
    12dc:	80 91 c6 00 	lds	r24, 0x00C6
		_delay_ms(5);

		attempts++;
		if (_bluetooth_receive_uart0_byte(&aByte))
		{
			if (aByte=='A')			
    12e0:	81 34       	cpi	r24, 0x41	; 65
    12e2:	11 f4       	brne	.+4      	; 0x12e8 <_bluetooth_set_baud_rate+0x35c>
    12e4:	81 e0       	ldi	r24, 0x01	; 1
    12e6:	05 c0       	rjmp	.+10     	; 0x12f2 <_bluetooth_set_baud_rate+0x366>
		_bluetooth_transmit_uart0_byte(13);
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
		_delay_ms(5);

		attempts++;
    12e8:	5f 5f       	subi	r21, 0xFF	; 255
		if (_bluetooth_receive_uart0_byte(&aByte))
		{
			if (aByte=='A')			
				return 1;					
		}
		if (attempts>=255)
    12ea:	5f 3f       	cpi	r21, 0xFF	; 255
    12ec:	09 f0       	breq	.+2      	; 0x12f0 <_bluetooth_set_baud_rate+0x364>
    12ee:	6f ce       	rjmp	.-802    	; 0xfce <_bluetooth_set_baud_rate+0x42>
    12f0:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	// succeeded in entering command mode

	return 0;
}
    12f2:	1f 91       	pop	r17
    12f4:	0f 91       	pop	r16
    12f6:	ff 90       	pop	r15
    12f8:	ef 90       	pop	r14
    12fa:	df 90       	pop	r13
    12fc:	cf 90       	pop	r12
    12fe:	bf 90       	pop	r11
    1300:	af 90       	pop	r10
    1302:	9f 90       	pop	r9
    1304:	08 95       	ret

00001306 <_bluetooth_get_baud_rate>:


unsigned char _bluetooth_get_baud_rate()
{
    1306:	30 e0       	ldi	r19, 0x00	; 0
    1308:	20 e0       	ldi	r18, 0x00	; 0
void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
  UCSR0A=UCSR0A & 0xdf;
  
  UDR0 =  data;  /* Start transmission   */
    130a:	6d e0       	ldi	r22, 0x0D	; 13
    130c:	40 e1       	ldi	r20, 0x10	; 16
    130e:	57 e2       	ldi	r21, 0x27	; 39
    1310:	e7 e4       	ldi	r30, 0x47	; 71
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1312:	75 e5       	ldi	r23, 0x55	; 85
    1314:	80 91 c0 00 	lds	r24, 0x00C0
    1318:	85 ff       	sbrs	r24, 5
    131a:	fc cf       	rjmp	.-8      	; 0x1314 <_bluetooth_get_baud_rate+0xe>
  UCSR0A=UCSR0A & 0xdf;
    131c:	80 91 c0 00 	lds	r24, 0x00C0
    1320:	8f 7d       	andi	r24, 0xDF	; 223
    1322:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1326:	60 93 c6 00 	sts	0x00C6, r22
    132a:	ca 01       	movw	r24, r20
    132c:	01 97       	sbiw	r24, 0x01	; 1
    132e:	f1 f7       	brne	.-4      	; 0x132c <_bluetooth_get_baud_rate+0x26>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1330:	80 91 c0 00 	lds	r24, 0x00C0
    1334:	85 ff       	sbrs	r24, 5
    1336:	fc cf       	rjmp	.-8      	; 0x1330 <_bluetooth_get_baud_rate+0x2a>
  UCSR0A=UCSR0A & 0xdf;
    1338:	80 91 c0 00 	lds	r24, 0x00C0
    133c:	8f 7d       	andi	r24, 0xDF	; 223
    133e:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1342:	60 93 c6 00 	sts	0x00C6, r22
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1346:	80 91 c0 00 	lds	r24, 0x00C0
    134a:	85 ff       	sbrs	r24, 5
    134c:	fc cf       	rjmp	.-8      	; 0x1346 <_bluetooth_get_baud_rate+0x40>
  UCSR0A=UCSR0A & 0xdf;
    134e:	80 91 c0 00 	lds	r24, 0x00C0
    1352:	8f 7d       	andi	r24, 0xDF	; 223
    1354:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1358:	e0 93 c6 00 	sts	0x00C6, r30
    135c:	ca 01       	movw	r24, r20
    135e:	01 97       	sbiw	r24, 0x01	; 1
    1360:	f1 f7       	brne	.-4      	; 0x135e <_bluetooth_get_baud_rate+0x58>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1362:	80 91 c0 00 	lds	r24, 0x00C0
    1366:	85 ff       	sbrs	r24, 5
    1368:	fc cf       	rjmp	.-8      	; 0x1362 <_bluetooth_get_baud_rate+0x5c>
  UCSR0A=UCSR0A & 0xdf;
    136a:	80 91 c0 00 	lds	r24, 0x00C0
    136e:	8f 7d       	andi	r24, 0xDF	; 223
    1370:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1374:	70 93 c6 00 	sts	0x00C6, r23
    1378:	ca 01       	movw	r24, r20
    137a:	01 97       	sbiw	r24, 0x01	; 1
    137c:	f1 f7       	brne	.-4      	; 0x137a <_bluetooth_get_baud_rate+0x74>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    137e:	80 91 c0 00 	lds	r24, 0x00C0
    1382:	85 ff       	sbrs	r24, 5
    1384:	fc cf       	rjmp	.-8      	; 0x137e <_bluetooth_get_baud_rate+0x78>
  UCSR0A=UCSR0A & 0xdf;
    1386:	80 91 c0 00 	lds	r24, 0x00C0
    138a:	8f 7d       	andi	r24, 0xDF	; 223
    138c:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1390:	60 93 c6 00 	sts	0x00C6, r22
    1394:	ca 01       	movw	r24, r20
    1396:	01 97       	sbiw	r24, 0x01	; 1
    1398:	f1 f7       	brne	.-4      	; 0x1396 <_bluetooth_get_baud_rate+0x90>
  }


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    139a:	80 91 c0 00 	lds	r24, 0x00C0
    139e:	85 ff       	sbrs	r24, 5
    13a0:	fc cf       	rjmp	.-8      	; 0x139a <_bluetooth_get_baud_rate+0x94>
  UCSR0A=UCSR0A & 0xdf;
    13a2:	80 91 c0 00 	lds	r24, 0x00C0
    13a6:	8f 7d       	andi	r24, 0xDF	; 223
    13a8:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    13ac:	60 93 c6 00 	sts	0x00C6, r22
    13b0:	ca 01       	movw	r24, r20
    13b2:	01 97       	sbiw	r24, 0x01	; 1
    13b4:	f1 f7       	brne	.-4      	; 0x13b2 <_bluetooth_get_baud_rate+0xac>
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
		_delay_ms(5);


		attempts++;
    13b6:	3f 5f       	subi	r19, 0xFF	; 255
 		if ((attempts>=255) || (_bluetooth_receive_uart0_byte(&baudrate)==0))
    13b8:	3f 3f       	cpi	r19, 0xFF	; 255
    13ba:	21 f1       	breq	.+72     	; 0x1404 <_bluetooth_get_baud_rate+0xfe>


unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
    13bc:	80 91 c0 00 	lds	r24, 0x00C0
    13c0:	87 fd       	sbrc	r24, 7
    13c2:	14 c0       	rjmp	.+40     	; 0x13ec <_bluetooth_get_baud_rate+0xe6>
    13c4:	80 91 c0 00 	lds	r24, 0x00C0
    13c8:	87 fd       	sbrc	r24, 7
    13ca:	10 c0       	rjmp	.+32     	; 0x13ec <_bluetooth_get_baud_rate+0xe6>
			break;

	}
	if (attempts<255)
	{	
		switch(baudrate)
    13cc:	24 33       	cpi	r18, 0x34	; 52
    13ce:	89 f0       	breq	.+34     	; 0x13f2 <_bluetooth_get_baud_rate+0xec>
    13d0:	25 33       	cpi	r18, 0x35	; 53
    13d2:	28 f4       	brcc	.+10     	; 0x13de <_bluetooth_get_baud_rate+0xd8>
    13d4:	21 33       	cpi	r18, 0x31	; 49
    13d6:	89 f0       	breq	.+34     	; 0x13fa <_bluetooth_get_baud_rate+0xf4>
    13d8:	22 33       	cpi	r18, 0x32	; 50
    13da:	99 f4       	brne	.+38     	; 0x1402 <_bluetooth_get_baud_rate+0xfc>
    13dc:	05 c0       	rjmp	.+10     	; 0x13e8 <_bluetooth_get_baud_rate+0xe2>
    13de:	25 33       	cpi	r18, 0x35	; 53
    13e0:	71 f0       	breq	.+28     	; 0x13fe <_bluetooth_get_baud_rate+0xf8>
    13e2:	29 33       	cpi	r18, 0x39	; 57
    13e4:	71 f4       	brne	.+28     	; 0x1402 <_bluetooth_get_baud_rate+0xfc>
    13e6:	07 c0       	rjmp	.+14     	; 0x13f6 <_bluetooth_get_baud_rate+0xf0>
    13e8:	2f ec       	ldi	r18, 0xCF	; 207
    13ea:	0c c0       	rjmp	.+24     	; 0x1404 <_bluetooth_get_baud_rate+0xfe>
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
    13ec:	20 91 c6 00 	lds	r18, 0x00C6
    13f0:	91 cf       	rjmp	.-222    	; 0x1314 <_bluetooth_get_baud_rate+0xe>
    13f2:	27 e6       	ldi	r18, 0x67	; 103
    13f4:	07 c0       	rjmp	.+14     	; 0x1404 <_bluetooth_get_baud_rate+0xfe>
    13f6:	23 e3       	ldi	r18, 0x33	; 51
    13f8:	05 c0       	rjmp	.+10     	; 0x1404 <_bluetooth_get_baud_rate+0xfe>
			case '4':
				baudrate=ATMEGA_BAUD_4800;
				break;
			case '9':
				baudrate=ATMEGA_BAUD_9600;
				break;
    13fa:	23 e0       	ldi	r18, 0x03	; 3
    13fc:	03 c0       	rjmp	.+6      	; 0x1404 <_bluetooth_get_baud_rate+0xfe>
			case '1':
				baudrate=ATMEGA_BAUD_115200;
				break;
    13fe:	28 e0       	ldi	r18, 0x08	; 8
    1400:	01 c0       	rjmp	.+2      	; 0x1404 <_bluetooth_get_baud_rate+0xfe>
			case '5':
				baudrate=ATMEGA_BAUD_57600;
				break;
    1402:	2c e0       	ldi	r18, 0x0C	; 12
				break;
			}
	}
	
	return baudrate;
}
    1404:	82 2f       	mov	r24, r18
    1406:	08 95       	ret

00001408 <_bluetooth_turn_on>:
	
*/
void _bluetooth_turn_on(void)
{
	// Set the direction of TX pin as output
	sbi(DDRD,OUT_BT_TXD_PD1);
    1408:	51 9a       	sbi	0x0a, 1	; 10

	// Set the direction of the RESET pin as output and high
	sbi(DDRD,OUT_BT_RESET_N_PD2);	
    140a:	52 9a       	sbi	0x0a, 2	; 10
	sbi(PORTD,OUT_BT_RESET_N_PD2);  
    140c:	5a 9a       	sbi	0x0b, 2	; 11

	// Set the direction of the switch pin as output and low
	sbi(DDRB,OUT_BT_SW_N_PB4);
    140e:	24 9a       	sbi	0x04, 4	; 4
	cbi(PORTB,OUT_BT_SW_N_PB4);
    1410:	2c 98       	cbi	0x05, 4	; 5

	// Set the status of the bluetooth to true
	sbi(wocket_status, BIT0_BLUETOOTH_STATUS);
    1412:	80 91 23 01 	lds	r24, 0x0123
    1416:	81 60       	ori	r24, 0x01	; 1
    1418:	80 93 23 01 	sts	0x0123, r24
}
    141c:	08 95       	ret

0000141e <_bluetooth_turn_off>:
	
*/
void _bluetooth_turn_off(void)
{
	// Set the direction of TX, RESET and switch pins as input
	cbi(DDRD,OUT_BT_TXD_PD1);
    141e:	51 98       	cbi	0x0a, 1	; 10
	cbi(DDRD,OUT_BT_RESET_N_PD2);
    1420:	52 98       	cbi	0x0a, 2	; 10
	cbi(DDRB,OUT_BT_SW_N_PB4);		 
    1422:	24 98       	cbi	0x04, 4	; 4

	// Set the status of bluetooth to false
	cbi(wocket_status, BIT0_BLUETOOTH_STATUS);
    1424:	80 91 23 01 	lds	r24, 0x0123
    1428:	8e 7f       	andi	r24, 0xFE	; 254
    142a:	80 93 23 01 	sts	0x0123, r24
}
    142e:	08 95       	ret

00001430 <_is_bluetooth_on>:
	Description: Tests if the bluetooth status bit is on
	
*/

unsigned char _is_bluetooth_on(void)
{
    1430:	80 91 23 01 	lds	r24, 0x0123
	return ((wocket_status>>BIT0_BLUETOOTH_STATUS) & 0x01);
}
    1434:	81 70       	andi	r24, 0x01	; 1
    1436:	08 95       	ret

00001438 <_bluetooth_is_connected>:



unsigned char _bluetooth_is_connected(void){

        return (0x01 & (PIND>>IN_BT_CONNECT_PD4));
    1438:	89 b1       	in	r24, 0x09	; 9
    143a:	82 95       	swap	r24


}
    143c:	81 70       	andi	r24, 0x01	; 1
    143e:	08 95       	ret

00001440 <_bluetooth_is_discoverable>:


unsigned char _bluetooth_is_discoverable(void){

        return (0x01 & (PIND>>IN_BT_DISC_PD5));
    1440:	89 b1       	in	r24, 0x09	; 9
    1442:	82 95       	swap	r24
    1444:	86 95       	lsr	r24
}
    1446:	81 70       	andi	r24, 0x01	; 1
    1448:	08 95       	ret

0000144a <_bluetooth_receive_uart0_byte>:


unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
    144a:	fc 01       	movw	r30, r24
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
    144c:	80 91 c0 00 	lds	r24, 0x00C0
    1450:	87 fd       	sbrc	r24, 7
    1452:	06 c0       	rjmp	.+12     	; 0x1460 <_bluetooth_receive_uart0_byte+0x16>
    1454:	80 91 c0 00 	lds	r24, 0x00C0
    1458:	87 fd       	sbrc	r24, 7
    145a:	02 c0       	rjmp	.+4      	; 0x1460 <_bluetooth_receive_uart0_byte+0x16>
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	08 95       	ret
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
    1460:	80 91 c6 00 	lds	r24, 0x00C6
    1464:	80 83       	st	Z, r24
    1466:	81 e0       	ldi	r24, 0x01	; 1

   return 1;/* Return success*/
  }
    1468:	08 95       	ret

0000146a <_bluetooth_transmit_uart0_byte>:


void _bluetooth_transmit_uart0_byte( unsigned char data )
{
    146a:	98 2f       	mov	r25, r24
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    146c:	80 91 c0 00 	lds	r24, 0x00C0
    1470:	85 ff       	sbrs	r24, 5
    1472:	fc cf       	rjmp	.-8      	; 0x146c <_bluetooth_transmit_uart0_byte+0x2>
  UCSR0A=UCSR0A & 0xdf;
    1474:	80 91 c0 00 	lds	r24, 0x00C0
    1478:	8f 7d       	andi	r24, 0xDF	; 223
    147a:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    147e:	90 93 c6 00 	sts	0x00C6, r25
   
}
    1482:	08 95       	ret

00001484 <_accelerometer_set_sensitivity>:

/* Accelerometer Functions */

unsigned char _accelerometer_set_sensitivity(unsigned char level){
  	
	if (level==_1_5G){
    1484:	88 23       	and	r24, r24
    1486:	11 f4       	brne	.+4      	; 0x148c <_accelerometer_set_sensitivity+0x8>
		cbi(PORTB,OUT_ACCEL_SEL1_PB0);
    1488:	28 98       	cbi	0x05, 0	; 5
    148a:	05 c0       	rjmp	.+10     	; 0x1496 <_accelerometer_set_sensitivity+0x12>
		cbi(PORTB,OUT_ACCEL_SEL2_PB1);
		return _1_5G;
	}else if (level==_2G){
    148c:	81 30       	cpi	r24, 0x01	; 1
    148e:	11 f0       	breq	.+4      	; 0x1494 <_accelerometer_set_sensitivity+0x10>
		sbi(PORTB,OUT_ACCEL_SEL1_PB0);
		cbi(PORTB,OUT_ACCEL_SEL2_PB1);
		return _2G;
	}else if (level==_4G){
    1490:	82 30       	cpi	r24, 0x02	; 2
    1492:	19 f4       	brne	.+6      	; 0x149a <_accelerometer_set_sensitivity+0x16>
		sbi(PORTB,OUT_ACCEL_SEL1_PB0);
    1494:	28 9a       	sbi	0x05, 0	; 5
		cbi(PORTB,OUT_ACCEL_SEL2_PB1);
    1496:	29 98       	cbi	0x05, 1	; 5
    1498:	08 95       	ret
		return _4G;
	}else if (level==_6G){
    149a:	83 30       	cpi	r24, 0x03	; 3
    149c:	11 f0       	breq	.+4      	; 0x14a2 <_accelerometer_set_sensitivity+0x1e>
    149e:	80 e0       	ldi	r24, 0x00	; 0
    14a0:	08 95       	ret
		sbi(PORTB,OUT_ACCEL_SEL1_PB0);
    14a2:	28 9a       	sbi	0x05, 0	; 5
		sbi(PORTB,OUT_ACCEL_SEL2_PB1);
    14a4:	29 9a       	sbi	0x05, 1	; 5
    14a6:	83 e0       	ldi	r24, 0x03	; 3
		return _6G;
	}

	return 0;
}
    14a8:	08 95       	ret

000014aa <_atmega_initialize>:
	
	Description: This function initializes the MCU. By default all pins are set as inputs to minize power consumption.
	
*/
void _atmega_initialize(unsigned char timer_prescalar)
{
    14aa:	cf 92       	push	r12
    14ac:	df 92       	push	r13
    14ae:	ef 92       	push	r14
    14b0:	ff 92       	push	r15
    14b2:	0f 93       	push	r16
    14b4:	1f 93       	push	r17
    14b6:	cf 93       	push	r28
    14b8:	df 93       	push	r29
    14ba:	c8 2e       	mov	r12, r24

	unsigned char prev_osccal=OSCCAL;
    14bc:	d0 90 66 00 	lds	r13, 0x0066
	Description: This function turns on the yellow led
	
*/
void _yellowled_turn_on(void)
{
	sbi(DDRC,OUT_LED_YE_PC2);
    14c0:	3a 9a       	sbi	0x07, 2	; 7
	sbi(PORTC,OUT_LED_YE_PC2);
    14c2:	42 9a       	sbi	0x08, 2	; 8
*/
void _atmega_disable_JTAG(void)
{
	unsigned char sreg;

	sreg = SREG;
    14c4:	9f b7       	in	r25, 0x3f	; 63
	cli();
    14c6:	f8 94       	cli
	MCUCR |= ( 1 <<JTD );
    14c8:	85 b7       	in	r24, 0x35	; 53
    14ca:	80 68       	ori	r24, 0x80	; 128
    14cc:	85 bf       	out	0x35, r24	; 53
	MCUCR |= ( 1 <<JTD );
    14ce:	85 b7       	in	r24, 0x35	; 53
    14d0:	80 68       	ori	r24, 0x80	; 128
    14d2:	85 bf       	out	0x35, r24	; 53
	SREG = sreg;
    14d4:	9f bf       	out	0x3f, r25	; 63
	_atmega_disable_JTAG();

	
	// By default initialize all ports as input to minimize power consumption
	// Setup Port A pins as input to minimize power consumption	
	cbi(DDRA,IN_VSENSE_COMP_PA0);
    14d6:	08 98       	cbi	0x01, 0	; 1
	cbi(DDRA,IN_ACCEL_Z_FILT_PA1);
    14d8:	09 98       	cbi	0x01, 1	; 1
	cbi(DDRA,IN_ACCEL_Y_FILT_PA2);
    14da:	0a 98       	cbi	0x01, 2	; 1
	cbi(DDRA,IN_ACCEL_X_FILT_PA3);
    14dc:	0b 98       	cbi	0x01, 3	; 1
	cbi(DDRA,IN_VSENSE_BAT_PA4);
    14de:	0c 98       	cbi	0x01, 4	; 1
	cbi(DDRA,IN_USER_N_PA5);
    14e0:	0d 98       	cbi	0x01, 5	; 1
	cbi(DDRA,FLOAT_PA6);
    14e2:	0e 98       	cbi	0x01, 6	; 1
	cbi(DDRA,FLOAT_PA7);
    14e4:	0f 98       	cbi	0x01, 7	; 1

	// Setup Port B pins as input to minimize power consumption
	cbi(DDRB,OUT_ACCEL_SEL1_PB0);	
    14e6:	20 98       	cbi	0x04, 0	; 4
	cbi(DDRB,OUT_ACCEL_SEL2_PB1);
    14e8:	21 98       	cbi	0x04, 1	; 4
	cbi(DDRB,IN_VSENSE_COMP_PB2);
    14ea:	22 98       	cbi	0x04, 2	; 4
	cbi(PORTB,IN_VSENSE_COMP_PB2);
    14ec:	2a 98       	cbi	0x05, 2	; 5
	cbi(DDRB,OUT_ACCEL_SLEEP_N_PB3);
    14ee:	23 98       	cbi	0x04, 3	; 4
	cbi(DDRB,OUT_BT_SW_N_PB4);	
    14f0:	24 98       	cbi	0x04, 4	; 4
	cbi(DDRB,IN_CPU_PROG_MOSI_PB5);
    14f2:	25 98       	cbi	0x04, 5	; 4
	cbi(DDRB,OUT_CPU_PROG_MISO_PB6);	
    14f4:	26 98       	cbi	0x04, 6	; 4
	cbi(DDRB,IN_CPU_PROG_SCLK_PB7);	
    14f6:	27 98       	cbi	0x04, 7	; 4
	
	// Setup Port C pins as input to minimize power consumption
	cbi(DDRC,FLOAT_PC0);	
    14f8:	38 98       	cbi	0x07, 0	; 7
	cbi(DDRC,OUT_LED_GN_PC1);	
    14fa:	39 98       	cbi	0x07, 1	; 7
	//cbi(DDRC,OUT_LED_YE_PC2);	
	cbi(DDRC,FLOAT_PC3);	
    14fc:	3b 98       	cbi	0x07, 3	; 7
	cbi(DDRC,FLOAT_PC4);	
    14fe:	3c 98       	cbi	0x07, 4	; 7
	cbi(DDRC,FLOAT_PC5);	
    1500:	3d 98       	cbi	0x07, 5	; 7
	cbi(DDRC,FLOAT_PC6);	
    1502:	3e 98       	cbi	0x07, 6	; 7
	cbi(DDRC,FLOAT_PC7);	
    1504:	3f 98       	cbi	0x07, 7	; 7

	// Setup Port D pins as input to minimize power consumption
	cbi(DDRD,IN_BT_RXD_PD0);	
    1506:	50 98       	cbi	0x0a, 0	; 10
	cbi(DDRD,OUT_BT_TXD_PD1);	
    1508:	51 98       	cbi	0x0a, 1	; 10
	cbi(DDRD,OUT_BT_RESET_N_PD2);	
    150a:	52 98       	cbi	0x0a, 2	; 10
	cbi(DDRD,IN_VIB_SW_N_PD3);	
    150c:	53 98       	cbi	0x0a, 3	; 10
	cbi(DDRD,IN_BT_CONNECT_PD4);	
    150e:	54 98       	cbi	0x0a, 4	; 10
	cbi(DDRD,IN_BT_DISC_PD5);	
    1510:	55 98       	cbi	0x0a, 5	; 10
	cbi(DDRD,FLOAT_PD6);
    1512:	56 98       	cbi	0x0a, 6	; 10
	cbi(DDRD,FLOAT_PD7);	
    1514:	57 98       	cbi	0x0a, 7	; 10
	
*/
void _bluetooth_turn_on(void)
{
	// Set the direction of TX pin as output
	sbi(DDRD,OUT_BT_TXD_PD1);
    1516:	51 9a       	sbi	0x0a, 1	; 10

	// Set the direction of the RESET pin as output and high
	sbi(DDRD,OUT_BT_RESET_N_PD2);	
    1518:	52 9a       	sbi	0x0a, 2	; 10
	sbi(PORTD,OUT_BT_RESET_N_PD2);  
    151a:	5a 9a       	sbi	0x0b, 2	; 11

	// Set the direction of the switch pin as output and low
	sbi(DDRB,OUT_BT_SW_N_PB4);
    151c:	24 9a       	sbi	0x04, 4	; 4
	cbi(PORTB,OUT_BT_SW_N_PB4);
    151e:	2c 98       	cbi	0x05, 4	; 5
	Description: This function turns on the accelerometer module and sets the pins properly
	
*/
void _accelerometer_turn_on(void)
{
	sbi(DDRB,OUT_ACCEL_SEL1_PB0);	
    1520:	20 9a       	sbi	0x04, 0	; 4
	sbi(DDRB,OUT_ACCEL_SEL2_PB1);
    1522:	21 9a       	sbi	0x04, 1	; 4
	sbi(DDRB,OUT_ACCEL_SLEEP_N_PB3);
    1524:	23 9a       	sbi	0x04, 3	; 4
	sbi(PORTB,OUT_ACCEL_SLEEP_N_PB3);	 
    1526:	2b 9a       	sbi	0x05, 3	; 5
	 			
	// Set the status of the accelerometer to true
	sbi(wocket_status, BIT1_ACCELEROMETER_STATUS);
    1528:	83 e0       	ldi	r24, 0x03	; 3
    152a:	80 93 23 01 	sts	0x0123, r24
	cbi(DDRD,FLOAT_PD7);	

	/* Set peripherials to the lowest power states */
	_bluetooth_turn_on();
	_accelerometer_turn_on();
	_accelerometer_set_sensitivity(_4G);
    152e:	82 e0       	ldi	r24, 0x02	; 2
    1530:	0e 94 42 0a 	call	0x1484	; 0x1484 <_accelerometer_set_sensitivity>
	
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
    1534:	10 92 c5 00 	sts	0x00C5, r1
        UBRR0L = (unsigned char)baud;
    1538:	8c e0       	ldi	r24, 0x0C	; 12
    153a:	80 93 c4 00 	sts	0x00C4, r24
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    153e:	88 e1       	ldi	r24, 0x18	; 24
    1540:	80 93 c1 00 	sts	0x00C1, r24
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    1544:	86 e0       	ldi	r24, 0x06	; 6
    1546:	80 93 c2 00 	sts	0x00C2, r24

	//First check if the radio is set at the correct baud rate
	//if the wocket yellow light does not go off, the wocket has not been
	
	_atmega_initialize_uart0(ATMEGA_BAUD_38400, TX_RX_UART_MODE);
	if ((_bluetooth_enter_command_mode()))
    154a:	0e 94 e5 06 	call	0xdca	; 0xdca <_bluetooth_enter_command_mode>
    154e:	88 23       	and	r24, r24
    1550:	b1 f0       	breq	.+44     	; 0x157e <_atmega_initialize+0xd4>
	
*/
void _yellowled_turn_off(void)
{

	sbi(DDRC,OUT_LED_YE_PC2);
    1552:	3a 9a       	sbi	0x07, 2	; 7
	cbi(PORTC,OUT_LED_YE_PC2);
    1554:	42 98       	cbi	0x08, 2	; 8
	cbi(DDRC,OUT_LED_YE_PC2);	
    1556:	3a 98       	cbi	0x07, 2	; 7
	
	// Set the status of the yellow led to false
	cbi(wocket_status, BIT3_YELLOWLED_STATUS);
    1558:	80 91 23 01 	lds	r24, 0x0123
    155c:	87 7f       	andi	r24, 0xF7	; 247
    155e:	80 93 23 01 	sts	0x0123, r24
	
	_atmega_initialize_uart0(ATMEGA_BAUD_38400, TX_RX_UART_MODE);
	if ((_bluetooth_enter_command_mode()))
	{	
		_yellowled_turn_off();
		if (_bluetooth_get_baud_rate()==ATMEGA_BAUD_38400)
    1562:	0e 94 83 09 	call	0x1306	; 0x1306 <_bluetooth_get_baud_rate>
    1566:	8c 30       	cpi	r24, 0x0C	; 12
    1568:	09 f0       	breq	.+2      	; 0x156c <_atmega_initialize+0xc2>
    156a:	41 c0       	rjmp	.+130    	; 0x15ee <_atmega_initialize+0x144>
	
*/
void _yellowled_turn_off(void)
{

	sbi(DDRC,OUT_LED_YE_PC2);
    156c:	3a 9a       	sbi	0x07, 2	; 7
	cbi(PORTC,OUT_LED_YE_PC2);
    156e:	42 98       	cbi	0x08, 2	; 8
	cbi(DDRC,OUT_LED_YE_PC2);	
    1570:	3a 98       	cbi	0x07, 2	; 7
	
	// Set the status of the yellow led to false
	cbi(wocket_status, BIT3_YELLOWLED_STATUS);
    1572:	80 91 23 01 	lds	r24, 0x0123
    1576:	87 7f       	andi	r24, 0xF7	; 247
    1578:	80 93 23 01 	sts	0x0123, r24
    157c:	38 c0       	rjmp	.+112    	; 0x15ee <_atmega_initialize+0x144>
    157e:	10 e5       	ldi	r17, 0x50	; 80
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
        UBRR0L = (unsigned char)baud;
    1580:	83 e0       	ldi	r24, 0x03	; 3
    1582:	e8 2e       	mov	r14, r24
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    1584:	08 e1       	ldi	r16, 0x18	; 24
    1586:	f0 2e       	mov	r15, r16
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    1588:	06 e0       	ldi	r16, 0x06	; 6

		
		// To run at 115K, we need to set the OSCCAL as follows, the value was
		// determined experimentally by trying different values	
		for (unsigned char i=0x50;(i<255);i++){
			OSCCAL= i;
    158a:	10 93 66 00 	sts	0x0066, r17
    158e:	c0 e0       	ldi	r28, 0x00	; 0
    1590:	d0 e0       	ldi	r29, 0x00	; 0
	
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
    1592:	10 92 c5 00 	sts	0x00C5, r1
        UBRR0L = (unsigned char)baud;
    1596:	e0 92 c4 00 	sts	0x00C4, r14
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    159a:	f0 92 c1 00 	sts	0x00C1, r15
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    159e:	00 93 c2 00 	sts	0x00C2, r16
			for (int j=0;(j<10);j++)
			{
				// To deal with a radio firmware bug, we are making sure the radio is set at the
				// correct baud rate of 38.4K
				_atmega_initialize_uart0(ATMEGA_BAUD_115200, TX_RX_UART_MODE);
				if ((_bluetooth_enter_command_mode()))
    15a2:	0e 94 e5 06 	call	0xdca	; 0xdca <_bluetooth_enter_command_mode>
    15a6:	88 23       	and	r24, r24
    15a8:	c9 f0       	breq	.+50     	; 0x15dc <_atmega_initialize+0x132>
				{	
				//_yellowled_green_on();
					if (_bluetooth_set_baud_rate(ATMEGA_BAUD_38400))
    15aa:	8c e0       	ldi	r24, 0x0C	; 12
    15ac:	0e 94 c6 07 	call	0xf8c	; 0xf8c <_bluetooth_set_baud_rate>
    15b0:	88 23       	and	r24, r24
    15b2:	a1 f0       	breq	.+40     	; 0x15dc <_atmega_initialize+0x132>
					{
						_bluetooth_reset();	
    15b4:	0e 94 b4 07 	call	0xf68	; 0xf68 <_bluetooth_reset>
	
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
    15b8:	10 92 c5 00 	sts	0x00C5, r1
        UBRR0L = (unsigned char)baud;
    15bc:	8c e0       	ldi	r24, 0x0C	; 12
    15be:	80 93 c4 00 	sts	0x00C4, r24
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    15c2:	f0 92 c1 00 	sts	0x00C1, r15
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    15c6:	00 93 c2 00 	sts	0x00C2, r16
	
*/
void _yellowled_turn_off(void)
{

	sbi(DDRC,OUT_LED_YE_PC2);
    15ca:	3a 9a       	sbi	0x07, 2	; 7
	cbi(PORTC,OUT_LED_YE_PC2);
    15cc:	42 98       	cbi	0x08, 2	; 8
	cbi(DDRC,OUT_LED_YE_PC2);	
    15ce:	3a 98       	cbi	0x07, 2	; 7
	
	// Set the status of the yellow led to false
	cbi(wocket_status, BIT3_YELLOWLED_STATUS);
    15d0:	80 91 23 01 	lds	r24, 0x0123
    15d4:	87 7f       	andi	r24, 0xF7	; 247
    15d6:	80 93 23 01 	sts	0x0123, r24
    15da:	04 c0       	rjmp	.+8      	; 0x15e4 <_atmega_initialize+0x13a>
		
		// To run at 115K, we need to set the OSCCAL as follows, the value was
		// determined experimentally by trying different values	
		for (unsigned char i=0x50;(i<255);i++){
			OSCCAL= i;
			for (int j=0;(j<10);j++)
    15dc:	21 96       	adiw	r28, 0x01	; 1
    15de:	ca 30       	cpi	r28, 0x0A	; 10
    15e0:	d1 05       	cpc	r29, r1
    15e2:	b9 f6       	brne	.-82     	; 0x1592 <_atmega_initialize+0xe8>
	}else{

		
		// To run at 115K, we need to set the OSCCAL as follows, the value was
		// determined experimentally by trying different values	
		for (unsigned char i=0x50;(i<255);i++){
    15e4:	1f 5f       	subi	r17, 0xFF	; 255
    15e6:	1f 3f       	cpi	r17, 0xFF	; 255
    15e8:	81 f6       	brne	.-96     	; 0x158a <_atmega_initialize+0xe0>
					}
				}

			}
		}
		OSCCAL= prev_osccal;	
    15ea:	d0 92 66 00 	sts	0x0066, r13
	
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
    15ee:	10 92 c5 00 	sts	0x00C5, r1
        UBRR0L = (unsigned char)baud;
    15f2:	8c e0       	ldi	r24, 0x0C	; 12
    15f4:	80 93 c4 00 	sts	0x00C4, r24
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    15f8:	88 e1       	ldi	r24, 0x18	; 24
    15fa:	80 93 c1 00 	sts	0x00C1, r24
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    15fe:	86 e0       	ldi	r24, 0x06	; 6
    1600:	80 93 c2 00 	sts	0x00C2, r24
	}

	_atmega_initialize_uart0(ATMEGA_BAUD_38400, TX_RX_UART_MODE);
	/* Set ADC for conversion */    
    //Set ADC reference to AVCC
     ADMUX |=(1 << REFS0);
    1604:	80 91 7c 00 	lds	r24, 0x007C
    1608:	80 64       	ori	r24, 0x40	; 64
    160a:	80 93 7c 00 	sts	0x007C, r24
     //Set the ADC conversion clock prescalar       
     _atmega_set_adc_clock(ADC_PRESCALAR_64);
    160e:	85 e0       	ldi	r24, 0x05	; 5
    1610:	0e 94 86 05 	call	0xb0c	; 0xb0c <_atmega_set_adc_clock>


void _atmega_adc_turn_on()
{

	sbi(ADCSRA,ADEN);
    1614:	80 91 7a 00 	lds	r24, 0x007A
    1618:	80 68       	ori	r24, 0x80	; 128
    161a:	80 93 7a 00 	sts	0x007A, r24
     //Set the ADC conversion clock prescalar       
     _atmega_set_adc_clock(ADC_PRESCALAR_64);
     _atmega_adc_turn_on();

     /* Enable Timer 2 */
     _atmega_enable_timer2(timer_prescalar);
    161e:	8c 2d       	mov	r24, r12
    1620:	0e 94 be 06 	call	0xd7c	; 0xd7c <_atmega_enable_timer2>


}
    1624:	df 91       	pop	r29
    1626:	cf 91       	pop	r28
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	ff 90       	pop	r15
    162e:	ef 90       	pop	r14
    1630:	df 90       	pop	r13
    1632:	cf 90       	pop	r12
    1634:	08 95       	ret

00001636 <_accelerometer_turn_on>:
	Description: This function turns on the accelerometer module and sets the pins properly
	
*/
void _accelerometer_turn_on(void)
{
	sbi(DDRB,OUT_ACCEL_SEL1_PB0);	
    1636:	20 9a       	sbi	0x04, 0	; 4
	sbi(DDRB,OUT_ACCEL_SEL2_PB1);
    1638:	21 9a       	sbi	0x04, 1	; 4
	sbi(DDRB,OUT_ACCEL_SLEEP_N_PB3);
    163a:	23 9a       	sbi	0x04, 3	; 4
	sbi(PORTB,OUT_ACCEL_SLEEP_N_PB3);	 
    163c:	2b 9a       	sbi	0x05, 3	; 5
	 			
	// Set the status of the accelerometer to true
	sbi(wocket_status, BIT1_ACCELEROMETER_STATUS);
    163e:	80 91 23 01 	lds	r24, 0x0123
    1642:	82 60       	ori	r24, 0x02	; 2
    1644:	80 93 23 01 	sts	0x0123, r24
}
    1648:	08 95       	ret

0000164a <_accelerometer_turn_off>:
	Description: This function turns off the accelerometer module and sets the pins as inputs to reduce power consumption
	
*/
void _accelerometer_turn_off(void)
{
	 _accelerometer_set_sensitivity(_1_5G);
    164a:	80 e0       	ldi	r24, 0x00	; 0
    164c:	0e 94 42 0a 	call	0x1484	; 0x1484 <_accelerometer_set_sensitivity>
	 cbi(DDRB,OUT_ACCEL_SEL1_PB0);	
    1650:	20 98       	cbi	0x04, 0	; 4
	 cbi(DDRB,OUT_ACCEL_SEL2_PB1);
    1652:	21 98       	cbi	0x04, 1	; 4
	 sbi(DDRB,OUT_ACCEL_SLEEP_N_PB3); //sleep pin in output mode
    1654:	23 9a       	sbi	0x04, 3	; 4
	 cbi(PORTB,OUT_ACCEL_SLEEP_N_PB3); //clear the pin	 
    1656:	2b 98       	cbi	0x05, 3	; 5
	 
	 // Set the status of the accelerometer to false
	 cbi(wocket_status, BIT1_ACCELEROMETER_STATUS);
    1658:	80 91 23 01 	lds	r24, 0x0123
    165c:	8d 7f       	andi	r24, 0xFD	; 253
    165e:	80 93 23 01 	sts	0x0123, r24
}
    1662:	08 95       	ret

00001664 <_atmega_finalize>:
	Description: This function shuts down all peripherals and makes sure that the device is in its lowest power state
	
*/
void _atmega_finalize(void)
{
	cli();
    1664:	f8 94       	cli
	
*/
void _bluetooth_turn_off(void)
{
	// Set the direction of TX, RESET and switch pins as input
	cbi(DDRD,OUT_BT_TXD_PD1);
    1666:	51 98       	cbi	0x0a, 1	; 10
	cbi(DDRD,OUT_BT_RESET_N_PD2);
    1668:	52 98       	cbi	0x0a, 2	; 10
	cbi(DDRB,OUT_BT_SW_N_PB4);		 
    166a:	24 98       	cbi	0x04, 4	; 4

	// Set the status of bluetooth to false
	cbi(wocket_status, BIT0_BLUETOOTH_STATUS);
    166c:	80 91 23 01 	lds	r24, 0x0123
    1670:	8e 7f       	andi	r24, 0xFE	; 254
    1672:	80 93 23 01 	sts	0x0123, r24
*/
void _atmega_finalize(void)
{
	cli();
	_bluetooth_turn_off();
	_accelerometer_turn_off();
    1676:	0e 94 25 0b 	call	0x164a	; 0x164a <_accelerometer_turn_off>
	
*/

void _greenled_turn_off(void)
{
	sbi(DDRC,OUT_LED_GN_PC1);
    167a:	39 9a       	sbi	0x07, 1	; 7
	cbi(PORTC,OUT_LED_GN_PC1);
    167c:	41 98       	cbi	0x08, 1	; 8
	cbi(DDRC,OUT_LED_GN_PC1);
    167e:	39 98       	cbi	0x07, 1	; 7
	
*/
void _yellowled_turn_off(void)
{

	sbi(DDRC,OUT_LED_YE_PC2);
    1680:	3a 9a       	sbi	0x07, 2	; 7
	cbi(PORTC,OUT_LED_YE_PC2);
    1682:	42 98       	cbi	0x08, 2	; 8
	cbi(DDRC,OUT_LED_YE_PC2);	
    1684:	3a 98       	cbi	0x07, 2	; 7
	
	// Set the status of the yellow led to false
	cbi(wocket_status, BIT3_YELLOWLED_STATUS);
    1686:	80 91 23 01 	lds	r24, 0x0123
    168a:	83 7f       	andi	r24, 0xF3	; 243
    168c:	80 93 23 01 	sts	0x0123, r24
	_accelerometer_turn_off();
	_greenled_turn_off();
	_yellowled_turn_off();

	//Set all ports as inputs
	DDRA=0x00;
    1690:	11 b8       	out	0x01, r1	; 1
	DDRB=0x00;
    1692:	14 b8       	out	0x04, r1	; 4
	DDRC=0x00;
    1694:	17 b8       	out	0x07, r1	; 7
	DDRD=0x00;
    1696:	1a b8       	out	0x0a, r1	; 10

	PORTA=0x00;
    1698:	12 b8       	out	0x02, r1	; 2
	PORTB=0x00;
    169a:	15 b8       	out	0x05, r1	; 5
	PORTC=0x00;
    169c:	18 b8       	out	0x08, r1	; 8
	PORTD=0x00;
    169e:	1b b8       	out	0x0b, r1	; 11
	
*/
void _atmega_disable_timer2(void)
{	
	//disable timer interrupt
	TIMSK2=0;
    16a0:	10 92 70 00 	sts	0x0070, r1
	// reset counter unit
	TCCR2B=0;
    16a4:	10 92 b1 00 	sts	0x00B1, r1

	// Disable timer
	_atmega_disable_timer2();

	//Disable watchdog
	wdt_disable();
    16a8:	88 e1       	ldi	r24, 0x18	; 24
    16aa:	0f b6       	in	r0, 0x3f	; 63
    16ac:	f8 94       	cli
    16ae:	80 93 60 00 	sts	0x0060, r24
    16b2:	10 92 60 00 	sts	0x0060, r1
    16b6:	0f be       	out	0x3f, r0	; 63
}


void _atmega_adc_turn_off()
{
	cbi(ADCSRA,ADEN);
    16b8:	ea e7       	ldi	r30, 0x7A	; 122
    16ba:	f0 e0       	ldi	r31, 0x00	; 0
    16bc:	80 81       	ld	r24, Z
    16be:	8f 77       	andi	r24, 0x7F	; 127
    16c0:	80 83       	st	Z, r24
	//Disable ADC Conversion
	_atmega_adc_turn_off();


	// Disable pull-ups
  	MCUCR |= (1u << PUD); 
    16c2:	85 b7       	in	r24, 0x35	; 53
    16c4:	80 61       	ori	r24, 0x10	; 16
    16c6:	85 bf       	out	0x35, r24	; 53
	// Disable Analog comparitor
  	ACSR &= ~(1<<ACIE);   // Disable analog comparator interrupt
    16c8:	80 b7       	in	r24, 0x30	; 48
    16ca:	87 7f       	andi	r24, 0xF7	; 247
    16cc:	80 bf       	out	0x30, r24	; 48
  	ACSR |= (1<<ACD);     // Disable analog comparitor 
    16ce:	80 b7       	in	r24, 0x30	; 48
    16d0:	80 68       	ori	r24, 0x80	; 128
    16d2:	80 bf       	out	0x30, r24	; 48
	// Power Reduction Register, everything off;
  	PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTWI)); 
    16d4:	e4 e6       	ldi	r30, 0x64	; 100
    16d6:	f0 e0       	ldi	r31, 0x00	; 0
    16d8:	80 81       	ld	r24, Z
    16da:	8d 6a       	ori	r24, 0xAD	; 173
    16dc:	80 83       	st	Z, r24

	//Power down the MCU

	sleep_enable();
    16de:	83 b7       	in	r24, 0x33	; 51
    16e0:	81 60       	ori	r24, 0x01	; 1
    16e2:	83 bf       	out	0x33, r24	; 51
    sleep_bod_disable();
    16e4:	85 b7       	in	r24, 0x35	; 53
    16e6:	80 66       	ori	r24, 0x60	; 96
    16e8:	85 bf       	out	0x35, r24	; 53
    16ea:	8f 7d       	andi	r24, 0xDF	; 223
    16ec:	85 bf       	out	0x35, r24	; 53
    sei();	
    16ee:	78 94       	sei
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    16f0:	83 b7       	in	r24, 0x33	; 51
    16f2:	81 7f       	andi	r24, 0xF1	; 241
    16f4:	84 60       	ori	r24, 0x04	; 4
    16f6:	83 bf       	out	0x33, r24	; 51
	sleep_cpu();
    16f8:	88 95       	sleep
    sleep_disable();
    16fa:	83 b7       	in	r24, 0x33	; 51
    16fc:	8e 7f       	andi	r24, 0xFE	; 254
    16fe:	83 bf       	out	0x33, r24	; 51

}
    1700:	08 95       	ret

00001702 <_is_accelerometer_on>:
	Description: Tests if the accelerometer status bit is on
	
*/

unsigned char _is_accelerometer_on(void)
{
    1702:	80 91 23 01 	lds	r24, 0x0123
    1706:	86 95       	lsr	r24
	return ((wocket_status>>BIT1_ACCELEROMETER_STATUS) & 0x01);
}
    1708:	81 70       	andi	r24, 0x01	; 1
    170a:	08 95       	ret

0000170c <_greenled_turn_on>:
	
*/

void _greenled_turn_on(void)
{
	sbi(DDRC,OUT_LED_GN_PC1);
    170c:	39 9a       	sbi	0x07, 1	; 7
	sbi(PORTC,OUT_LED_GN_PC1);
    170e:	41 9a       	sbi	0x08, 1	; 8
	
	// Set the status of the green led to true
	sbi(wocket_status, BIT2_GREENLED_STATUS); 
    1710:	80 91 23 01 	lds	r24, 0x0123
    1714:	84 60       	ori	r24, 0x04	; 4
    1716:	80 93 23 01 	sts	0x0123, r24
}
    171a:	08 95       	ret

0000171c <_greenled_turn_off>:
	
*/

void _greenled_turn_off(void)
{
	sbi(DDRC,OUT_LED_GN_PC1);
    171c:	39 9a       	sbi	0x07, 1	; 7
	cbi(PORTC,OUT_LED_GN_PC1);
    171e:	41 98       	cbi	0x08, 1	; 8
	cbi(DDRC,OUT_LED_GN_PC1);
    1720:	39 98       	cbi	0x07, 1	; 7
	
	// Set the status of the green led to false
	cbi(wocket_status, BIT2_GREENLED_STATUS);
    1722:	80 91 23 01 	lds	r24, 0x0123
    1726:	8b 7f       	andi	r24, 0xFB	; 251
    1728:	80 93 23 01 	sts	0x0123, r24

}
    172c:	08 95       	ret

0000172e <_is_greenled_on>:
	
	Description: Tests if the green led is on
	
*/
unsigned char _is_greenled_on(void)
{
    172e:	80 91 23 01 	lds	r24, 0x0123
    1732:	86 95       	lsr	r24
    1734:	86 95       	lsr	r24
	return ((wocket_status>>BIT2_GREENLED_STATUS) & 0x01);
}
    1736:	81 70       	andi	r24, 0x01	; 1
    1738:	08 95       	ret

0000173a <_yellowled_turn_on>:
	Description: This function turns on the yellow led
	
*/
void _yellowled_turn_on(void)
{
	sbi(DDRC,OUT_LED_YE_PC2);
    173a:	3a 9a       	sbi	0x07, 2	; 7
	sbi(PORTC,OUT_LED_YE_PC2);
    173c:	42 9a       	sbi	0x08, 2	; 8

	// Set the status of the yellow led to true
	sbi(wocket_status, BIT3_YELLOWLED_STATUS);
    173e:	80 91 23 01 	lds	r24, 0x0123
    1742:	88 60       	ori	r24, 0x08	; 8
    1744:	80 93 23 01 	sts	0x0123, r24
}
    1748:	08 95       	ret

0000174a <_yellowled_turn_off>:
	
*/
void _yellowled_turn_off(void)
{

	sbi(DDRC,OUT_LED_YE_PC2);
    174a:	3a 9a       	sbi	0x07, 2	; 7
	cbi(PORTC,OUT_LED_YE_PC2);
    174c:	42 98       	cbi	0x08, 2	; 8
	cbi(DDRC,OUT_LED_YE_PC2);	
    174e:	3a 98       	cbi	0x07, 2	; 7
	
	// Set the status of the yellow led to false
	cbi(wocket_status, BIT3_YELLOWLED_STATUS);
    1750:	80 91 23 01 	lds	r24, 0x0123
    1754:	87 7f       	andi	r24, 0xF7	; 247
    1756:	80 93 23 01 	sts	0x0123, r24
}
    175a:	08 95       	ret

0000175c <_is_yellowled_on>:
	
	Description: Tests if the yellow led is on
	
*/
unsigned char _is_yellowled_on(void)
{
    175c:	80 91 23 01 	lds	r24, 0x0123
    1760:	86 95       	lsr	r24
    1762:	86 95       	lsr	r24
    1764:	86 95       	lsr	r24
	return ((wocket_status>>BIT3_YELLOWLED_STATUS) & 0x01);
}
    1766:	81 70       	andi	r24, 0x01	; 1
    1768:	08 95       	ret

0000176a <_atmega324p_init_uart0>:

void _atmega324p_init_uart0(unsigned int baud){
	/* Set baud rate */
	UBRR0H = (unsigned char)(baud>>8);
    176a:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)baud;
    176e:	80 93 c4 00 	sts	0x00C4, r24
	/* Enable receiver and transmitter */
	UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    1772:	88 e1       	ldi	r24, 0x18	; 24
    1774:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 2stop bit */
	//UCSR0C = (1<<USBS0)|(3<<UCSZ00);  //change 1 to 0 and &
	UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    1778:	86 e0       	ldi	r24, 0x06	; 6
    177a:	80 93 c2 00 	sts	0x00C2, r24
}
    177e:	08 95       	ret

00001780 <_atmega324p_init_uart1>:

void _atmega324p_init_uart1(unsigned int baud){
	/* Set baud rate */
	UBRR1H = (unsigned char)(baud>>8);
    1780:	90 93 cd 00 	sts	0x00CD, r25
	UBRR1L = (unsigned char)baud;
    1784:	80 93 cc 00 	sts	0x00CC, r24
	/* Enable receiver and transmitter */
	UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    1788:	88 e1       	ldi	r24, 0x18	; 24
    178a:	80 93 c9 00 	sts	0x00C9, r24
	/* Set frame format: 8data, 2stop bit */
	UCSR1C =(3<<UCSZ10);  //change 1 to 0 and &
    178e:	86 e0       	ldi	r24, 0x06	; 6
    1790:	80 93 ca 00 	sts	0x00CA, r24
}
    1794:	08 95       	ret

00001796 <_atmega324p_enable_free_running_adc>:



void _atmega324p_enable_free_running_adc(){
	   
   ADCSRB &= ~((1<<ADTS2) | (1<<ADTS1) | (1<<ADTS0)); //setting Free Running Mode
    1796:	eb e7       	ldi	r30, 0x7B	; 123
    1798:	f0 e0       	ldi	r31, 0x00	; 0
    179a:	80 81       	ld	r24, Z
    179c:	88 7f       	andi	r24, 0xF8	; 248
    179e:	80 83       	st	Z, r24
   ADCSRA |= (1 << ADATE);   //has to be set to 1 for ADC
    17a0:	ea e7       	ldi	r30, 0x7A	; 122
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	80 81       	ld	r24, Z
    17a6:	80 62       	ori	r24, 0x20	; 32
    17a8:	80 83       	st	Z, r24
}
    17aa:	08 95       	ret

000017ac <_atmega324p_disable_free_running_adc>:

void _atmega324p_disable_free_running_adc(){
	      
   ADCSRA &= ~(1 << ADATE);   //has to be set to 1 for ADC
    17ac:	ea e7       	ldi	r30, 0x7A	; 122
    17ae:	f0 e0       	ldi	r31, 0x00	; 0
    17b0:	80 81       	ld	r24, Z
    17b2:	8f 7d       	andi	r24, 0xDF	; 223
    17b4:	80 83       	st	Z, r24
}
    17b6:	08 95       	ret

000017b8 <_atmega324p_set_prescalar_adc>:

void _atmega324p_set_prescalar_adc(unsigned char prescalar){
	if (prescalar==PRESCALAR_2){
    17b8:	88 23       	and	r24, r24
    17ba:	21 f4       	brne	.+8      	; 0x17c4 <_atmega324p_set_prescalar_adc+0xc>
		ADCSRA &= ~((1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0));
    17bc:	80 91 7a 00 	lds	r24, 0x007A
    17c0:	88 7f       	andi	r24, 0xF8	; 248
    17c2:	36 c0       	rjmp	.+108    	; 0x1830 <_atmega324p_set_prescalar_adc+0x78>
	}else if (prescalar==PRESCALAR_4){
    17c4:	81 30       	cpi	r24, 0x01	; 1
    17c6:	49 f4       	brne	.+18     	; 0x17da <_atmega324p_set_prescalar_adc+0x22>
		ADCSRA &= ~((1 << ADPS2) | (1 << ADPS0));
    17c8:	80 91 7a 00 	lds	r24, 0x007A
    17cc:	8a 7f       	andi	r24, 0xFA	; 250
    17ce:	80 93 7a 00 	sts	0x007A, r24
		ADCSRA |= (1 << ADPS1);
    17d2:	80 91 7a 00 	lds	r24, 0x007A
    17d6:	82 60       	ori	r24, 0x02	; 2
    17d8:	2b c0       	rjmp	.+86     	; 0x1830 <_atmega324p_set_prescalar_adc+0x78>
	}else if (prescalar==PRESCALAR_8){
    17da:	82 30       	cpi	r24, 0x02	; 2
    17dc:	49 f4       	brne	.+18     	; 0x17f0 <_atmega324p_set_prescalar_adc+0x38>
		ADCSRA &= ~(1 << ADPS2);
    17de:	80 91 7a 00 	lds	r24, 0x007A
    17e2:	8b 7f       	andi	r24, 0xFB	; 251
    17e4:	80 93 7a 00 	sts	0x007A, r24
		ADCSRA |= ((1 << ADPS1) |(1 << ADPS0)) ;
    17e8:	80 91 7a 00 	lds	r24, 0x007A
    17ec:	83 60       	ori	r24, 0x03	; 3
    17ee:	20 c0       	rjmp	.+64     	; 0x1830 <_atmega324p_set_prescalar_adc+0x78>
	}else if (prescalar==PRESCALAR_16){
    17f0:	83 30       	cpi	r24, 0x03	; 3
    17f2:	49 f4       	brne	.+18     	; 0x1806 <_atmega324p_set_prescalar_adc+0x4e>
		ADCSRA &= ~((1 << ADPS1) |(1 << ADPS0));
    17f4:	80 91 7a 00 	lds	r24, 0x007A
    17f8:	8c 7f       	andi	r24, 0xFC	; 252
    17fa:	80 93 7a 00 	sts	0x007A, r24
		ADCSRA |= (1 << ADPS2);
    17fe:	80 91 7a 00 	lds	r24, 0x007A
    1802:	84 60       	ori	r24, 0x04	; 4
    1804:	15 c0       	rjmp	.+42     	; 0x1830 <_atmega324p_set_prescalar_adc+0x78>
	}else if (prescalar==PRESCALAR_32){
    1806:	84 30       	cpi	r24, 0x04	; 4
    1808:	49 f4       	brne	.+18     	; 0x181c <_atmega324p_set_prescalar_adc+0x64>
		ADCSRA &= ~(1 << ADPS1);
    180a:	80 91 7a 00 	lds	r24, 0x007A
    180e:	8d 7f       	andi	r24, 0xFD	; 253
    1810:	80 93 7a 00 	sts	0x007A, r24
		ADCSRA |= ((1 << ADPS2)|(1 << ADPS0));
    1814:	80 91 7a 00 	lds	r24, 0x007A
    1818:	85 60       	ori	r24, 0x05	; 5
    181a:	0a c0       	rjmp	.+20     	; 0x1830 <_atmega324p_set_prescalar_adc+0x78>
	}else if (prescalar==PRESCALAR_64){
    181c:	85 30       	cpi	r24, 0x05	; 5
    181e:	59 f4       	brne	.+22     	; 0x1836 <_atmega324p_set_prescalar_adc+0x7e>
		ADCSRA &= ~(1 << ADPS0);
    1820:	80 91 7a 00 	lds	r24, 0x007A
    1824:	8e 7f       	andi	r24, 0xFE	; 254
    1826:	80 93 7a 00 	sts	0x007A, r24
		ADCSRA |= ((1 << ADPS2)|(1 << ADPS1));
    182a:	80 91 7a 00 	lds	r24, 0x007A
    182e:	86 60       	ori	r24, 0x06	; 6
    1830:	80 93 7a 00 	sts	0x007A, r24
    1834:	08 95       	ret
	}else if (prescalar==PRESCALAR_128){		
    1836:	86 30       	cpi	r24, 0x06	; 6
    1838:	29 f4       	brne	.+10     	; 0x1844 <_atmega324p_set_prescalar_adc+0x8c>
		ADCSRA |= ((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
    183a:	80 91 7a 00 	lds	r24, 0x007A
    183e:	87 60       	ori	r24, 0x07	; 7
    1840:	80 93 7a 00 	sts	0x007A, r24
    1844:	08 95       	ret

00001846 <_atmega324p_set_reference_adc>:
	}
}

//To do : add support to other than the internal
void _atmega324p_set_reference_adc(){
	ADMUX |=(1 << REFS0); // Set ADC reference to AVCC
    1846:	ec e7       	ldi	r30, 0x7C	; 124
    1848:	f0 e0       	ldi	r31, 0x00	; 0
    184a:	80 81       	ld	r24, Z
    184c:	80 64       	ori	r24, 0x40	; 64
    184e:	80 83       	st	Z, r24
}
    1850:	08 95       	ret

00001852 <_atmega324p_enable_adc>:

void _atmega324p_enable_adc(){

	sbi(ADCSRA,ADEN);// power up
    1852:	ea e7       	ldi	r30, 0x7A	; 122
    1854:	f0 e0       	ldi	r31, 0x00	; 0
    1856:	80 81       	ld	r24, Z
    1858:	80 68       	ori	r24, 0x80	; 128
    185a:	80 83       	st	Z, r24

	//both the following are needed to allow ADIF to be set when a conversion completes
	//sbi(ADCSRA,ADIE);//enable ADC conversion interrupts  
	//sei(); //sets the I bit in the SREG 
}
    185c:	08 95       	ret

0000185e <_atmega324p_disable_adc>:

void _atmega324p_disable_adc(){
	cbi(ADCSRA,ADEN);// power down
    185e:	ea e7       	ldi	r30, 0x7A	; 122
    1860:	f0 e0       	ldi	r31, 0x00	; 0
    1862:	80 81       	ld	r24, Z
    1864:	8f 77       	andi	r24, 0x7F	; 127
    1866:	80 83       	st	Z, r24
	//cbi(ADCSRA,ADIE);//disable interrupts
}
    1868:	08 95       	ret

0000186a <_atmega324p_start_adc>:

void _atmega324p_start_adc(){
	sbi(ADCSRA, ADIF);   // clear hardware "conversion complete" flag 
    186a:	ea e7       	ldi	r30, 0x7A	; 122
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	80 81       	ld	r24, Z
    1870:	80 61       	ori	r24, 0x10	; 16
    1872:	80 83       	st	Z, r24
	sbi(ADCSRA,ADSC);
    1874:	80 81       	ld	r24, Z
    1876:	80 64       	ori	r24, 0x40	; 64
    1878:	80 83       	st	Z, r24
}
    187a:	08 95       	ret

0000187c <_atmega324p_is_complete_adc>:

//ADSC is 1 while converting, 0 when it is done.
unsigned char _atmega324p_is_complete_adc(){
	return bit_is_set(ADCSRA, ADSC);
    187c:	80 91 7a 00 	lds	r24, 0x007A
}
    1880:	80 74       	andi	r24, 0x40	; 64
    1882:	08 95       	ret

00001884 <_atmega324p_set_channel_adc>:

void _atmega324p_set_channel_adc(unsigned char channel){
	if (channel==ADC0){
    1884:	88 23       	and	r24, r24
    1886:	21 f4       	brne	.+8      	; 0x1890 <_atmega324p_set_channel_adc+0xc>
		cbi(ADMUX,0);
    1888:	80 91 7c 00 	lds	r24, 0x007C
    188c:	8e 7f       	andi	r24, 0xFE	; 254
    188e:	05 c0       	rjmp	.+10     	; 0x189a <_atmega324p_set_channel_adc+0x16>
		cbi(ADMUX,1);
		cbi(ADMUX,2);
		cbi(ADMUX,3);
		cbi(ADMUX,4);
	}
	else if (channel==ADC1){
    1890:	81 30       	cpi	r24, 0x01	; 1
    1892:	71 f4       	brne	.+28     	; 0x18b0 <_atmega324p_set_channel_adc+0x2c>
		sbi(ADMUX,0);
    1894:	80 91 7c 00 	lds	r24, 0x007C
    1898:	81 60       	ori	r24, 0x01	; 1
    189a:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,1);
    189e:	80 91 7c 00 	lds	r24, 0x007C
    18a2:	8d 7f       	andi	r24, 0xFD	; 253
    18a4:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,2);
    18a8:	80 91 7c 00 	lds	r24, 0x007C
    18ac:	8b 7f       	andi	r24, 0xFB	; 251
    18ae:	2b c0       	rjmp	.+86     	; 0x1906 <_atmega324p_set_channel_adc+0x82>
		cbi(ADMUX,3);
		cbi(ADMUX,4);
	}else if (channel==ADC2){
    18b0:	82 30       	cpi	r24, 0x02	; 2
    18b2:	21 f4       	brne	.+8      	; 0x18bc <_atmega324p_set_channel_adc+0x38>
		cbi(ADMUX,0);
    18b4:	80 91 7c 00 	lds	r24, 0x007C
    18b8:	8e 7f       	andi	r24, 0xFE	; 254
    18ba:	05 c0       	rjmp	.+10     	; 0x18c6 <_atmega324p_set_channel_adc+0x42>
		sbi(ADMUX,1);
		cbi(ADMUX,2);
		cbi(ADMUX,3);
		cbi(ADMUX,4);
	}else if (channel==ADC3){
    18bc:	83 30       	cpi	r24, 0x03	; 3
    18be:	49 f4       	brne	.+18     	; 0x18d2 <_atmega324p_set_channel_adc+0x4e>
		sbi(ADMUX,0);
    18c0:	80 91 7c 00 	lds	r24, 0x007C
    18c4:	81 60       	ori	r24, 0x01	; 1
    18c6:	80 93 7c 00 	sts	0x007C, r24
		sbi(ADMUX,1);
    18ca:	80 91 7c 00 	lds	r24, 0x007C
    18ce:	82 60       	ori	r24, 0x02	; 2
    18d0:	e9 cf       	rjmp	.-46     	; 0x18a4 <_atmega324p_set_channel_adc+0x20>
		cbi(ADMUX,2);
		cbi(ADMUX,3);
		cbi(ADMUX,4);
	}else if (channel==ADC4){
    18d2:	84 30       	cpi	r24, 0x04	; 4
    18d4:	49 f4       	brne	.+18     	; 0x18e8 <_atmega324p_set_channel_adc+0x64>
		cbi(ADMUX,0);
    18d6:	80 91 7c 00 	lds	r24, 0x007C
    18da:	8e 7f       	andi	r24, 0xFE	; 254
    18dc:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,1);
    18e0:	80 91 7c 00 	lds	r24, 0x007C
    18e4:	8d 7f       	andi	r24, 0xFD	; 253
    18e6:	0a c0       	rjmp	.+20     	; 0x18fc <_atmega324p_set_channel_adc+0x78>
		sbi(ADMUX,2);
		cbi(ADMUX,3);
		cbi(ADMUX,4);
	}else if (channel==ADC6)
    18e8:	86 30       	cpi	r24, 0x06	; 6
    18ea:	d1 f4       	brne	.+52     	; 0x1920 <_atmega324p_set_channel_adc+0x9c>
	{
		cbi(ADMUX,0);
    18ec:	80 91 7c 00 	lds	r24, 0x007C
    18f0:	8e 7f       	andi	r24, 0xFE	; 254
    18f2:	80 93 7c 00 	sts	0x007C, r24
		sbi(ADMUX,1);
    18f6:	80 91 7c 00 	lds	r24, 0x007C
    18fa:	82 60       	ori	r24, 0x02	; 2
    18fc:	80 93 7c 00 	sts	0x007C, r24
		sbi(ADMUX,2);
    1900:	80 91 7c 00 	lds	r24, 0x007C
    1904:	84 60       	ori	r24, 0x04	; 4
    1906:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,3);
    190a:	80 91 7c 00 	lds	r24, 0x007C
    190e:	87 7f       	andi	r24, 0xF7	; 247
    1910:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,4);
    1914:	80 91 7c 00 	lds	r24, 0x007C
    1918:	8f 7e       	andi	r24, 0xEF	; 239
    191a:	80 93 7c 00 	sts	0x007C, r24
    191e:	08 95       	ret
	}
	else if (channel==ADC7)
    1920:	87 30       	cpi	r24, 0x07	; 7
    1922:	c9 f4       	brne	.+50     	; 0x1956 <_atmega324p_set_channel_adc+0xd2>
	{
		sbi(ADMUX,0);
    1924:	80 91 7c 00 	lds	r24, 0x007C
    1928:	81 60       	ori	r24, 0x01	; 1
    192a:	80 93 7c 00 	sts	0x007C, r24
		sbi(ADMUX,1);
    192e:	80 91 7c 00 	lds	r24, 0x007C
    1932:	82 60       	ori	r24, 0x02	; 2
    1934:	80 93 7c 00 	sts	0x007C, r24
		sbi(ADMUX,2);
    1938:	80 91 7c 00 	lds	r24, 0x007C
    193c:	84 60       	ori	r24, 0x04	; 4
    193e:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,3);
    1942:	80 91 7c 00 	lds	r24, 0x007C
    1946:	87 7f       	andi	r24, 0xF7	; 247
    1948:	80 93 7c 00 	sts	0x007C, r24
		cbi(ADMUX,4);
    194c:	80 91 7c 00 	lds	r24, 0x007C
    1950:	8f 7e       	andi	r24, 0xEF	; 239
    1952:	80 93 7c 00 	sts	0x007C, r24
    1956:	08 95       	ret

00001958 <_atmega324p_a2dConvert10bit>:
	}*/
}

unsigned short _atmega324p_a2dConvert10bit(unsigned char channel){
	//select channel
	_atmega324p_set_channel_adc(channel);
    1958:	0e 94 42 0c 	call	0x1884	; 0x1884 <_atmega324p_set_channel_adc>
	cbi(ADCSRA,ADEN);// power down
	//cbi(ADCSRA,ADIE);//disable interrupts
}

void _atmega324p_start_adc(){
	sbi(ADCSRA, ADIF);   // clear hardware "conversion complete" flag 
    195c:	80 91 7a 00 	lds	r24, 0x007A
    1960:	80 61       	ori	r24, 0x10	; 16
    1962:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSRA,ADSC);
    1966:	80 91 7a 00 	lds	r24, 0x007A
    196a:	80 64       	ori	r24, 0x40	; 64
    196c:	80 93 7a 00 	sts	0x007A, r24
}

//ADSC is 1 while converting, 0 when it is done.
unsigned char _atmega324p_is_complete_adc(){
	return bit_is_set(ADCSRA, ADSC);
    1970:	80 91 7a 00 	lds	r24, 0x007A

unsigned short _atmega324p_a2dConvert10bit(unsigned char channel){
	//select channel
	_atmega324p_set_channel_adc(channel);
	_atmega324p_start_adc();
	while(_atmega324p_is_complete_adc()); 
    1974:	86 fd       	sbrc	r24, 6
    1976:	fc cf       	rjmp	.-8      	; 0x1970 <_atmega324p_a2dConvert10bit+0x18>
	return ((ADCL)|((ADCH)<<8));
    1978:	20 91 78 00 	lds	r18, 0x0078
    197c:	40 91 79 00 	lds	r20, 0x0079
    1980:	94 2f       	mov	r25, r20
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	30 e0       	ldi	r19, 0x00	; 0
    1986:	28 2b       	or	r18, r24
    1988:	39 2b       	or	r19, r25
}
    198a:	c9 01       	movw	r24, r18
    198c:	08 95       	ret

0000198e <_atmega324p_init_adc>:
void _atmega324p_init_adc(){

	//set the directional pins for the A/D converter
	cbi(DDRA,X_PIN);
    198e:	0b 98       	cbi	0x01, 3	; 1
	cbi(DDRA,Y_PIN);
    1990:	0a 98       	cbi	0x01, 2	; 1
	cbi(DDRA,Z_PIN);
    1992:	09 98       	cbi	0x01, 1	; 1
	cbi(DDRA,6);
    1994:	0e 98       	cbi	0x01, 6	; 1
	}
}

//To do : add support to other than the internal
void _atmega324p_set_reference_adc(){
	ADMUX |=(1 << REFS0); // Set ADC reference to AVCC
    1996:	ec e7       	ldi	r30, 0x7C	; 124
    1998:	f0 e0       	ldi	r31, 0x00	; 0
    199a:	80 81       	ld	r24, Z
    199c:	80 64       	ori	r24, 0x40	; 64
    199e:	80 83       	st	Z, r24
   // No MUX values needed to be changed to use ADC0
   //ADCSRA |= (1 << ADATE);   //has to be set to 1 for ADC
   //ADCSRB &= (0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0); //setting Free Running Mode
	
	//_atmega324p_enable_free_running_adc();
	_atmega324p_set_prescalar_adc(PRESCALAR_64);
    19a0:	85 e0       	ldi	r24, 0x05	; 5
    19a2:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <_atmega324p_set_prescalar_adc>
	ADMUX |=(1 << REFS0); // Set ADC reference to AVCC
}

void _atmega324p_enable_adc(){

	sbi(ADCSRA,ADEN);// power up
    19a6:	ea e7       	ldi	r30, 0x7A	; 122
    19a8:	f0 e0       	ldi	r31, 0x00	; 0
    19aa:	80 81       	ld	r24, Z
    19ac:	80 68       	ori	r24, 0x80	; 128
    19ae:	80 83       	st	Z, r24
   //Set prescalar to 64 -125 KHZ rate @ 8MHz
	_atmega324p_enable_adc();


	//set LED PINs
	sbi(DDRC,GREEN_LED);
    19b0:	39 9a       	sbi	0x07, 1	; 7
	sbi(DDRC,YELLOW_LED);
    19b2:	3a 9a       	sbi	0x07, 2	; 7
  // ADCSRA |= (1 << ADSC);  // Start A2D Conversions
  //_atmega324p_start_adc();

}
    19b4:	08 95       	ret

000019b6 <_atmega324p_green_led_on>:

void _atmega324p_green_led_on(){
	sbi(PORTC,GREEN_LED);
    19b6:	41 9a       	sbi	0x08, 1	; 8
}
    19b8:	08 95       	ret

000019ba <_atmega324p_green_led_off>:

void _atmega324p_green_led_off(){
	cbi(PORTC,GREEN_LED);
    19ba:	41 98       	cbi	0x08, 1	; 8
}
    19bc:	08 95       	ret

000019be <_atmega324p_yellow_led_on>:


void _atmega324p_yellow_led_on(){
	sbi(PORTC,YELLOW_LED);
    19be:	42 9a       	sbi	0x08, 2	; 8
}
    19c0:	08 95       	ret

000019c2 <_atmega324p_yellow_led_off>:

void _atmega324p_yellow_led_off(){
	cbi(PORTC,YELLOW_LED);
    19c2:	42 98       	cbi	0x08, 2	; 8
}
    19c4:	08 95       	ret

000019c6 <_atmega324p_powerdown>:


void _atmega324p_powerdown(){
SMCR = 0x05;
    19c6:	85 e0       	ldi	r24, 0x05	; 5
    19c8:	83 bf       	out	0x33, r24	; 51
}
    19ca:	08 95       	ret

000019cc <_atmega324p_disable_JTAG>:
//by default the interface is enabled to disable it JTD has to be written logic 1
	// 2 times in 4 cycles.
{
	unsigned char sreg;

	sreg = SREG;
    19cc:	8f b7       	in	r24, 0x3f	; 63
	cli();
    19ce:	f8 94       	cli
	MCUCR |= ( 1 <<JTD );
    19d0:	95 b7       	in	r25, 0x35	; 53
    19d2:	90 68       	ori	r25, 0x80	; 128
    19d4:	95 bf       	out	0x35, r25	; 53
	MCUCR |= ( 1 <<JTD );
    19d6:	95 b7       	in	r25, 0x35	; 53
    19d8:	90 68       	ori	r25, 0x80	; 128
    19da:	95 bf       	out	0x35, r25	; 53
	SREG = sreg;
    19dc:	8f bf       	out	0x3f, r24	; 63
}
    19de:	08 95       	ret

000019e0 <ReceiveByte>:


unsigned char ReceiveByte(unsigned char *data)
  {
    19e0:	fc 01       	movw	r30, r24
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
    19e2:	80 91 c0 00 	lds	r24, 0x00C0
    19e6:	87 fd       	sbrc	r24, 7
    19e8:	0a c0       	rjmp	.+20     	; 0x19fe <ReceiveByte+0x1e>
    19ea:	80 ed       	ldi	r24, 0xD0	; 208
    19ec:	97 e0       	ldi	r25, 0x07	; 7
    19ee:	01 97       	sbiw	r24, 0x01	; 1
    19f0:	f1 f7       	brne	.-4      	; 0x19ee <ReceiveByte+0xe>
    19f2:	80 91 c0 00 	lds	r24, 0x00C0
    19f6:	87 fd       	sbrc	r24, 7
    19f8:	02 c0       	rjmp	.+4      	; 0x19fe <ReceiveByte+0x1e>
    19fa:	81 e0       	ldi	r24, 0x01	; 1
    19fc:	08 95       	ret
   {
   		if (count++==1) return 1; //timed out
   			_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
    19fe:	80 91 c6 00 	lds	r24, 0x00C6
    1a02:	80 83       	st	Z, r24
    1a04:	80 e0       	ldi	r24, 0x00	; 0

   return 0;/* Return success*/
  }
    1a06:	08 95       	ret

00001a08 <TransmitByte>:


void TransmitByte( unsigned char data )
{
    1a08:	98 2f       	mov	r25, r24
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1a0a:	80 91 c0 00 	lds	r24, 0x00C0
    1a0e:	85 ff       	sbrs	r24, 5
    1a10:	fc cf       	rjmp	.-8      	; 0x1a0a <TransmitByte+0x2>
  UCSR0A=UCSR0A & 0xdf;
    1a12:	80 91 c0 00 	lds	r24, 0x00C0
    1a16:	8f 7d       	andi	r24, 0xDF	; 223
    1a18:	80 93 c0 00 	sts	0x00C0, r24
  
  UDR0 =  data;  /* Start transmission   */
    1a1c:	90 93 c6 00 	sts	0x00C6, r25
   
}
    1a20:	08 95       	ret

00001a22 <_atmega324p_shutdown>:

unsigned char _atmega324p_shutdown(){

        return (0x01 & (PINA>>USER_BUTTON_PIN));
    1a22:	80 b1       	in	r24, 0x00	; 0
    1a24:	82 95       	swap	r24
    1a26:	86 95       	lsr	r24


}
    1a28:	81 70       	andi	r24, 0x01	; 1
    1a2a:	08 95       	ret

00001a2c <_atmega324p_power_down>:


void _atmega324p_power_down()
{
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    1a2c:	83 b7       	in	r24, 0x33	; 51
    1a2e:	81 7f       	andi	r24, 0xF1	; 241
    1a30:	84 60       	ori	r24, 0x04	; 4
    1a32:	83 bf       	out	0x33, r24	; 51
	sleep_enable();
    1a34:	83 b7       	in	r24, 0x33	; 51
    1a36:	81 60       	ori	r24, 0x01	; 1
    1a38:	83 bf       	out	0x33, r24	; 51
	sleep_mode();	
    1a3a:	83 b7       	in	r24, 0x33	; 51
    1a3c:	81 60       	ori	r24, 0x01	; 1
    1a3e:	83 bf       	out	0x33, r24	; 51
    1a40:	88 95       	sleep
    1a42:	83 b7       	in	r24, 0x33	; 51
    1a44:	8e 7f       	andi	r24, 0xFE	; 254
    1a46:	83 bf       	out	0x33, r24	; 51
}
    1a48:	08 95       	ret

00001a4a <_atmega324p_reset>:


void _atmega324p_reset()
{		
        cli(); //irq's off
    1a4a:	f8 94       	cli
        wdt_enable(WDTO_15MS); //wd on,15ms
    1a4c:	28 e0       	ldi	r18, 0x08	; 8
    1a4e:	88 e1       	ldi	r24, 0x18	; 24
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	0f b6       	in	r0, 0x3f	; 63
    1a54:	f8 94       	cli
    1a56:	a8 95       	wdr
    1a58:	80 93 60 00 	sts	0x0060, r24
    1a5c:	0f be       	out	0x3f, r0	; 63
    1a5e:	20 93 60 00 	sts	0x0060, r18
    1a62:	ff cf       	rjmp	.-2      	; 0x1a62 <_atmega324p_reset+0x18>

00001a64 <_atmega324p_init>:
//by default the interface is enabled to disable it JTD has to be written logic 1
	// 2 times in 4 cycles.
{
	unsigned char sreg;

	sreg = SREG;
    1a64:	3f b7       	in	r19, 0x3f	; 63
	cli();
    1a66:	f8 94       	cli
	MCUCR |= ( 1 <<JTD );
    1a68:	25 b7       	in	r18, 0x35	; 53
    1a6a:	20 68       	ori	r18, 0x80	; 128
    1a6c:	25 bf       	out	0x35, r18	; 53
	MCUCR |= ( 1 <<JTD );
    1a6e:	25 b7       	in	r18, 0x35	; 53
    1a70:	20 68       	ori	r18, 0x80	; 128
    1a72:	25 bf       	out	0x35, r18	; 53
	SREG = sreg;
    1a74:	3f bf       	out	0x3f, r19	; 63
	return ((wocket_status>>BIT3_YELLOWLED_STATUS) & 0x01);
}

void _atmega324p_init_uart0(unsigned int baud){
	/* Set baud rate */
	UBRR0H = (unsigned char)(baud>>8);
    1a76:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)baud;
    1a7a:	80 93 c4 00 	sts	0x00C4, r24
	/* Enable receiver and transmitter */
	UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    1a7e:	88 e1       	ldi	r24, 0x18	; 24
    1a80:	80 93 c1 00 	sts	0x00C1, r24
	/* Set frame format: 8data, 2stop bit */
	//UCSR0C = (1<<USBS0)|(3<<UCSZ00);  //change 1 to 0 and &
	UCSR0C = (3<<UCSZ00);  //change 1 to 0 and &
    1a84:	86 e0       	ldi	r24, 0x06	; 6
    1a86:	80 93 c2 00 	sts	0x00C2, r24
	//initialize UART0, connected to the RX of the BT
	_atmega324p_init_uart0(baud);
//	_atmega324p_init_uart1(baud);

	//set the BT
	_rn41_init();
    1a8a:	0e 94 64 05 	call	0xac8	; 0xac8 <_rn41_init>

    //initialize the accelerometer settings
	_mma7260qt_init();
    1a8e:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <_mma7260qt_init>

	//initialize the digital to analog converter
	_atmega324p_init_adc();
    1a92:	0e 94 c7 0c 	call	0x198e	; 0x198e <_atmega324p_init_adc>


	//set user button as input
        cbi(DDRA,USER_BUTTON_PIN);
    1a96:	0d 98       	cbi	0x01, 5	; 1
        sbi(PINA,USER_BUTTON_PIN);
    1a98:	05 9a       	sbi	0x00, 5	; 0


	//power save mode

	SMCR |=((1<<SM0)|(1<<SM1) | (1<<SE));
    1a9a:	83 b7       	in	r24, 0x33	; 51
    1a9c:	87 60       	ori	r24, 0x07	; 7
    1a9e:	83 bf       	out	0x33, r24	; 51

	//timer setup timer/counter2

	 TCCR2B |= ((1 << CS20) |(1 << CS21) | (1 << CS22)); // Set up timer 
    1aa0:	e1 eb       	ldi	r30, 0xB1	; 177
    1aa2:	f0 e0       	ldi	r31, 0x00	; 0
    1aa4:	80 81       	ld	r24, Z
    1aa6:	87 60       	ori	r24, 0x07	; 7
    1aa8:	80 83       	st	Z, r24
	 TCNT2=154;
    1aaa:	8a e9       	ldi	r24, 0x9A	; 154
    1aac:	80 93 b2 00 	sts	0x00B2, r24
	 TIMSK2 |= (1 << TOIE2); // Enable CTC interrupt
    1ab0:	e0 e7       	ldi	r30, 0x70	; 112
    1ab2:	f0 e0       	ldi	r31, 0x00	; 0
    1ab4:	80 81       	ld	r24, Z
    1ab6:	81 60       	ori	r24, 0x01	; 1
    1ab8:	80 83       	st	Z, r24
   	 sei(); //  Enable global interrupts 
    1aba:	78 94       	sei

	
}
    1abc:	08 95       	ret

00001abe <_mma7260qt_set_sensitivity>:

/** Here we will set the direction of the different ports ***/

unsigned char _mma7260qt_set_sensitivity(unsigned char level){
  	
	if (level==_1_5G){
    1abe:	88 23       	and	r24, r24
    1ac0:	11 f4       	brne	.+4      	; 0x1ac6 <_mma7260qt_set_sensitivity+0x8>
		cbi(PORTB,GS1_PIN);
    1ac2:	28 98       	cbi	0x05, 0	; 5
    1ac4:	03 c0       	rjmp	.+6      	; 0x1acc <_mma7260qt_set_sensitivity+0xe>
		cbi(PORTB,GS2_PIN);
		return _1_5G;
	}else if (level==_2G){
    1ac6:	81 30       	cpi	r24, 0x01	; 1
    1ac8:	19 f4       	brne	.+6      	; 0x1ad0 <_mma7260qt_set_sensitivity+0x12>
		sbi(PORTB,GS1_PIN);
    1aca:	28 9a       	sbi	0x05, 0	; 5
		cbi(PORTB,GS2_PIN);
    1acc:	29 98       	cbi	0x05, 1	; 5
    1ace:	08 95       	ret
		return _2G;
	}else if (level==_4G){
    1ad0:	82 30       	cpi	r24, 0x02	; 2
    1ad2:	19 f4       	brne	.+6      	; 0x1ada <_mma7260qt_set_sensitivity+0x1c>
		sbi(PORTB,GS2_PIN);
    1ad4:	29 9a       	sbi	0x05, 1	; 5
		cbi(PORTB,GS1_PIN);
    1ad6:	28 98       	cbi	0x05, 0	; 5
    1ad8:	08 95       	ret
		return _4G;
	}else if (level==_6G){
    1ada:	83 30       	cpi	r24, 0x03	; 3
    1adc:	11 f0       	breq	.+4      	; 0x1ae2 <_mma7260qt_set_sensitivity+0x24>
    1ade:	80 e0       	ldi	r24, 0x00	; 0
    1ae0:	08 95       	ret
		sbi(PORTB,GS1_PIN);
    1ae2:	28 9a       	sbi	0x05, 0	; 5
		sbi(PORTB,GS2_PIN);
    1ae4:	29 9a       	sbi	0x05, 1	; 5
    1ae6:	83 e0       	ldi	r24, 0x03	; 3
		return _6G;
	}

	return 0;
}
    1ae8:	08 95       	ret

00001aea <_mma7260qt_wakeup>:

void _mma7260qt_wakeup(){
	sbi(PORTB,SLP_PIN);
    1aea:	2b 9a       	sbi	0x05, 3	; 5

}
    1aec:	08 95       	ret

00001aee <_mma7260qt_sleep>:

void _mma7260qt_sleep(){
	cbi(PORTB,SLP_PIN);
    1aee:	2b 98       	cbi	0x05, 3	; 5
}
    1af0:	08 95       	ret

00001af2 <_mma7260qt_is_asleep>:

unsigned char _mma7260qt_is_asleep(){

	return (0x01 & ~(PORTB>>SLP_PIN));
    1af2:	85 b1       	in	r24, 0x05	; 5
    1af4:	86 95       	lsr	r24
    1af6:	86 95       	lsr	r24
    1af8:	86 95       	lsr	r24
    1afa:	80 95       	com	r24
}
    1afc:	81 70       	andi	r24, 0x01	; 1
    1afe:	08 95       	ret

00001b00 <_mma7260qt_init>:

//by default set sensitivity to 1.5G
void _mma7260qt_init(){
	
	sbi(DDRB,GS1_PIN); //set to output
    1b00:	20 9a       	sbi	0x04, 0	; 4
	sbi(DDRB,GS2_PIN); //set to output
    1b02:	21 9a       	sbi	0x04, 1	; 4
	sbi(DDRB,SLP_PIN); //set to output
    1b04:	23 9a       	sbi	0x04, 3	; 4

	//set X,Y,Z pins to input
	cbi(DDRA, X_PIN);
    1b06:	0b 98       	cbi	0x01, 3	; 1
	cbi(DDRA, Y_PIN);
    1b08:	0a 98       	cbi	0x01, 2	; 1
	cbi(DDRA, Z_PIN);
    1b0a:	09 98       	cbi	0x01, 1	; 1

	//set other control pins to inputs --> move to seperate file later
	cbi(DDRB, VSENSE_COMP_PB);
    1b0c:	22 98       	cbi	0x04, 2	; 4
	cbi(DDRA, VSENSE_COMP_PA);
    1b0e:	08 98       	cbi	0x01, 0	; 1
	cbi(DDRA, VSENSE_BAT);
    1b10:	0c 98       	cbi	0x01, 4	; 1
	cbi(DDRA, DOCK_N);
    1b12:	0d 98       	cbi	0x01, 5	; 1

	//set default sensitivity to 1.5G
	sensitivity=_mma7260qt_set_sensitivity(_4G);	
    1b14:	82 e0       	ldi	r24, 0x02	; 2
    1b16:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <_mma7260qt_set_sensitivity>
    1b1a:	80 93 34 02 	sts	0x0234, r24

	return 0;
}

void _mma7260qt_wakeup(){
	sbi(PORTB,SLP_PIN);
    1b1e:	2b 9a       	sbi	0x05, 3	; 5
	//set default sensitivity to 1.5G
	sensitivity=_mma7260qt_set_sensitivity(_4G);	
	//_mma7260qt_sleep(); //initially asleep
	_mma7260qt_wakeup(); //initially awake
	
}
    1b20:	08 95       	ret

00001b22 <init_crc>:
#include "crc.h"


void init_crc(void){
    1b22:	20 e0       	ldi	r18, 0x00	; 0
    1b24:	30 e0       	ldi	r19, 0x00	; 0
		remainder=dividend<< (WIDTH -8);

		for (bit=8;bit>0;--bit)
		{
			if (remainder & TOPBIT)
				remainder=(remainder<<1)^ POLYNOMIAL;
    1b26:	48 ed       	ldi	r20, 0xD8	; 216
#include "crc.h"


void init_crc(void){
    1b28:	82 2f       	mov	r24, r18
    1b2a:	98 e0       	ldi	r25, 0x08	; 8
	{
		remainder=dividend<< (WIDTH -8);

		for (bit=8;bit>0;--bit)
		{
			if (remainder & TOPBIT)
    1b2c:	87 ff       	sbrs	r24, 7
    1b2e:	03 c0       	rjmp	.+6      	; 0x1b36 <init_crc+0x14>
				remainder=(remainder<<1)^ POLYNOMIAL;
    1b30:	88 0f       	add	r24, r24
    1b32:	84 27       	eor	r24, r20
    1b34:	01 c0       	rjmp	.+2      	; 0x1b38 <init_crc+0x16>
			else
				remainder=(remainder<<1);
    1b36:	88 0f       	add	r24, r24
	unsigned char bit;
	for (dividend=0;(dividend<256);++dividend)
	{
		remainder=dividend<< (WIDTH -8);

		for (bit=8;bit>0;--bit)
    1b38:	91 50       	subi	r25, 0x01	; 1
    1b3a:	c1 f7       	brne	.-16     	; 0x1b2c <init_crc+0xa>
				remainder=(remainder<<1)^ POLYNOMIAL;
			else
				remainder=(remainder<<1);
		}

		crcTable[dividend]=remainder;
    1b3c:	f9 01       	movw	r30, r18
    1b3e:	ee 5c       	subi	r30, 0xCE	; 206
    1b40:	fe 4f       	sbci	r31, 0xFE	; 254
    1b42:	80 83       	st	Z, r24

void init_crc(void){
	unsigned char remainder;
	int dividend=0;
	unsigned char bit;
	for (dividend=0;(dividend<256);++dividend)
    1b44:	2f 5f       	subi	r18, 0xFF	; 255
    1b46:	3f 4f       	sbci	r19, 0xFF	; 255
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	20 30       	cpi	r18, 0x00	; 0
    1b4c:	38 07       	cpc	r19, r24
    1b4e:	61 f7       	brne	.-40     	; 0x1b28 <init_crc+0x6>
				remainder=(remainder<<1);
		}

		crcTable[dividend]=remainder;
	}
}
    1b50:	08 95       	ret

00001b52 <crc>:

unsigned char crc(unsigned char message[],unsigned char length)
{
    1b52:	dc 01       	movw	r26, r24
    1b54:	e0 e0       	ldi	r30, 0x00	; 0
    1b56:	90 e0       	ldi	r25, 0x00	; 0
    1b58:	07 c0       	rjmp	.+14     	; 0x1b68 <crc+0x16>
	unsigned char byte=0;

	for (byte=0;(byte<length);byte++)
	{
		data=message[byte]^(remainder >> (WIDTH-8));
		remainder=crcTable[data] ^ (remainder<<8);
    1b5a:	8d 91       	ld	r24, X+
    1b5c:	e8 27       	eor	r30, r24
    1b5e:	f0 e0       	ldi	r31, 0x00	; 0
    1b60:	ee 5c       	subi	r30, 0xCE	; 206
    1b62:	fe 4f       	sbci	r31, 0xFE	; 254
    1b64:	e0 81       	ld	r30, Z
{
	unsigned char data;
	unsigned char remainder=0;
	unsigned char byte=0;

	for (byte=0;(byte<length);byte++)
    1b66:	9f 5f       	subi	r25, 0xFF	; 255
    1b68:	96 17       	cp	r25, r22
    1b6a:	b8 f3       	brcs	.-18     	; 0x1b5a <crc+0x8>
		data=message[byte]^(remainder >> (WIDTH-8));
		remainder=crcTable[data] ^ (remainder<<8);
	}

	return remainder;
}
    1b6c:	8e 2f       	mov	r24, r30
    1b6e:	08 95       	ret

00001b70 <encode>:
#include "encoder.h"

WOCKETS_UNCOMPRESSED_FRAME encode(unsigned char sensitivity,unsigned short x, unsigned short y, unsigned short z)
{
    1b70:	1f 93       	push	r17
    1b72:	df 93       	push	r29
    1b74:	cf 93       	push	r28
    1b76:	00 d0       	rcall	.+0      	; 0x1b78 <encode+0x8>
    1b78:	00 d0       	rcall	.+0      	; 0x1b7a <encode+0xa>
    1b7a:	0f 92       	push	r0
    1b7c:	cd b7       	in	r28, 0x3d	; 61
    1b7e:	de b7       	in	r29, 0x3e	; 62
    1b80:	f9 01       	movw	r30, r18
	frame.byte2 |= ((unsigned char) ((x>>1)&0x7f));
	frame.byte3 |= ((unsigned char) ((x<<6) &0x40)) | ((unsigned char) ((y>>4)&0x3f));
	frame.byte4 |= ((unsigned char) ((y<<3) &0x78)) | ((unsigned char) ((z>>7)&0x07));
	frame.byte5 |= ((unsigned char) (z&0x7f));

	return frame;
    1b82:	12 2f       	mov	r17, r18
    1b84:	1f 77       	andi	r17, 0x7F	; 127
    1b86:	ee 0f       	add	r30, r30
    1b88:	ef 2f       	mov	r30, r31
    1b8a:	ee 1f       	adc	r30, r30
    1b8c:	ff 0b       	sbc	r31, r31
    1b8e:	f1 95       	neg	r31
    1b90:	e7 70       	andi	r30, 0x07	; 7
    1b92:	94 2f       	mov	r25, r20
    1b94:	99 0f       	add	r25, r25
    1b96:	99 0f       	add	r25, r25
    1b98:	99 0f       	add	r25, r25
    1b9a:	98 77       	andi	r25, 0x78	; 120
    1b9c:	e9 2b       	or	r30, r25
    1b9e:	24 e0       	ldi	r18, 0x04	; 4
    1ba0:	56 95       	lsr	r21
    1ba2:	47 95       	ror	r20
    1ba4:	2a 95       	dec	r18
    1ba6:	e1 f7       	brne	.-8      	; 0x1ba0 <encode+0x30>
    1ba8:	4f 73       	andi	r20, 0x3F	; 63
    1baa:	96 2f       	mov	r25, r22
    1bac:	92 95       	swap	r25
    1bae:	99 0f       	add	r25, r25
    1bb0:	99 0f       	add	r25, r25
    1bb2:	90 74       	andi	r25, 0x40	; 64
    1bb4:	49 2b       	or	r20, r25
    1bb6:	db 01       	movw	r26, r22
    1bb8:	b6 95       	lsr	r27
    1bba:	a7 95       	ror	r26
    1bbc:	af 77       	andi	r26, 0x7F	; 127
    1bbe:	87 70       	andi	r24, 0x07	; 7
    1bc0:	88 0f       	add	r24, r24
    1bc2:	88 0f       	add	r24, r24
    1bc4:	80 68       	ori	r24, 0x80	; 128
    1bc6:	97 2f       	mov	r25, r23
    1bc8:	93 70       	andi	r25, 0x03	; 3
    1bca:	89 2b       	or	r24, r25
}
    1bcc:	28 2f       	mov	r18, r24
    1bce:	3a 2f       	mov	r19, r26
    1bd0:	5e 2f       	mov	r21, r30
    1bd2:	61 2f       	mov	r22, r17
    1bd4:	70 e0       	ldi	r23, 0x00	; 0
    1bd6:	80 e0       	ldi	r24, 0x00	; 0
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	0f 90       	pop	r0
    1bdc:	0f 90       	pop	r0
    1bde:	0f 90       	pop	r0
    1be0:	0f 90       	pop	r0
    1be2:	0f 90       	pop	r0
    1be4:	cf 91       	pop	r28
    1be6:	df 91       	pop	r29
    1be8:	1f 91       	pop	r17
    1bea:	08 95       	ret

00001bec <__eerd_word>:
    1bec:	df 92       	push	r13
    1bee:	ef 92       	push	r14
    1bf0:	ff 92       	push	r15
    1bf2:	0f 93       	push	r16
    1bf4:	1f 93       	push	r17
    1bf6:	7b 01       	movw	r14, r22
    1bf8:	8c 01       	movw	r16, r24
    1bfa:	fb 01       	movw	r30, r22
    1bfc:	09 95       	icall
    1bfe:	d8 2e       	mov	r13, r24
    1c00:	c8 01       	movw	r24, r16
    1c02:	01 96       	adiw	r24, 0x01	; 1
    1c04:	f7 01       	movw	r30, r14
    1c06:	09 95       	icall
    1c08:	98 2f       	mov	r25, r24
    1c0a:	8d 2d       	mov	r24, r13
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	08 95       	ret

00001c18 <__eewr_word>:
    1c18:	df 92       	push	r13
    1c1a:	ef 92       	push	r14
    1c1c:	ff 92       	push	r15
    1c1e:	0f 93       	push	r16
    1c20:	1f 93       	push	r17
    1c22:	d7 2e       	mov	r13, r23
    1c24:	7a 01       	movw	r14, r20
    1c26:	8c 01       	movw	r16, r24
    1c28:	fa 01       	movw	r30, r20
    1c2a:	09 95       	icall
    1c2c:	c8 01       	movw	r24, r16
    1c2e:	01 96       	adiw	r24, 0x01	; 1
    1c30:	6d 2d       	mov	r22, r13
    1c32:	f7 01       	movw	r30, r14
    1c34:	09 95       	icall
    1c36:	1f 91       	pop	r17
    1c38:	0f 91       	pop	r16
    1c3a:	ff 90       	pop	r15
    1c3c:	ef 90       	pop	r14
    1c3e:	df 90       	pop	r13
    1c40:	08 95       	ret

00001c42 <_exit>:
    1c42:	f8 94       	cli

00001c44 <__stop_program>:
    1c44:	ff cf       	rjmp	.-2      	; 0x1c44 <__stop_program>
