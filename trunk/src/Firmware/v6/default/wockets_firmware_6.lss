
wockets_firmware_6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00003152  00003206  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003152  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00003797  0080010c  0080010c  00003212  2**0
                  ALLOC
  3 .eeprom       00000023  00810000  00810000  00003212  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000a08  00000000  00000000  00003238  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000275  00000000  00000000  00003c40  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000080  00000000  00000000  00003eb5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000d54  00000000  00000000  00003f35  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00002bac  00000000  00000000  00004c89  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000082f  00000000  00000000  00007835  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000029bb  00000000  00000000  00008064  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000460  00000000  00000000  0000aa20  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000b59  00000000  00000000  0000ae80  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00001171  00000000  00000000  0000b9d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000030  00000000  00000000  0000cb4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubtypes 000000b6  00000000  00000000  0000cb7a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 84 00 	jmp	0x108	; 0x108 <__ctors_end>
       4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      10:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      14:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      18:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      1c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      20:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      24:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      28:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      2c:	0c 94 de 07 	jmp	0xfbc	; 0xfbc <__vector_11>
      30:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      34:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      38:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      3c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      40:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      44:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      48:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      4c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      50:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      54:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      58:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      5c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      60:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      64:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      68:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      6c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      70:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      74:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      78:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      7c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      80:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      84:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      88:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      8c:	93 11       	cpse	r25, r3
      8e:	93 11       	cpse	r25, r3
      90:	93 11       	cpse	r25, r3
      92:	93 11       	cpse	r25, r3
      94:	93 11       	cpse	r25, r3
      96:	95 11       	cpse	r25, r5
      98:	93 11       	cpse	r25, r3
      9a:	9b 11       	cpse	r25, r11
      9c:	93 11       	cpse	r25, r3
      9e:	95 11       	cpse	r25, r5
      a0:	93 11       	cpse	r25, r3
      a2:	95 11       	cpse	r25, r5
      a4:	93 11       	cpse	r25, r3
      a6:	95 11       	cpse	r25, r5
      a8:	93 11       	cpse	r25, r3
      aa:	93 11       	cpse	r25, r3
      ac:	93 11       	cpse	r25, r3
      ae:	93 11       	cpse	r25, r3
      b0:	93 11       	cpse	r25, r3
      b2:	95 11       	cpse	r25, r5
      b4:	93 11       	cpse	r25, r3
      b6:	9b 11       	cpse	r25, r11
      b8:	93 11       	cpse	r25, r3
      ba:	93 11       	cpse	r25, r3
      bc:	93 11       	cpse	r25, r3
      be:	99 11       	cpse	r25, r9
      c0:	95 11       	cpse	r25, r5
      c2:	97 11       	cpse	r25, r7
      c4:	95 11       	cpse	r25, r5
      c6:	93 11       	cpse	r25, r3
      c8:	93 11       	cpse	r25, r3
      ca:	7d 12       	cpse	r7, r29
      cc:	ab 12       	cpse	r10, r27
      ce:	6c 13       	cpse	r22, r28
      d0:	2d 17       	cp	r18, r29
      d2:	9a 12       	cpse	r9, r26
      d4:	a0 12       	cpse	r10, r16
      d6:	e1 14       	cp	r14, r1
      d8:	1c 14       	cp	r1, r12
      da:	66 13       	cpse	r22, r22
      dc:	b0 13       	cpse	r27, r16
      de:	33 17       	cp	r19, r19
      e0:	41 17       	cp	r20, r17
      e2:	58 13       	cpse	r21, r24
      e4:	5e 13       	cpse	r21, r30
      e6:	30 17       	cp	r19, r16
      e8:	78 12       	cpse	r7, r24
      ea:	6f 12       	cpse	r6, r31
      ec:	75 12       	cpse	r7, r21
      ee:	dc 13       	cpse	r29, r28
      f0:	e5 13       	cpse	r30, r21
      f2:	51 15       	cp	r21, r1
      f4:	c4 15       	cp	r28, r4
      f6:	8b 16       	cp	r8, r27
      f8:	90 16       	cp	r9, r16
      fa:	95 16       	cp	r9, r21
      fc:	22 12       	cpse	r2, r18
      fe:	f4 13       	cpse	r31, r20
     100:	d1 11       	cpse	r29, r1
     102:	c9 16       	cp	r12, r25
     104:	23 17       	cp	r18, r19
     106:	ee 13       	cpse	r30, r30

00000108 <__ctors_end>:
     108:	11 24       	eor	r1, r1
     10a:	1f be       	out	0x3f, r1	; 63
     10c:	cf ef       	ldi	r28, 0xFF	; 255
     10e:	d0 e4       	ldi	r29, 0x40	; 64
     110:	de bf       	out	0x3e, r29	; 62
     112:	cd bf       	out	0x3d, r28	; 61

00000114 <__do_copy_data>:
     114:	11 e0       	ldi	r17, 0x01	; 1
     116:	a0 e0       	ldi	r26, 0x00	; 0
     118:	b1 e0       	ldi	r27, 0x01	; 1
     11a:	e2 e5       	ldi	r30, 0x52	; 82
     11c:	f1 e3       	ldi	r31, 0x31	; 49
     11e:	00 e0       	ldi	r16, 0x00	; 0
     120:	0b bf       	out	0x3b, r16	; 59
     122:	02 c0       	rjmp	.+4      	; 0x128 <__do_copy_data+0x14>
     124:	07 90       	elpm	r0, Z+
     126:	0d 92       	st	X+, r0
     128:	ac 30       	cpi	r26, 0x0C	; 12
     12a:	b1 07       	cpc	r27, r17
     12c:	d9 f7       	brne	.-10     	; 0x124 <__do_copy_data+0x10>

0000012e <__do_clear_bss>:
     12e:	18 e3       	ldi	r17, 0x38	; 56
     130:	ac e0       	ldi	r26, 0x0C	; 12
     132:	b1 e0       	ldi	r27, 0x01	; 1
     134:	01 c0       	rjmp	.+2      	; 0x138 <.do_clear_bss_start>

00000136 <.do_clear_bss_loop>:
     136:	1d 92       	st	X+, r1

00000138 <.do_clear_bss_start>:
     138:	a3 3a       	cpi	r26, 0xA3	; 163
     13a:	b1 07       	cpc	r27, r17
     13c:	e1 f7       	brne	.-8      	; 0x136 <.do_clear_bss_loop>
     13e:	0e 94 8e 04 	call	0x91c	; 0x91c <main>
     142:	0c 94 a7 18 	jmp	0x314e	; 0x314e <_exit>

00000146 <__bad_interrupt>:
     146:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014a <ComputeByte>:
{
    int i;
    unsigned short data;
	// Xor'ing inCrc with inData
    data = (unsigned short)(inCrc ^ inData);
    data <<= 8;
     14a:	36 2f       	mov	r19, r22
     14c:	38 27       	eor	r19, r24
     14e:	20 e0       	ldi	r18, 0x00	; 0
     150:	88 e0       	ldi	r24, 0x08	; 8
     152:	90 e0       	ldi	r25, 0x00	; 0
    for (i = 0; i < 8; i++)
   	{
        if ((data & 0x8000) != 0)
        	data = (unsigned short)(data ^ POLYNOMIAL);
     154:	40 e8       	ldi	r20, 0x80	; 128
     156:	53 e8       	ldi	r21, 0x83	; 131
	// Xor'ing inCrc with inData
    data = (unsigned short)(inCrc ^ inData);
    data <<= 8;
    for (i = 0; i < 8; i++)
   	{
        if ((data & 0x8000) != 0)
     158:	37 ff       	sbrs	r19, 7
     15a:	02 c0       	rjmp	.+4      	; 0x160 <ComputeByte+0x16>
        	data = (unsigned short)(data ^ POLYNOMIAL);
     15c:	24 27       	eor	r18, r20
     15e:	35 27       	eor	r19, r21
    	data = (unsigned short)(data << 1);
     160:	22 0f       	add	r18, r18
     162:	33 1f       	adc	r19, r19
     164:	01 97       	sbiw	r24, 0x01	; 1
    int i;
    unsigned short data;
	// Xor'ing inCrc with inData
    data = (unsigned short)(inCrc ^ inData);
    data <<= 8;
    for (i = 0; i < 8; i++)
     166:	c1 f7       	brne	.-16     	; 0x158 <ComputeByte+0xe>
        if ((data & 0x8000) != 0)
        	data = (unsigned short)(data ^ POLYNOMIAL);
    	data = (unsigned short)(data << 1);
    }
	return (unsigned char)(data >> 8);
}
     168:	83 2f       	mov	r24, r19
     16a:	08 95       	ret

0000016c <ComputeCRC8>:

/* Compute CRC for one byte*/ 
unsigned char ComputeCRC8(unsigned char crc, unsigned char *data, int len)
{
     16c:	ef 92       	push	r14
     16e:	ff 92       	push	r15
     170:	0f 93       	push	r16
     172:	1f 93       	push	r17
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	7a 01       	movw	r14, r20
	for (int i = 0; (i < len); i++)
     17a:	06 2f       	mov	r16, r22
     17c:	17 2f       	mov	r17, r23
     17e:	c0 e0       	ldi	r28, 0x00	; 0
     180:	d0 e0       	ldi	r29, 0x00	; 0
     182:	06 c0       	rjmp	.+12     	; 0x190 <ComputeCRC8+0x24>
    	crc = ComputeByte(crc, *(data+i));
     184:	f8 01       	movw	r30, r16
     186:	61 91       	ld	r22, Z+
     188:	8f 01       	movw	r16, r30
     18a:	0e 94 a5 00 	call	0x14a	; 0x14a <ComputeByte>
}

/* Compute CRC for one byte*/ 
unsigned char ComputeCRC8(unsigned char crc, unsigned char *data, int len)
{
	for (int i = 0; (i < len); i++)
     18e:	21 96       	adiw	r28, 0x01	; 1
     190:	ce 15       	cp	r28, r14
     192:	df 05       	cpc	r29, r15
     194:	bc f3       	brlt	.-18     	; 0x184 <ComputeCRC8+0x18>
    	crc = ComputeByte(crc, *(data+i));
    return crc;
}
     196:	df 91       	pop	r29
     198:	cf 91       	pop	r28
     19a:	1f 91       	pop	r17
     19c:	0f 91       	pop	r16
     19e:	ff 90       	pop	r15
     1a0:	ef 90       	pop	r14
     1a2:	08 95       	ret

000001a4 <CRC16>:

/* Compute CRC for two bytes of data or unsigned short*/   
unsigned short CRC16(unsigned char *buf, int len )
{
     1a4:	cf 93       	push	r28
     1a6:	df 93       	push	r29
     1a8:	fc 01       	movw	r30, r24
	unsigned short crc = 0;
     1aa:	40 e0       	ldi	r20, 0x00	; 0
     1ac:	50 e0       	ldi	r21, 0x00	; 0
	while( len-- ) {
		int i;
		crc ^= *(char *)buf++ << 8;
		for( i = 0; i < 8; ++i ) {
			if( crc & 0x8000 )
				crc = (crc << 1) ^ 0x1021;
     1ae:	c1 e2       	ldi	r28, 0x21	; 33
     1b0:	d0 e1       	ldi	r29, 0x10	; 16

/* Compute CRC for two bytes of data or unsigned short*/   
unsigned short CRC16(unsigned char *buf, int len )
{
	unsigned short crc = 0;
	while( len-- ) {
     1b2:	12 c0       	rjmp	.+36     	; 0x1d8 <CRC16+0x34>
		int i;
		crc ^= *(char *)buf++ << 8;
     1b4:	31 91       	ld	r19, Z+
     1b6:	20 e0       	ldi	r18, 0x00	; 0
     1b8:	42 27       	eor	r20, r18
     1ba:	53 27       	eor	r21, r19
     1bc:	88 e0       	ldi	r24, 0x08	; 8
     1be:	90 e0       	ldi	r25, 0x00	; 0
     1c0:	da 01       	movw	r26, r20
     1c2:	aa 0f       	add	r26, r26
     1c4:	bb 1f       	adc	r27, r27
		for( i = 0; i < 8; ++i ) {
			if( crc & 0x8000 )
     1c6:	57 ff       	sbrs	r21, 7
     1c8:	04 c0       	rjmp	.+8      	; 0x1d2 <CRC16+0x2e>
				crc = (crc << 1) ^ 0x1021;
     1ca:	ad 01       	movw	r20, r26
     1cc:	4c 27       	eor	r20, r28
     1ce:	5d 27       	eor	r21, r29
     1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <CRC16+0x30>
			else
				crc = crc << 1;
     1d2:	ad 01       	movw	r20, r26
     1d4:	01 97       	sbiw	r24, 0x01	; 1
{
	unsigned short crc = 0;
	while( len-- ) {
		int i;
		crc ^= *(char *)buf++ << 8;
		for( i = 0; i < 8; ++i ) {
     1d6:	a1 f7       	brne	.-24     	; 0x1c0 <CRC16+0x1c>

/* Compute CRC for two bytes of data or unsigned short*/   
unsigned short CRC16(unsigned char *buf, int len )
{
	unsigned short crc = 0;
	while( len-- ) {
     1d8:	61 50       	subi	r22, 0x01	; 1
     1da:	70 40       	sbci	r23, 0x00	; 0
     1dc:	8f ef       	ldi	r24, 0xFF	; 255
     1de:	6f 3f       	cpi	r22, 0xFF	; 255
     1e0:	78 07       	cpc	r23, r24
     1e2:	41 f7       	brne	.-48     	; 0x1b4 <CRC16+0x10>
			else
				crc = crc << 1;
		}
	}
	return crc;
}
     1e4:	ca 01       	movw	r24, r20
     1e6:	df 91       	pop	r29
     1e8:	cf 91       	pop	r28
     1ea:	08 95       	ret

000001ec <_send_pdu>:
/* This function sends the raw data to the phone.
Sending a PDU, in an uncompressed mode, requires 10bits per axis. In typical scenarios, the accelerometer 
on the body is not moving or is moving slightly, it is therefore redundant to send the 10bits. Instead, if 
the difference between consecutive values, the differential data, is less than 32 (2^5), the differential
value is sent in compress mode within 5 bits*/
static __inline__ void _send_pdu(unsigned short x, unsigned short y, unsigned short z) {	
     1ec:	ef 92       	push	r14
     1ee:	ff 92       	push	r15
     1f0:	0f 93       	push	r16
     1f2:	1f 93       	push	r17
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	ec 01       	movw	r28, r24
     1fa:	8b 01       	movw	r16, r22
     1fc:	7a 01       	movw	r14, r20
	if(compress) {
     1fe:	80 91 25 01 	lds	r24, 0x0125
     202:	88 23       	and	r24, r24
     204:	09 f4       	brne	.+2      	; 0x208 <_send_pdu+0x1c>
     206:	75 c0       	rjmp	.+234    	; 0x2f2 <_send_pdu+0x106>
		deltasign = 0x00;
     208:	10 92 71 38 	sts	0x3871, r1
		if (x > prevx) {
     20c:	80 91 69 0c 	lds	r24, 0x0C69
     210:	90 91 6a 0c 	lds	r25, 0x0C6A
     214:	8c 17       	cp	r24, r28
     216:	9d 07       	cpc	r25, r29
     218:	40 f4       	brcc	.+16     	; 0x22a <_send_pdu+0x3e>
			deltasign |= 0x01; //The first bit from right: sign of difference value in x axis
     21a:	21 e0       	ldi	r18, 0x01	; 1
     21c:	20 93 71 38 	sts	0x3871, r18
			diffx = x - prevx;
     220:	9e 01       	movw	r18, r28
     222:	28 1b       	sub	r18, r24
     224:	39 0b       	sbc	r19, r25
     226:	c9 01       	movw	r24, r18
     228:	02 c0       	rjmp	.+4      	; 0x22e <_send_pdu+0x42>
		}
		else
			diffx = prevx - x;
     22a:	8c 1b       	sub	r24, r28
     22c:	9d 0b       	sbc	r25, r29
     22e:	90 93 66 0c 	sts	0x0C66, r25
     232:	80 93 65 0c 	sts	0x0C65, r24
		
		if (y > prevy) {
     236:	80 91 6d 0c 	lds	r24, 0x0C6D
     23a:	90 91 6e 0c 	lds	r25, 0x0C6E
     23e:	80 17       	cp	r24, r16
     240:	91 07       	cpc	r25, r17
     242:	50 f4       	brcc	.+20     	; 0x258 <_send_pdu+0x6c>
			deltasign |= 0x02; //The Second bit from right: sign of difference value in y axis
     244:	20 91 71 38 	lds	r18, 0x3871
     248:	22 60       	ori	r18, 0x02	; 2
     24a:	20 93 71 38 	sts	0x3871, r18
			diffy = y - prevy;
     24e:	98 01       	movw	r18, r16
     250:	28 1b       	sub	r18, r24
     252:	39 0b       	sbc	r19, r25
     254:	c9 01       	movw	r24, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <_send_pdu+0x70>
		}
		else
			diffy = prevy - y;   
     258:	80 1b       	sub	r24, r16
     25a:	91 0b       	sbc	r25, r17
     25c:	90 93 6c 0c 	sts	0x0C6C, r25
     260:	80 93 6b 0c 	sts	0x0C6B, r24
		
		if (z > prevz) {
     264:	80 91 63 38 	lds	r24, 0x3863
     268:	90 91 64 38 	lds	r25, 0x3864
     26c:	8e 15       	cp	r24, r14
     26e:	9f 05       	cpc	r25, r15
     270:	50 f4       	brcc	.+20     	; 0x286 <_send_pdu+0x9a>
			deltasign |= 0x04; //The third bit from right: sign of difference value in z axis
     272:	20 91 71 38 	lds	r18, 0x3871
     276:	24 60       	ori	r18, 0x04	; 4
     278:	20 93 71 38 	sts	0x3871, r18
			diffz = z - prevz;
     27c:	97 01       	movw	r18, r14
     27e:	28 1b       	sub	r18, r24
     280:	39 0b       	sbc	r19, r25
     282:	c9 01       	movw	r24, r18
     284:	02 c0       	rjmp	.+4      	; 0x28a <_send_pdu+0x9e>
		}
		else
			diffz = prevz - z;
     286:	8e 19       	sub	r24, r14
     288:	9f 09       	sbc	r25, r15
     28a:	90 93 62 38 	sts	0x3862, r25
     28e:	80 93 61 38 	sts	0x3861, r24
		
		if ((diffx < 32) && (diffy < 32) && (diffz < 32))			
     292:	80 91 65 0c 	lds	r24, 0x0C65
     296:	90 91 66 0c 	lds	r25, 0x0C66
     29a:	80 32       	cpi	r24, 0x20	; 32
     29c:	91 05       	cpc	r25, r1
     29e:	18 f5       	brcc	.+70     	; 0x2e6 <_send_pdu+0xfa>
     2a0:	e0 91 6b 0c 	lds	r30, 0x0C6B
     2a4:	f0 91 6c 0c 	lds	r31, 0x0C6C
     2a8:	e0 32       	cpi	r30, 0x20	; 32
     2aa:	f1 05       	cpc	r31, r1
     2ac:	e0 f4       	brcc	.+56     	; 0x2e6 <_send_pdu+0xfa>
     2ae:	20 91 61 38 	lds	r18, 0x3861
     2b2:	30 91 62 38 	lds	r19, 0x3862
     2b6:	20 32       	cpi	r18, 0x20	; 32
     2b8:	31 05       	cpc	r19, r1
     2ba:	a8 f4       	brcc	.+42     	; 0x2e6 <_send_pdu+0xfa>
			_send_compressed_pdu((diffx | ((deltasign &0x01)<<5)), (diffy | ((deltasign &0x02)<<4)), 
     2bc:	40 91 71 38 	lds	r20, 0x3871
     2c0:	54 2f       	mov	r21, r20
     2c2:	51 70       	andi	r21, 0x01	; 1
     2c4:	52 95       	swap	r21
     2c6:	55 0f       	add	r21, r21
     2c8:	50 7e       	andi	r21, 0xE0	; 224
     2ca:	64 2f       	mov	r22, r20
     2cc:	62 70       	andi	r22, 0x02	; 2
     2ce:	62 95       	swap	r22
     2d0:	60 7f       	andi	r22, 0xF0	; 240
     2d2:	6e 2b       	or	r22, r30
     2d4:	44 70       	andi	r20, 0x04	; 4
     2d6:	44 0f       	add	r20, r20
     2d8:	44 0f       	add	r20, r20
     2da:	44 0f       	add	r20, r20
     2dc:	42 2b       	or	r20, r18
     2de:	85 2b       	or	r24, r21
     2e0:	0e 94 7d 10 	call	0x20fa	; 0x20fa <_send_compressed_pdu>
     2e4:	0c c0       	rjmp	.+24     	; 0x2fe <_send_pdu+0x112>
			(diffz | ((deltasign &0x04)<<3)));
		else
			_send_uncompressed_pdu(x, y, z);
     2e6:	ce 01       	movw	r24, r28
     2e8:	b8 01       	movw	r22, r16
     2ea:	a7 01       	movw	r20, r14
     2ec:	0e 94 30 10 	call	0x2060	; 0x2060 <_send_uncompressed_pdu>
     2f0:	06 c0       	rjmp	.+12     	; 0x2fe <_send_pdu+0x112>
	}
	else {
	 	_send_uncompressed_pdu(x, y, z);
     2f2:	ce 01       	movw	r24, r28
     2f4:	0e 94 30 10 	call	0x2060	; 0x2060 <_send_uncompressed_pdu>
		compress = 1;
     2f8:	81 e0       	ldi	r24, 0x01	; 1
     2fa:	80 93 25 01 	sts	0x0125, r24
	}
	prevx = x;
     2fe:	d0 93 6a 0c 	sts	0x0C6A, r29
     302:	c0 93 69 0c 	sts	0x0C69, r28
	prevy = y;
     306:	10 93 6e 0c 	sts	0x0C6E, r17
     30a:	00 93 6d 0c 	sts	0x0C6D, r16
	prevz = z;
     30e:	f0 92 64 38 	sts	0x3864, r15
     312:	e0 92 63 38 	sts	0x3863, r14
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	08 95       	ret

00000324 <Filter>:
//--------------------------------------Filter-------------------------------------

// Averaging the accelerometer values of each axis in one miniute for producing the activity count 
unsigned short Filter(unsigned short data,int axis) {
     324:	0f 93       	push	r16
     326:	1f 93       	push	r17
     328:	cf 93       	push	r28
     32a:	df 93       	push	r29
     32c:	9c 01       	movw	r18, r24
     32e:	fb 01       	movw	r30, r22
	 unsigned short mean = 0;
	 int j=0;                
     for (; (j < _SAMPLING_RATE); j++) {
     330:	60 91 06 01 	lds	r22, 0x0106
     334:	c6 2f       	mov	r28, r22
     336:	d0 e0       	ldi	r29, 0x00	; 0
	prevz = z;
}
//--------------------------------------Filter-------------------------------------

// Averaging the accelerometer values of each axis in one miniute for producing the activity count 
unsigned short Filter(unsigned short data,int axis) {
     338:	8c e2       	ldi	r24, 0x2C	; 44
     33a:	91 e0       	ldi	r25, 0x01	; 1
     33c:	e8 9f       	mul	r30, r24
     33e:	d0 01       	movw	r26, r0
     340:	e9 9f       	mul	r30, r25
     342:	b0 0d       	add	r27, r0
     344:	f8 9f       	mul	r31, r24
     346:	b0 0d       	add	r27, r0
     348:	11 24       	eor	r1, r1
     34a:	af 51       	subi	r26, 0x1F	; 31
     34c:	b7 4f       	sbci	r27, 0xF7	; 247
	 unsigned short mean = 0;
	 int j=0;                
     34e:	40 e0       	ldi	r20, 0x00	; 0
     350:	50 e0       	ldi	r21, 0x00	; 0
}
//--------------------------------------Filter-------------------------------------

// Averaging the accelerometer values of each axis in one miniute for producing the activity count 
unsigned short Filter(unsigned short data,int axis) {
	 unsigned short mean = 0;
     352:	80 e0       	ldi	r24, 0x00	; 0
     354:	90 e0       	ldi	r25, 0x00	; 0
	 int j=0;                
     for (; (j < _SAMPLING_RATE); j++) {
     356:	0d c0       	rjmp	.+26     	; 0x372 <Filter+0x4e>
	 	  mean += xv[axis][j];	//Initializing the xv is not required because, the activity count is 
     358:	0d 91       	ld	r16, X+
     35a:	1c 91       	ld	r17, X
     35c:	11 97       	sbiw	r26, 0x01	; 1
     35e:	80 0f       	add	r24, r16
     360:	91 1f       	adc	r25, r17
		  						//calculated and saved only once per minute when xv is filled with 
								//valid accelerometer data
          xv[axis][j] = xv[axis][j + 1];		  		  
     362:	4f 5f       	subi	r20, 0xFF	; 255
     364:	5f 4f       	sbci	r21, 0xFF	; 255
     366:	12 96       	adiw	r26, 0x02	; 2
     368:	0d 91       	ld	r16, X+
     36a:	1c 91       	ld	r17, X
     36c:	13 97       	sbiw	r26, 0x03	; 3
     36e:	0d 93       	st	X+, r16
     370:	1d 93       	st	X+, r17

// Averaging the accelerometer values of each axis in one miniute for producing the activity count 
unsigned short Filter(unsigned short data,int axis) {
	 unsigned short mean = 0;
	 int j=0;                
     for (; (j < _SAMPLING_RATE); j++) {
     372:	4c 17       	cp	r20, r28
     374:	5d 07       	cpc	r21, r29
     376:	84 f3       	brlt	.-32     	; 0x358 <Filter+0x34>
	 	  mean += xv[axis][j];	//Initializing the xv is not required because, the activity count is 
		  						//calculated and saved only once per minute when xv is filled with 
								//valid accelerometer data
          xv[axis][j] = xv[axis][j + 1];		  		  
	 }
	 mean = mean / _SAMPLING_RATE;
     378:	70 e0       	ldi	r23, 0x00	; 0
     37a:	0e 94 25 18 	call	0x304a	; 0x304a <__udivmodhi4>
     xv[axis][j] = data;
     37e:	86 e9       	ldi	r24, 0x96	; 150
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	e8 9f       	mul	r30, r24
     384:	d0 01       	movw	r26, r0
     386:	e9 9f       	mul	r30, r25
     388:	b0 0d       	add	r27, r0
     38a:	f8 9f       	mul	r31, r24
     38c:	b0 0d       	add	r27, r0
     38e:	11 24       	eor	r1, r1
     390:	ac 0f       	add	r26, r28
     392:	bd 1f       	adc	r27, r29
     394:	aa 0f       	add	r26, r26
     396:	bb 1f       	adc	r27, r27
     398:	af 51       	subi	r26, 0x1F	; 31
     39a:	b7 4f       	sbci	r27, 0xF7	; 247
     39c:	11 96       	adiw	r26, 0x01	; 1
     39e:	3c 93       	st	X, r19
     3a0:	2e 93       	st	-X, r18
     				 
	 if (data > mean)
     3a2:	62 17       	cp	r22, r18
     3a4:	73 07       	cpc	r23, r19
     3a6:	18 f4       	brcc	.+6      	; 0x3ae <Filter+0x8a>
	 	return (data - mean);
     3a8:	26 1b       	sub	r18, r22
     3aa:	37 0b       	sbc	r19, r23
     3ac:	04 c0       	rjmp	.+8      	; 0x3b6 <Filter+0x92>
	 else
	 	return (mean - data);      
     3ae:	cb 01       	movw	r24, r22
     3b0:	82 1b       	sub	r24, r18
     3b2:	93 0b       	sbc	r25, r19
     3b4:	9c 01       	movw	r18, r24
}
     3b6:	c9 01       	movw	r24, r18
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	1f 91       	pop	r17
     3be:	0f 91       	pop	r16
     3c0:	08 95       	ret

000003c2 <do_sampling>:

//-----------------------------------do_sampling----------------------------------------
/* Sampling the accelerometer 
Sampling procedure is done in various parts of the code to ensure that the interups are 
acknowledeged close enough to their occurances*/
void do_sampling(){
     3c2:	cf 92       	push	r12
     3c4:	df 92       	push	r13
     3c6:	ef 92       	push	r14
     3c8:	ff 92       	push	r15
     3ca:	0f 93       	push	r16
     3cc:	1f 93       	push	r17
     3ce:	cf 93       	push	r28
     3d0:	df 93       	push	r29
	
	sampleFlag = 0;
     3d2:	10 92 26 01 	sts	0x0126, r1
	//sample the accelerometer
	/*x = _atmega_a2dConvert10bit(ADC0);		
	y = _atmega_a2dConvert10bit(ADC1);
	z = _atmega_a2dConvert10bit(ADC2);*/
	//------test-----
	if (i == 1024) 
     3d6:	80 91 23 01 	lds	r24, 0x0123
     3da:	90 91 24 01 	lds	r25, 0x0124
     3de:	24 e0       	ldi	r18, 0x04	; 4
     3e0:	80 30       	cpi	r24, 0x00	; 0
     3e2:	92 07       	cpc	r25, r18
     3e4:	21 f4       	brne	.+8      	; 0x3ee <do_sampling+0x2c>
		i=0;
     3e6:	10 92 24 01 	sts	0x0124, r1
     3ea:	10 92 23 01 	sts	0x0123, r1
	x = y = z = i;
     3ee:	80 91 23 01 	lds	r24, 0x0123
     3f2:	90 91 24 01 	lds	r25, 0x0124
     3f6:	90 93 47 01 	sts	0x0147, r25
     3fa:	80 93 46 01 	sts	0x0146, r24
     3fe:	90 93 45 01 	sts	0x0145, r25
     402:	80 93 44 01 	sts	0x0144, r24
     406:	90 93 43 01 	sts	0x0143, r25
     40a:	80 93 42 01 	sts	0x0142, r24
	i++;
     40e:	9c 01       	movw	r18, r24
     410:	2f 5f       	subi	r18, 0xFF	; 255
     412:	3f 4f       	sbci	r19, 0xFF	; 255
     414:	30 93 24 01 	sts	0x0124, r19
     418:	20 93 23 01 	sts	0x0123, r18
	//---------------

	//Filter the raw accelerometer data and compute the vector of magnitude (Activity count)
	vmag += Filter(x, 0) + Filter(y, 1) + Filter(z, 2);
     41c:	e0 90 6c 38 	lds	r14, 0x386C
     420:	f0 90 6d 38 	lds	r15, 0x386D
     424:	00 91 6e 38 	lds	r16, 0x386E
     428:	10 91 6f 38 	lds	r17, 0x386F
     42c:	60 e0       	ldi	r22, 0x00	; 0
     42e:	70 e0       	ldi	r23, 0x00	; 0
     430:	0e 94 92 01 	call	0x324	; 0x324 <Filter>
     434:	6c 01       	movw	r12, r24
     436:	80 91 44 01 	lds	r24, 0x0144
     43a:	90 91 45 01 	lds	r25, 0x0145
     43e:	61 e0       	ldi	r22, 0x01	; 1
     440:	70 e0       	ldi	r23, 0x00	; 0
     442:	0e 94 92 01 	call	0x324	; 0x324 <Filter>
     446:	ec 01       	movw	r28, r24
     448:	80 91 46 01 	lds	r24, 0x0146
     44c:	90 91 47 01 	lds	r25, 0x0147
     450:	62 e0       	ldi	r22, 0x02	; 2
     452:	70 e0       	ldi	r23, 0x00	; 0
     454:	0e 94 92 01 	call	0x324	; 0x324 <Filter>
     458:	cc 0d       	add	r28, r12
     45a:	dd 1d       	adc	r29, r13
     45c:	c8 0f       	add	r28, r24
     45e:	d9 1f       	adc	r29, r25
     460:	be 01       	movw	r22, r28
     462:	80 e0       	ldi	r24, 0x00	; 0
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	6e 0d       	add	r22, r14
     468:	7f 1d       	adc	r23, r15
     46a:	80 1f       	adc	r24, r16
     46c:	91 1f       	adc	r25, r17
     46e:	60 93 6c 38 	sts	0x386C, r22
     472:	70 93 6d 38 	sts	0x386D, r23
     476:	80 93 6e 38 	sts	0x386E, r24
     47a:	90 93 6f 38 	sts	0x386F, r25
		
	//for calculating the activity count, skip the first samples to make sure the buffer is clean	
	if (_wPC > _SAMPLING_RATE) {							
     47e:	20 91 4f 01 	lds	r18, 0x014F
     482:	30 91 50 01 	lds	r19, 0x0150
     486:	40 91 51 01 	lds	r20, 0x0151
     48a:	50 91 52 01 	lds	r21, 0x0152
     48e:	e0 90 06 01 	lds	r14, 0x0106
     492:	ff 24       	eor	r15, r15
     494:	00 e0       	ldi	r16, 0x00	; 0
     496:	10 e0       	ldi	r17, 0x00	; 0
     498:	e2 16       	cp	r14, r18
     49a:	f3 06       	cpc	r15, r19
     49c:	04 07       	cpc	r16, r20
     49e:	15 07       	cpc	r17, r21
     4a0:	08 f0       	brcs	.+2      	; 0x4a4 <do_sampling+0xe2>
     4a2:	87 c0       	rjmp	.+270    	; 0x5b2 <do_sampling+0x1f0>
		if (summary_count == 0) {			// calculate the activity count only once per miniute
     4a4:	20 91 67 0c 	lds	r18, 0x0C67
     4a8:	30 91 68 0c 	lds	r19, 0x0C68
     4ac:	21 15       	cp	r18, r1
     4ae:	31 05       	cpc	r19, r1
     4b0:	09 f0       	breq	.+2      	; 0x4b4 <do_sampling+0xf2>
     4b2:	78 c0       	rjmp	.+240    	; 0x5a4 <do_sampling+0x1e2>
			vmag = vmag / AC_SCALING;	// vmag is scaled in order to prevent the overflow 			
     4b4:	20 91 00 01 	lds	r18, 0x0100
     4b8:	30 91 01 01 	lds	r19, 0x0101
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	50 e0       	ldi	r21, 0x00	; 0
     4c0:	0e 94 39 18 	call	0x3072	; 0x3072 <__udivmodsi4>
			if (vmag > AC_CEILING)
     4c4:	60 91 02 01 	lds	r22, 0x0102
     4c8:	70 91 03 01 	lds	r23, 0x0103
     4cc:	cb 01       	movw	r24, r22
     4ce:	a0 e0       	ldi	r26, 0x00	; 0
     4d0:	b0 e0       	ldi	r27, 0x00	; 0
     4d2:	e0 91 1f 01 	lds	r30, 0x011F
     4d6:	f0 91 20 01 	lds	r31, 0x0120
     4da:	82 17       	cp	r24, r18
     4dc:	93 07       	cpc	r25, r19
     4de:	a4 07       	cpc	r26, r20
     4e0:	b5 07       	cpc	r27, r21
     4e2:	38 f4       	brcc	.+14     	; 0x4f2 <do_sampling+0x130>
				acount[ci] = AC_CEILING;// the maximum possible value of activity counts (size: two bytes)	
     4e4:	ee 0f       	add	r30, r30
     4e6:	ff 1f       	adc	r31, r31
     4e8:	e0 5a       	subi	r30, 0xA0	; 160
     4ea:	fe 4f       	sbci	r31, 0xFE	; 254
     4ec:	71 83       	std	Z+1, r23	; 0x01
     4ee:	60 83       	st	Z, r22
     4f0:	06 c0       	rjmp	.+12     	; 0x4fe <do_sampling+0x13c>
			else
				acount[ci] = (unsigned short) vmag; 
     4f2:	ee 0f       	add	r30, r30
     4f4:	ff 1f       	adc	r31, r31
     4f6:	e0 5a       	subi	r30, 0xA0	; 160
     4f8:	fe 4f       	sbci	r31, 0xFE	; 254
     4fa:	31 83       	std	Z+1, r19	; 0x01
     4fc:	20 83       	st	Z, r18
	 		
			vmag = 0;
     4fe:	10 92 6c 38 	sts	0x386C, r1
     502:	10 92 6d 38 	sts	0x386D, r1
     506:	10 92 6e 38 	sts	0x386E, r1
     50a:	10 92 6f 38 	sts	0x386F, r1
			++ci;
     50e:	80 91 1f 01 	lds	r24, 0x011F
     512:	90 91 20 01 	lds	r25, 0x0120
     516:	01 96       	adiw	r24, 0x01	; 1
     518:	90 93 20 01 	sts	0x0120, r25
     51c:	80 93 1f 01 	sts	0x011F, r24

			if (ci == AC_BUFFER_SIZE)
     520:	23 e0       	ldi	r18, 0x03	; 3
     522:	80 3c       	cpi	r24, 0xC0	; 192
     524:	92 07       	cpc	r25, r18
     526:	21 f4       	brne	.+8      	; 0x530 <do_sampling+0x16e>
				ci = 0;
     528:	10 92 20 01 	sts	0x0120, r1
     52c:	10 92 1f 01 	sts	0x011F, r1
			cseq++;	// if the activity counts for the first 16 hours are full then increment the c sequence	
     530:	80 91 17 01 	lds	r24, 0x0117
     534:	90 91 18 01 	lds	r25, 0x0118
     538:	01 96       	adiw	r24, 0x01	; 1
     53a:	90 93 18 01 	sts	0x0118, r25
     53e:	80 93 17 01 	sts	0x0117, r24
			 
			if (ci == si) {
     542:	e0 91 1f 01 	lds	r30, 0x011F
     546:	f0 91 20 01 	lds	r31, 0x0120
     54a:	80 91 21 01 	lds	r24, 0x0121
     54e:	90 91 22 01 	lds	r25, 0x0122
     552:	e8 17       	cp	r30, r24
     554:	f9 07       	cpc	r31, r25
     556:	b9 f4       	brne	.+46     	; 0x586 <do_sampling+0x1c4>
				si++;
     558:	cf 01       	movw	r24, r30
     55a:	01 96       	adiw	r24, 0x01	; 1
     55c:	90 93 22 01 	sts	0x0122, r25
     560:	80 93 21 01 	sts	0x0121, r24
				if (si == AC_BUFFER_SIZE)
     564:	23 e0       	ldi	r18, 0x03	; 3
     566:	80 3c       	cpi	r24, 0xC0	; 192
     568:	92 07       	cpc	r25, r18
     56a:	21 f4       	brne	.+8      	; 0x574 <do_sampling+0x1b2>
					si = 0;
     56c:	10 92 22 01 	sts	0x0122, r1
     570:	10 92 21 01 	sts	0x0121, r1
				sseq++;
     574:	80 91 19 01 	lds	r24, 0x0119
     578:	90 91 1a 01 	lds	r25, 0x011A
     57c:	01 96       	adiw	r24, 0x01	; 1
     57e:	90 93 1a 01 	sts	0x011A, r25
     582:	80 93 19 01 	sts	0x0119, r24
			}
			acount[ci] = 0;
     586:	ee 0f       	add	r30, r30
     588:	ff 1f       	adc	r31, r31
     58a:	e0 5a       	subi	r30, 0xA0	; 160
     58c:	fe 4f       	sbci	r31, 0xFE	; 254
     58e:	11 82       	std	Z+1, r1	; 0x01
     590:	10 82       	st	Z, r1
			summary_count = AC_NUMS;	// 1 minute Summary counter is associated with activity counts 
     592:	80 91 15 01 	lds	r24, 0x0115
     596:	90 91 16 01 	lds	r25, 0x0116
     59a:	90 93 68 0c 	sts	0x0C68, r25
     59e:	80 93 67 0c 	sts	0x0C67, r24
     5a2:	14 c0       	rjmp	.+40     	; 0x5cc <do_sampling+0x20a>
		}
		else
			summary_count--;
     5a4:	21 50       	subi	r18, 0x01	; 1
     5a6:	30 40       	sbci	r19, 0x00	; 0
     5a8:	30 93 68 0c 	sts	0x0C68, r19
     5ac:	20 93 67 0c 	sts	0x0C67, r18
     5b0:	0d c0       	rjmp	.+26     	; 0x5cc <do_sampling+0x20a>
	}
	else if (_wPC == 40)				// discard the first 40 samples for the vmag  				
     5b2:	28 32       	cpi	r18, 0x28	; 40
     5b4:	31 05       	cpc	r19, r1
     5b6:	41 05       	cpc	r20, r1
     5b8:	51 05       	cpc	r21, r1
     5ba:	41 f4       	brne	.+16     	; 0x5cc <do_sampling+0x20a>
		vmag = 0;
     5bc:	10 92 6c 38 	sts	0x386C, r1
     5c0:	10 92 6d 38 	sts	0x386D, r1
     5c4:	10 92 6e 38 	sts	0x386E, r1
     5c8:	10 92 6f 38 	sts	0x386F, r1

	//Save the raw data in the RAM 
	m_SET_X(data[dataIndex], x, dataSubindex);
     5cc:	20 91 10 01 	lds	r18, 0x0110
     5d0:	21 30       	cpi	r18, 0x01	; 1
     5d2:	31 f1       	breq	.+76     	; 0x620 <do_sampling+0x25e>
     5d4:	21 30       	cpi	r18, 0x01	; 1
     5d6:	30 f0       	brcs	.+12     	; 0x5e4 <do_sampling+0x222>
     5d8:	22 30       	cpi	r18, 0x02	; 2
     5da:	c9 f1       	breq	.+114    	; 0x64e <do_sampling+0x28c>
     5dc:	23 30       	cpi	r18, 0x03	; 3
     5de:	09 f0       	breq	.+2      	; 0x5e2 <do_sampling+0x220>
     5e0:	74 c0       	rjmp	.+232    	; 0x6ca <do_sampling+0x308>
     5e2:	54 c0       	rjmp	.+168    	; 0x68c <do_sampling+0x2ca>
     5e4:	40 91 0e 01 	lds	r20, 0x010E
     5e8:	50 91 0f 01 	lds	r21, 0x010F
     5ec:	80 91 42 01 	lds	r24, 0x0142
     5f0:	90 91 43 01 	lds	r25, 0x0143
     5f4:	fa 01       	movw	r30, r20
     5f6:	74 e0       	ldi	r23, 0x04	; 4
     5f8:	ee 0f       	add	r30, r30
     5fa:	ff 1f       	adc	r31, r31
     5fc:	7a 95       	dec	r23
     5fe:	e1 f7       	brne	.-8      	; 0x5f8 <do_sampling+0x236>
     600:	e4 1b       	sub	r30, r20
     602:	f5 0b       	sbc	r31, r21
     604:	e1 59       	subi	r30, 0x91	; 145
     606:	f3 4f       	sbci	r31, 0xF3	; 243
     608:	ac 01       	movw	r20, r24
     60a:	56 95       	lsr	r21
     60c:	47 95       	ror	r20
     60e:	56 95       	lsr	r21
     610:	47 95       	ror	r20
     612:	40 83       	st	Z, r20
     614:	82 95       	swap	r24
     616:	88 0f       	add	r24, r24
     618:	88 0f       	add	r24, r24
     61a:	80 7c       	andi	r24, 0xC0	; 192
     61c:	81 83       	std	Z+1, r24	; 0x01
     61e:	60 c0       	rjmp	.+192    	; 0x6e0 <do_sampling+0x31e>
     620:	80 91 0e 01 	lds	r24, 0x010E
     624:	90 91 0f 01 	lds	r25, 0x010F
     628:	30 91 42 01 	lds	r19, 0x0142
     62c:	40 91 43 01 	lds	r20, 0x0143
     630:	fc 01       	movw	r30, r24
     632:	54 e0       	ldi	r21, 0x04	; 4
     634:	ee 0f       	add	r30, r30
     636:	ff 1f       	adc	r31, r31
     638:	5a 95       	dec	r21
     63a:	e1 f7       	brne	.-8      	; 0x634 <do_sampling+0x272>
     63c:	e8 1b       	sub	r30, r24
     63e:	f9 0b       	sbc	r31, r25
     640:	e1 59       	subi	r30, 0x91	; 145
     642:	f3 4f       	sbci	r31, 0xF3	; 243
     644:	83 81       	ldd	r24, Z+3	; 0x03
     646:	84 2b       	or	r24, r20
     648:	83 83       	std	Z+3, r24	; 0x03
     64a:	34 83       	std	Z+4, r19	; 0x04
     64c:	68 c0       	rjmp	.+208    	; 0x71e <do_sampling+0x35c>
     64e:	40 91 0e 01 	lds	r20, 0x010E
     652:	50 91 0f 01 	lds	r21, 0x010F
     656:	80 91 42 01 	lds	r24, 0x0142
     65a:	90 91 43 01 	lds	r25, 0x0143
     65e:	fa 01       	movw	r30, r20
     660:	34 e0       	ldi	r19, 0x04	; 4
     662:	ee 0f       	add	r30, r30
     664:	ff 1f       	adc	r31, r31
     666:	3a 95       	dec	r19
     668:	e1 f7       	brne	.-8      	; 0x662 <do_sampling+0x2a0>
     66a:	e4 1b       	sub	r30, r20
     66c:	f5 0b       	sbc	r31, r21
     66e:	e1 59       	subi	r30, 0x91	; 145
     670:	f3 4f       	sbci	r31, 0xF3	; 243
     672:	ac 01       	movw	r20, r24
     674:	96 e0       	ldi	r25, 0x06	; 6
     676:	56 95       	lsr	r21
     678:	47 95       	ror	r20
     67a:	9a 95       	dec	r25
     67c:	e1 f7       	brne	.-8      	; 0x676 <do_sampling+0x2b4>
     67e:	37 81       	ldd	r19, Z+7	; 0x07
     680:	34 2b       	or	r19, r20
     682:	37 83       	std	Z+7, r19	; 0x07
     684:	88 0f       	add	r24, r24
     686:	88 0f       	add	r24, r24
     688:	80 87       	std	Z+8, r24	; 0x08
     68a:	67 c0       	rjmp	.+206    	; 0x75a <do_sampling+0x398>
     68c:	40 91 0e 01 	lds	r20, 0x010E
     690:	50 91 0f 01 	lds	r21, 0x010F
     694:	80 91 42 01 	lds	r24, 0x0142
     698:	90 91 43 01 	lds	r25, 0x0143
     69c:	fa 01       	movw	r30, r20
     69e:	04 e0       	ldi	r16, 0x04	; 4
     6a0:	ee 0f       	add	r30, r30
     6a2:	ff 1f       	adc	r31, r31
     6a4:	0a 95       	dec	r16
     6a6:	e1 f7       	brne	.-8      	; 0x6a0 <do_sampling+0x2de>
     6a8:	e4 1b       	sub	r30, r20
     6aa:	f5 0b       	sbc	r31, r21
     6ac:	e1 59       	subi	r30, 0x91	; 145
     6ae:	f3 4f       	sbci	r31, 0xF3	; 243
     6b0:	ac 01       	movw	r20, r24
     6b2:	14 e0       	ldi	r17, 0x04	; 4
     6b4:	56 95       	lsr	r21
     6b6:	47 95       	ror	r20
     6b8:	1a 95       	dec	r17
     6ba:	e1 f7       	brne	.-8      	; 0x6b4 <do_sampling+0x2f2>
     6bc:	33 85       	ldd	r19, Z+11	; 0x0b
     6be:	34 2b       	or	r19, r20
     6c0:	33 87       	std	Z+11, r19	; 0x0b
     6c2:	82 95       	swap	r24
     6c4:	80 7f       	andi	r24, 0xF0	; 240
     6c6:	84 87       	std	Z+12, r24	; 0x0c
     6c8:	5f c0       	rjmp	.+190    	; 0x788 <do_sampling+0x3c6>
	m_SET_Y(data[dataIndex], y, dataSubindex);
     6ca:	21 30       	cpi	r18, 0x01	; 1
     6cc:	41 f1       	breq	.+80     	; 0x71e <do_sampling+0x35c>
     6ce:	21 30       	cpi	r18, 0x01	; 1
     6d0:	38 f0       	brcs	.+14     	; 0x6e0 <do_sampling+0x31e>
     6d2:	22 30       	cpi	r18, 0x02	; 2
     6d4:	09 f4       	brne	.+2      	; 0x6d8 <do_sampling+0x316>
     6d6:	41 c0       	rjmp	.+130    	; 0x75a <do_sampling+0x398>
     6d8:	23 30       	cpi	r18, 0x03	; 3
     6da:	09 f0       	breq	.+2      	; 0x6de <do_sampling+0x31c>
     6dc:	74 c0       	rjmp	.+232    	; 0x7c6 <do_sampling+0x404>
     6de:	54 c0       	rjmp	.+168    	; 0x788 <do_sampling+0x3c6>
     6e0:	40 91 0e 01 	lds	r20, 0x010E
     6e4:	50 91 0f 01 	lds	r21, 0x010F
     6e8:	80 91 44 01 	lds	r24, 0x0144
     6ec:	90 91 45 01 	lds	r25, 0x0145
     6f0:	fa 01       	movw	r30, r20
     6f2:	b4 e0       	ldi	r27, 0x04	; 4
     6f4:	ee 0f       	add	r30, r30
     6f6:	ff 1f       	adc	r31, r31
     6f8:	ba 95       	dec	r27
     6fa:	e1 f7       	brne	.-8      	; 0x6f4 <do_sampling+0x332>
     6fc:	e4 1b       	sub	r30, r20
     6fe:	f5 0b       	sbc	r31, r21
     700:	e1 59       	subi	r30, 0x91	; 145
     702:	f3 4f       	sbci	r31, 0xF3	; 243
     704:	ac 01       	movw	r20, r24
     706:	a4 e0       	ldi	r26, 0x04	; 4
     708:	56 95       	lsr	r21
     70a:	47 95       	ror	r20
     70c:	aa 95       	dec	r26
     70e:	e1 f7       	brne	.-8      	; 0x708 <do_sampling+0x346>
     710:	31 81       	ldd	r19, Z+1	; 0x01
     712:	34 2b       	or	r19, r20
     714:	31 83       	std	Z+1, r19	; 0x01
     716:	82 95       	swap	r24
     718:	80 7f       	andi	r24, 0xF0	; 240
     71a:	82 83       	std	Z+2, r24	; 0x02
     71c:	5f c0       	rjmp	.+190    	; 0x7dc <do_sampling+0x41a>
     71e:	40 91 0e 01 	lds	r20, 0x010E
     722:	50 91 0f 01 	lds	r21, 0x010F
     726:	80 91 44 01 	lds	r24, 0x0144
     72a:	90 91 45 01 	lds	r25, 0x0145
     72e:	fa 01       	movw	r30, r20
     730:	74 e0       	ldi	r23, 0x04	; 4
     732:	ee 0f       	add	r30, r30
     734:	ff 1f       	adc	r31, r31
     736:	7a 95       	dec	r23
     738:	e1 f7       	brne	.-8      	; 0x732 <do_sampling+0x370>
     73a:	e4 1b       	sub	r30, r20
     73c:	f5 0b       	sbc	r31, r21
     73e:	e1 59       	subi	r30, 0x91	; 145
     740:	f3 4f       	sbci	r31, 0xF3	; 243
     742:	ac 01       	movw	r20, r24
     744:	56 95       	lsr	r21
     746:	47 95       	ror	r20
     748:	56 95       	lsr	r21
     74a:	47 95       	ror	r20
     74c:	45 83       	std	Z+5, r20	; 0x05
     74e:	82 95       	swap	r24
     750:	88 0f       	add	r24, r24
     752:	88 0f       	add	r24, r24
     754:	80 7c       	andi	r24, 0xC0	; 192
     756:	86 83       	std	Z+6, r24	; 0x06
     758:	60 c0       	rjmp	.+192    	; 0x81a <do_sampling+0x458>
     75a:	80 91 0e 01 	lds	r24, 0x010E
     75e:	90 91 0f 01 	lds	r25, 0x010F
     762:	30 91 44 01 	lds	r19, 0x0144
     766:	40 91 45 01 	lds	r20, 0x0145
     76a:	fc 01       	movw	r30, r24
     76c:	54 e0       	ldi	r21, 0x04	; 4
     76e:	ee 0f       	add	r30, r30
     770:	ff 1f       	adc	r31, r31
     772:	5a 95       	dec	r21
     774:	e1 f7       	brne	.-8      	; 0x76e <do_sampling+0x3ac>
     776:	e8 1b       	sub	r30, r24
     778:	f9 0b       	sbc	r31, r25
     77a:	e1 59       	subi	r30, 0x91	; 145
     77c:	f3 4f       	sbci	r31, 0xF3	; 243
     77e:	80 85       	ldd	r24, Z+8	; 0x08
     780:	84 2b       	or	r24, r20
     782:	80 87       	std	Z+8, r24	; 0x08
     784:	31 87       	std	Z+9, r19	; 0x09
     786:	68 c0       	rjmp	.+208    	; 0x858 <do_sampling+0x496>
     788:	40 91 0e 01 	lds	r20, 0x010E
     78c:	50 91 0f 01 	lds	r21, 0x010F
     790:	80 91 44 01 	lds	r24, 0x0144
     794:	90 91 45 01 	lds	r25, 0x0145
     798:	fa 01       	movw	r30, r20
     79a:	34 e0       	ldi	r19, 0x04	; 4
     79c:	ee 0f       	add	r30, r30
     79e:	ff 1f       	adc	r31, r31
     7a0:	3a 95       	dec	r19
     7a2:	e1 f7       	brne	.-8      	; 0x79c <do_sampling+0x3da>
     7a4:	e4 1b       	sub	r30, r20
     7a6:	f5 0b       	sbc	r31, r21
     7a8:	e1 59       	subi	r30, 0x91	; 145
     7aa:	f3 4f       	sbci	r31, 0xF3	; 243
     7ac:	ac 01       	movw	r20, r24
     7ae:	96 e0       	ldi	r25, 0x06	; 6
     7b0:	56 95       	lsr	r21
     7b2:	47 95       	ror	r20
     7b4:	9a 95       	dec	r25
     7b6:	e1 f7       	brne	.-8      	; 0x7b0 <do_sampling+0x3ee>
     7b8:	34 85       	ldd	r19, Z+12	; 0x0c
     7ba:	34 2b       	or	r19, r20
     7bc:	34 87       	std	Z+12, r19	; 0x0c
     7be:	88 0f       	add	r24, r24
     7c0:	88 0f       	add	r24, r24
     7c2:	85 87       	std	Z+13, r24	; 0x0d
     7c4:	67 c0       	rjmp	.+206    	; 0x894 <do_sampling+0x4d2>
	m_SET_Z(data[dataIndex], z, dataSubindex);
     7c6:	21 30       	cpi	r18, 0x01	; 1
     7c8:	41 f1       	breq	.+80     	; 0x81a <do_sampling+0x458>
     7ca:	21 30       	cpi	r18, 0x01	; 1
     7cc:	38 f0       	brcs	.+14     	; 0x7dc <do_sampling+0x41a>
     7ce:	22 30       	cpi	r18, 0x02	; 2
     7d0:	09 f4       	brne	.+2      	; 0x7d4 <do_sampling+0x412>
     7d2:	42 c0       	rjmp	.+132    	; 0x858 <do_sampling+0x496>
     7d4:	23 30       	cpi	r18, 0x03	; 3
     7d6:	09 f0       	breq	.+2      	; 0x7da <do_sampling+0x418>
     7d8:	73 c0       	rjmp	.+230    	; 0x8c0 <do_sampling+0x4fe>
     7da:	5c c0       	rjmp	.+184    	; 0x894 <do_sampling+0x4d2>
     7dc:	40 91 0e 01 	lds	r20, 0x010E
     7e0:	50 91 0f 01 	lds	r21, 0x010F
     7e4:	80 91 46 01 	lds	r24, 0x0146
     7e8:	90 91 47 01 	lds	r25, 0x0147
     7ec:	fa 01       	movw	r30, r20
     7ee:	04 e0       	ldi	r16, 0x04	; 4
     7f0:	ee 0f       	add	r30, r30
     7f2:	ff 1f       	adc	r31, r31
     7f4:	0a 95       	dec	r16
     7f6:	e1 f7       	brne	.-8      	; 0x7f0 <do_sampling+0x42e>
     7f8:	e4 1b       	sub	r30, r20
     7fa:	f5 0b       	sbc	r31, r21
     7fc:	e1 59       	subi	r30, 0x91	; 145
     7fe:	f3 4f       	sbci	r31, 0xF3	; 243
     800:	ac 01       	movw	r20, r24
     802:	16 e0       	ldi	r17, 0x06	; 6
     804:	56 95       	lsr	r21
     806:	47 95       	ror	r20
     808:	1a 95       	dec	r17
     80a:	e1 f7       	brne	.-8      	; 0x804 <do_sampling+0x442>
     80c:	32 81       	ldd	r19, Z+2	; 0x02
     80e:	34 2b       	or	r19, r20
     810:	32 83       	std	Z+2, r19	; 0x02
     812:	88 0f       	add	r24, r24
     814:	88 0f       	add	r24, r24
     816:	83 83       	std	Z+3, r24	; 0x03
     818:	53 c0       	rjmp	.+166    	; 0x8c0 <do_sampling+0x4fe>
     81a:	40 91 0e 01 	lds	r20, 0x010E
     81e:	50 91 0f 01 	lds	r21, 0x010F
     822:	80 91 46 01 	lds	r24, 0x0146
     826:	90 91 47 01 	lds	r25, 0x0147
     82a:	fa 01       	movw	r30, r20
     82c:	b4 e0       	ldi	r27, 0x04	; 4
     82e:	ee 0f       	add	r30, r30
     830:	ff 1f       	adc	r31, r31
     832:	ba 95       	dec	r27
     834:	e1 f7       	brne	.-8      	; 0x82e <do_sampling+0x46c>
     836:	e4 1b       	sub	r30, r20
     838:	f5 0b       	sbc	r31, r21
     83a:	e1 59       	subi	r30, 0x91	; 145
     83c:	f3 4f       	sbci	r31, 0xF3	; 243
     83e:	ac 01       	movw	r20, r24
     840:	a4 e0       	ldi	r26, 0x04	; 4
     842:	56 95       	lsr	r21
     844:	47 95       	ror	r20
     846:	aa 95       	dec	r26
     848:	e1 f7       	brne	.-8      	; 0x842 <do_sampling+0x480>
     84a:	36 81       	ldd	r19, Z+6	; 0x06
     84c:	34 2b       	or	r19, r20
     84e:	36 83       	std	Z+6, r19	; 0x06
     850:	82 95       	swap	r24
     852:	80 7f       	andi	r24, 0xF0	; 240
     854:	87 83       	std	Z+7, r24	; 0x07
     856:	34 c0       	rjmp	.+104    	; 0x8c0 <do_sampling+0x4fe>
     858:	40 91 0e 01 	lds	r20, 0x010E
     85c:	50 91 0f 01 	lds	r21, 0x010F
     860:	80 91 46 01 	lds	r24, 0x0146
     864:	90 91 47 01 	lds	r25, 0x0147
     868:	fa 01       	movw	r30, r20
     86a:	74 e0       	ldi	r23, 0x04	; 4
     86c:	ee 0f       	add	r30, r30
     86e:	ff 1f       	adc	r31, r31
     870:	7a 95       	dec	r23
     872:	e1 f7       	brne	.-8      	; 0x86c <do_sampling+0x4aa>
     874:	e4 1b       	sub	r30, r20
     876:	f5 0b       	sbc	r31, r21
     878:	e1 59       	subi	r30, 0x91	; 145
     87a:	f3 4f       	sbci	r31, 0xF3	; 243
     87c:	ac 01       	movw	r20, r24
     87e:	56 95       	lsr	r21
     880:	47 95       	ror	r20
     882:	56 95       	lsr	r21
     884:	47 95       	ror	r20
     886:	42 87       	std	Z+10, r20	; 0x0a
     888:	82 95       	swap	r24
     88a:	88 0f       	add	r24, r24
     88c:	88 0f       	add	r24, r24
     88e:	80 7c       	andi	r24, 0xC0	; 192
     890:	83 87       	std	Z+11, r24	; 0x0b
     892:	16 c0       	rjmp	.+44     	; 0x8c0 <do_sampling+0x4fe>
     894:	80 91 0e 01 	lds	r24, 0x010E
     898:	90 91 0f 01 	lds	r25, 0x010F
     89c:	30 91 46 01 	lds	r19, 0x0146
     8a0:	40 91 47 01 	lds	r20, 0x0147
     8a4:	fc 01       	movw	r30, r24
     8a6:	54 e0       	ldi	r21, 0x04	; 4
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	5a 95       	dec	r21
     8ae:	e1 f7       	brne	.-8      	; 0x8a8 <do_sampling+0x4e6>
     8b0:	e8 1b       	sub	r30, r24
     8b2:	f9 0b       	sbc	r31, r25
     8b4:	e1 59       	subi	r30, 0x91	; 145
     8b6:	f3 4f       	sbci	r31, 0xF3	; 243
     8b8:	85 85       	ldd	r24, Z+13	; 0x0d
     8ba:	84 2b       	or	r24, r20
     8bc:	85 87       	std	Z+13, r24	; 0x0d
     8be:	36 87       	std	Z+14, r19	; 0x0e

	dataSubindex++;
     8c0:	2f 5f       	subi	r18, 0xFF	; 255
     8c2:	20 93 10 01 	sts	0x0110, r18
	if (dataSubindex >= 4) {	
     8c6:	24 30       	cpi	r18, 0x04	; 4
     8c8:	00 f1       	brcs	.+64     	; 0x90a <do_sampling+0x548>
	 	dataSubindex = 0; 
     8ca:	10 92 10 01 	sts	0x0110, r1
		dataIndex++;
     8ce:	80 91 0e 01 	lds	r24, 0x010E
     8d2:	90 91 0f 01 	lds	r25, 0x010F
     8d6:	01 96       	adiw	r24, 0x01	; 1
     8d8:	90 93 0f 01 	sts	0x010F, r25
     8dc:	80 93 0e 01 	sts	0x010E, r24
		if (dataIndex >= DATA_SIZE)
     8e0:	22 e0       	ldi	r18, 0x02	; 2
     8e2:	8e 3e       	cpi	r24, 0xEE	; 238
     8e4:	92 07       	cpc	r25, r18
     8e6:	20 f0       	brcs	.+8      	; 0x8f0 <do_sampling+0x52e>
			dataIndex = 0;
     8e8:	10 92 0f 01 	sts	0x010F, r1
     8ec:	10 92 0e 01 	sts	0x010E, r1

		if (batch_counter < (DATA_SIZE - 1))
     8f0:	80 91 0c 01 	lds	r24, 0x010C
     8f4:	90 91 0d 01 	lds	r25, 0x010D
     8f8:	22 e0       	ldi	r18, 0x02	; 2
     8fa:	8d 3e       	cpi	r24, 0xED	; 237
     8fc:	92 07       	cpc	r25, r18
     8fe:	28 f4       	brcc	.+10     	; 0x90a <do_sampling+0x548>
			batch_counter++;
     900:	01 96       	adiw	r24, 0x01	; 1
     902:	90 93 0d 01 	sts	0x010D, r25
     906:	80 93 0c 01 	sts	0x010C, r24
	}
}	
     90a:	df 91       	pop	r29
     90c:	cf 91       	pop	r28
     90e:	1f 91       	pop	r17
     910:	0f 91       	pop	r16
     912:	ff 90       	pop	r15
     914:	ef 90       	pop	r14
     916:	df 90       	pop	r13
     918:	cf 90       	pop	r12
     91a:	08 95       	ret

0000091c <main>:


//----------------------------------- Main function ----------------------------------------------
int main() {
     91c:	1f 93       	push	r17
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29

   // If the wocket is docked, waits for 10 seconds
	if (_is_docked()) {
     922:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <_is_docked>
     926:	88 23       	and	r24, r24
     928:	69 f4       	brne	.+26     	; 0x944 <main+0x28>
     92a:	11 c0       	rjmp	.+34     	; 0x94e <main+0x32>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     92c:	ef e0       	ldi	r30, 0x0F	; 15
     92e:	f7 e2       	ldi	r31, 0x27	; 39
     930:	31 97       	sbiw	r30, 0x01	; 1
     932:	f1 f7       	brne	.-4      	; 0x930 <main+0x14>
     934:	00 c0       	rjmp	.+0      	; 0x936 <main+0x1a>
     936:	00 00       	nop
     938:	21 50       	subi	r18, 0x01	; 1
     93a:	30 40       	sbci	r19, 0x00	; 0
		for(int j = 0;(j < 10);j++)			
			for(int i = 0;(i < 200);i++)
     93c:	b9 f7       	brne	.-18     	; 0x92c <main+0x10>
     93e:	01 97       	sbiw	r24, 0x01	; 1
//----------------------------------- Main function ----------------------------------------------
int main() {

   // If the wocket is docked, waits for 10 seconds
	if (_is_docked()) {
		for(int j = 0;(j < 10);j++)			
     940:	19 f4       	brne	.+6      	; 0x948 <main+0x2c>
     942:	05 c0       	rjmp	.+10     	; 0x94e <main+0x32>

//----------------------------------- Main function ----------------------------------------------
int main() {

   // If the wocket is docked, waits for 10 seconds
	if (_is_docked()) {
     944:	8a e0       	ldi	r24, 0x0A	; 10
     946:	90 e0       	ldi	r25, 0x00	; 0
	}
}	


//----------------------------------- Main function ----------------------------------------------
int main() {
     948:	28 ec       	ldi	r18, 0xC8	; 200
     94a:	30 e0       	ldi	r19, 0x00	; 0
     94c:	ef cf       	rjmp	.-34     	; 0x92c <main+0x10>
			for(int i = 0;(i < 200);i++)
				_delay_ms(5);
	}

	// Blink green for 5 seconds	
	_wocket_initialize();
     94e:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <_wocket_initialize>

	summary_count = _SAMPLING_RATE * 60;
     952:	90 91 06 01 	lds	r25, 0x0106
     956:	8c e3       	ldi	r24, 0x3C	; 60
     958:	98 9f       	mul	r25, r24
     95a:	c0 01       	movw	r24, r0
     95c:	11 24       	eor	r1, r1
     95e:	90 93 68 0c 	sts	0x0C68, r25
     962:	80 93 67 0c 	sts	0x0C67, r24
	AC_NUMS = _SAMPLING_RATE * 60;
     966:	90 93 16 01 	sts	0x0116, r25
     96a:	80 93 15 01 	sts	0x0115, r24

	/*Functions used for optimizing power by shutting down different peripherals. 
	These functions are part of the external dependencies provided by AVR software power.h*/
	power_adc_disable();
     96e:	80 91 64 00 	lds	r24, 0x0064
     972:	81 60       	ori	r24, 0x01	; 1
     974:	80 93 64 00 	sts	0x0064, r24
  	power_spi_disable();
     978:	80 91 64 00 	lds	r24, 0x0064
     97c:	84 60       	ori	r24, 0x04	; 4
     97e:	80 93 64 00 	sts	0x0064, r24
  	power_timer0_disable();
     982:	80 91 64 00 	lds	r24, 0x0064
     986:	80 62       	ori	r24, 0x20	; 32
     988:	80 93 64 00 	sts	0x0064, r24
  	power_timer1_disable();
     98c:	80 91 64 00 	lds	r24, 0x0064
     990:	88 60       	ori	r24, 0x08	; 8
     992:	80 93 64 00 	sts	0x0064, r24
  	power_twi_disable();
     996:	80 91 64 00 	lds	r24, 0x0064
     99a:	80 68       	ori	r24, 0x80	; 128
     99c:	80 93 64 00 	sts	0x0064, r24
				}											
		
		        // if the wocket was just connected, confirm the wocket transmission mode 
				if (justconnected == 1)	{
					_send_wtm();
					justconnected = 2;
     9a0:	12 e0       	ldi	r17, 0x02	; 2
  	power_twi_disable();

	//Loop indefinitely
	while(1){

		if(sampleFlag){		// Sample flag is turned ON in the timer 2 ISR (OVR)\
     9a2:	80 91 26 01 	lds	r24, 0x0126
     9a6:	88 23       	and	r24, r24
     9a8:	09 f4       	brne	.+2      	; 0x9ac <main+0x90>
     9aa:	fb c2       	rjmp	.+1526   	; 0xfa2 <main+0x686>
		    
			//turn on adc and micro controller on board	
			power_adc_enable();
     9ac:	80 91 64 00 	lds	r24, 0x0064
     9b0:	8e 7f       	andi	r24, 0xFE	; 254
     9b2:	80 93 64 00 	sts	0x0064, r24
			_atmega_adc_turn_on();
     9b6:	0e 94 b9 09 	call	0x1372	; 0x1372 <_atmega_adc_turn_on>
			
			do_sampling(); // To prevent data loss, sampling is done in the "main loop" instead of the 
     9ba:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <do_sampling>
			               //"Interrupt Service Routine"				
		
			if (_wTM == _WTM_Continuous) { //Countinuous Mode
     9be:	80 91 4e 01 	lds	r24, 0x014E
     9c2:	88 23       	and	r24, r24
     9c4:	09 f0       	breq	.+2      	; 0x9c8 <main+0xac>
     9c6:	29 c1       	rjmp	.+594    	; 0xc1a <main+0x2fe>
				//Fetching raw data	
				switch(dataSubindex) {
     9c8:	80 91 10 01 	lds	r24, 0x0110
     9cc:	81 30       	cpi	r24, 0x01	; 1
     9ce:	51 f0       	breq	.+20     	; 0x9e4 <main+0xc8>
     9d0:	81 30       	cpi	r24, 0x01	; 1
     9d2:	08 f4       	brcc	.+2      	; 0x9d6 <main+0xba>
     9d4:	bf c0       	rjmp	.+382    	; 0xb54 <main+0x238>
     9d6:	82 30       	cpi	r24, 0x02	; 2
     9d8:	09 f4       	brne	.+2      	; 0x9dc <main+0xc0>
     9da:	44 c0       	rjmp	.+136    	; 0xa64 <main+0x148>
     9dc:	83 30       	cpi	r24, 0x03	; 3
     9de:	09 f0       	breq	.+2      	; 0x9e2 <main+0xc6>
     9e0:	fc c0       	rjmp	.+504    	; 0xbda <main+0x2be>
     9e2:	7b c0       	rjmp	.+246    	; 0xada <main+0x1be>
					case 1:
							m_GET_X(x, data[dataIndex].byte1,  data[dataIndex].byte2,  0);
     9e4:	80 91 0e 01 	lds	r24, 0x010E
     9e8:	90 91 0f 01 	lds	r25, 0x010F
     9ec:	fc 01       	movw	r30, r24
     9ee:	74 e0       	ldi	r23, 0x04	; 4
     9f0:	ee 0f       	add	r30, r30
     9f2:	ff 1f       	adc	r31, r31
     9f4:	7a 95       	dec	r23
     9f6:	e1 f7       	brne	.-8      	; 0x9f0 <main+0xd4>
     9f8:	e8 1b       	sub	r30, r24
     9fa:	f9 0b       	sbc	r31, r25
     9fc:	e1 59       	subi	r30, 0x91	; 145
     9fe:	f3 4f       	sbci	r31, 0xF3	; 243
     a00:	21 81       	ldd	r18, Z+1	; 0x01
     a02:	82 2f       	mov	r24, r18
     a04:	82 95       	swap	r24
     a06:	86 95       	lsr	r24
     a08:	86 95       	lsr	r24
     a0a:	83 70       	andi	r24, 0x03	; 3
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	40 81       	ld	r20, Z
     a10:	50 e0       	ldi	r21, 0x00	; 0
     a12:	44 0f       	add	r20, r20
     a14:	55 1f       	adc	r21, r21
     a16:	44 0f       	add	r20, r20
     a18:	55 1f       	adc	r21, r21
     a1a:	84 2b       	or	r24, r20
     a1c:	95 2b       	or	r25, r21
     a1e:	90 93 43 01 	sts	0x0143, r25
     a22:	80 93 42 01 	sts	0x0142, r24
							m_GET_Y(y, data[dataIndex].byte2,  data[dataIndex].byte3,  0);
     a26:	82 81       	ldd	r24, Z+2	; 0x02
     a28:	30 e0       	ldi	r19, 0x00	; 0
     a2a:	2f 73       	andi	r18, 0x3F	; 63
     a2c:	30 70       	andi	r19, 0x00	; 0
     a2e:	54 e0       	ldi	r21, 0x04	; 4
     a30:	22 0f       	add	r18, r18
     a32:	33 1f       	adc	r19, r19
     a34:	5a 95       	dec	r21
     a36:	e1 f7       	brne	.-8      	; 0xa30 <main+0x114>
     a38:	48 2f       	mov	r20, r24
     a3a:	42 95       	swap	r20
     a3c:	4f 70       	andi	r20, 0x0F	; 15
     a3e:	50 e0       	ldi	r21, 0x00	; 0
     a40:	24 2b       	or	r18, r20
     a42:	35 2b       	or	r19, r21
     a44:	30 93 45 01 	sts	0x0145, r19
     a48:	20 93 44 01 	sts	0x0144, r18
							m_GET_Z(z, data[dataIndex].byte3,  data[dataIndex].byte4,  0);
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	8f 70       	andi	r24, 0x0F	; 15
     a50:	90 70       	andi	r25, 0x00	; 0
     a52:	46 e0       	ldi	r20, 0x06	; 6
     a54:	88 0f       	add	r24, r24
     a56:	99 1f       	adc	r25, r25
     a58:	4a 95       	dec	r20
     a5a:	e1 f7       	brne	.-8      	; 0xa54 <main+0x138>
     a5c:	23 81       	ldd	r18, Z+3	; 0x03
     a5e:	26 95       	lsr	r18
     a60:	26 95       	lsr	r18
     a62:	b4 c0       	rjmp	.+360    	; 0xbcc <main+0x2b0>
							break;
					case 2:
							m_GET_X(x, data[dataIndex].byte4,  data[dataIndex].byte5,  1);
     a64:	80 91 0e 01 	lds	r24, 0x010E
     a68:	90 91 0f 01 	lds	r25, 0x010F
     a6c:	fc 01       	movw	r30, r24
     a6e:	34 e0       	ldi	r19, 0x04	; 4
     a70:	ee 0f       	add	r30, r30
     a72:	ff 1f       	adc	r31, r31
     a74:	3a 95       	dec	r19
     a76:	e1 f7       	brne	.-8      	; 0xa70 <main+0x154>
     a78:	e8 1b       	sub	r30, r24
     a7a:	f9 0b       	sbc	r31, r25
     a7c:	e1 59       	subi	r30, 0x91	; 145
     a7e:	f3 4f       	sbci	r31, 0xF3	; 243
     a80:	83 81       	ldd	r24, Z+3	; 0x03
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	83 70       	andi	r24, 0x03	; 3
     a86:	90 70       	andi	r25, 0x00	; 0
     a88:	98 2f       	mov	r25, r24
     a8a:	88 27       	eor	r24, r24
     a8c:	24 81       	ldd	r18, Z+4	; 0x04
     a8e:	30 e0       	ldi	r19, 0x00	; 0
     a90:	82 2b       	or	r24, r18
     a92:	93 2b       	or	r25, r19
     a94:	90 93 43 01 	sts	0x0143, r25
     a98:	80 93 42 01 	sts	0x0142, r24
							m_GET_Y(y, data[dataIndex].byte6,  data[dataIndex].byte7,  1);
     a9c:	86 81       	ldd	r24, Z+6	; 0x06
     a9e:	28 2f       	mov	r18, r24
     aa0:	22 95       	swap	r18
     aa2:	26 95       	lsr	r18
     aa4:	26 95       	lsr	r18
     aa6:	23 70       	andi	r18, 0x03	; 3
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	45 81       	ldd	r20, Z+5	; 0x05
     aac:	50 e0       	ldi	r21, 0x00	; 0
     aae:	44 0f       	add	r20, r20
     ab0:	55 1f       	adc	r21, r21
     ab2:	44 0f       	add	r20, r20
     ab4:	55 1f       	adc	r21, r21
     ab6:	24 2b       	or	r18, r20
     ab8:	35 2b       	or	r19, r21
     aba:	30 93 45 01 	sts	0x0145, r19
     abe:	20 93 44 01 	sts	0x0144, r18
							m_GET_Z(z, data[dataIndex].byte7,  data[dataIndex].byte8,  1);
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	8f 73       	andi	r24, 0x3F	; 63
     ac6:	90 70       	andi	r25, 0x00	; 0
     ac8:	a4 e0       	ldi	r26, 0x04	; 4
     aca:	88 0f       	add	r24, r24
     acc:	99 1f       	adc	r25, r25
     ace:	aa 95       	dec	r26
     ad0:	e1 f7       	brne	.-8      	; 0xaca <main+0x1ae>
     ad2:	27 81       	ldd	r18, Z+7	; 0x07
     ad4:	22 95       	swap	r18
     ad6:	2f 70       	andi	r18, 0x0F	; 15
     ad8:	79 c0       	rjmp	.+242    	; 0xbcc <main+0x2b0>
							break;
					case 3:
							m_GET_X(x, data[dataIndex].byte8,  data[dataIndex].byte9,  2);
     ada:	80 91 0e 01 	lds	r24, 0x010E
     ade:	90 91 0f 01 	lds	r25, 0x010F
     ae2:	fc 01       	movw	r30, r24
     ae4:	74 e0       	ldi	r23, 0x04	; 4
     ae6:	ee 0f       	add	r30, r30
     ae8:	ff 1f       	adc	r31, r31
     aea:	7a 95       	dec	r23
     aec:	e1 f7       	brne	.-8      	; 0xae6 <main+0x1ca>
     aee:	e8 1b       	sub	r30, r24
     af0:	f9 0b       	sbc	r31, r25
     af2:	e1 59       	subi	r30, 0x91	; 145
     af4:	f3 4f       	sbci	r31, 0xF3	; 243
     af6:	40 85       	ldd	r20, Z+8	; 0x08
     af8:	24 2f       	mov	r18, r20
     afa:	26 95       	lsr	r18
     afc:	26 95       	lsr	r18
     afe:	30 e0       	ldi	r19, 0x00	; 0
     b00:	87 81       	ldd	r24, Z+7	; 0x07
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	8f 70       	andi	r24, 0x0F	; 15
     b06:	90 70       	andi	r25, 0x00	; 0
     b08:	66 e0       	ldi	r22, 0x06	; 6
     b0a:	88 0f       	add	r24, r24
     b0c:	99 1f       	adc	r25, r25
     b0e:	6a 95       	dec	r22
     b10:	e1 f7       	brne	.-8      	; 0xb0a <main+0x1ee>
     b12:	28 2b       	or	r18, r24
     b14:	39 2b       	or	r19, r25
     b16:	30 93 43 01 	sts	0x0143, r19
     b1a:	20 93 42 01 	sts	0x0142, r18
							m_GET_Y(y, data[dataIndex].byte9,  data[dataIndex].byte10, 2);
     b1e:	84 2f       	mov	r24, r20
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	83 70       	andi	r24, 0x03	; 3
     b24:	90 70       	andi	r25, 0x00	; 0
     b26:	98 2f       	mov	r25, r24
     b28:	88 27       	eor	r24, r24
     b2a:	21 85       	ldd	r18, Z+9	; 0x09
     b2c:	30 e0       	ldi	r19, 0x00	; 0
     b2e:	82 2b       	or	r24, r18
     b30:	93 2b       	or	r25, r19
     b32:	90 93 45 01 	sts	0x0145, r25
     b36:	80 93 44 01 	sts	0x0144, r24
							m_GET_Z(z, data[dataIndex].byte11, data[dataIndex].byte12, 2);
     b3a:	83 85       	ldd	r24, Z+11	; 0x0b
     b3c:	82 95       	swap	r24
     b3e:	86 95       	lsr	r24
     b40:	86 95       	lsr	r24
     b42:	83 70       	andi	r24, 0x03	; 3
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	22 85       	ldd	r18, Z+10	; 0x0a
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	22 0f       	add	r18, r18
     b4c:	33 1f       	adc	r19, r19
     b4e:	22 0f       	add	r18, r18
     b50:	33 1f       	adc	r19, r19
     b52:	3d c0       	rjmp	.+122    	; 0xbce <main+0x2b2>
							break;
					case 0:
							m_GET_X(x, data[dataIndex].byte12, data[dataIndex].byte13, 3);
     b54:	80 91 0e 01 	lds	r24, 0x010E
     b58:	90 91 0f 01 	lds	r25, 0x010F
     b5c:	fc 01       	movw	r30, r24
     b5e:	b4 e0       	ldi	r27, 0x04	; 4
     b60:	ee 0f       	add	r30, r30
     b62:	ff 1f       	adc	r31, r31
     b64:	ba 95       	dec	r27
     b66:	e1 f7       	brne	.-8      	; 0xb60 <main+0x244>
     b68:	e8 1b       	sub	r30, r24
     b6a:	f9 0b       	sbc	r31, r25
     b6c:	e1 59       	subi	r30, 0x91	; 145
     b6e:	f3 4f       	sbci	r31, 0xF3	; 243
     b70:	84 85       	ldd	r24, Z+12	; 0x0c
     b72:	48 2f       	mov	r20, r24
     b74:	42 95       	swap	r20
     b76:	4f 70       	andi	r20, 0x0F	; 15
     b78:	50 e0       	ldi	r21, 0x00	; 0
     b7a:	23 85       	ldd	r18, Z+11	; 0x0b
     b7c:	30 e0       	ldi	r19, 0x00	; 0
     b7e:	2f 73       	andi	r18, 0x3F	; 63
     b80:	30 70       	andi	r19, 0x00	; 0
     b82:	a4 e0       	ldi	r26, 0x04	; 4
     b84:	22 0f       	add	r18, r18
     b86:	33 1f       	adc	r19, r19
     b88:	aa 95       	dec	r26
     b8a:	e1 f7       	brne	.-8      	; 0xb84 <main+0x268>
     b8c:	42 2b       	or	r20, r18
     b8e:	53 2b       	or	r21, r19
     b90:	50 93 43 01 	sts	0x0143, r21
     b94:	40 93 42 01 	sts	0x0142, r20
							m_GET_Y(y, data[dataIndex].byte13, data[dataIndex].byte14, 3);
     b98:	45 85       	ldd	r20, Z+13	; 0x0d
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	8f 70       	andi	r24, 0x0F	; 15
     b9e:	90 70       	andi	r25, 0x00	; 0
     ba0:	76 e0       	ldi	r23, 0x06	; 6
     ba2:	88 0f       	add	r24, r24
     ba4:	99 1f       	adc	r25, r25
     ba6:	7a 95       	dec	r23
     ba8:	e1 f7       	brne	.-8      	; 0xba2 <main+0x286>
     baa:	24 2f       	mov	r18, r20
     bac:	26 95       	lsr	r18
     bae:	26 95       	lsr	r18
     bb0:	30 e0       	ldi	r19, 0x00	; 0
     bb2:	82 2b       	or	r24, r18
     bb4:	93 2b       	or	r25, r19
     bb6:	90 93 45 01 	sts	0x0145, r25
     bba:	80 93 44 01 	sts	0x0144, r24
							m_GET_Z(z, data[dataIndex].byte14, data[dataIndex].byte15, 3);
     bbe:	84 2f       	mov	r24, r20
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	83 70       	andi	r24, 0x03	; 3
     bc4:	90 70       	andi	r25, 0x00	; 0
     bc6:	98 2f       	mov	r25, r24
     bc8:	88 27       	eor	r24, r24
     bca:	26 85       	ldd	r18, Z+14	; 0x0e
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	82 2b       	or	r24, r18
     bd0:	93 2b       	or	r25, r19
     bd2:	90 93 47 01 	sts	0x0147, r25
     bd6:	80 93 46 01 	sts	0x0146, r24
							break;
				}											
		
		        // if the wocket was just connected, confirm the wocket transmission mode 
				if (justconnected == 1)	{
     bda:	80 91 2e 01 	lds	r24, 0x012E
     bde:	81 30       	cpi	r24, 0x01	; 1
     be0:	21 f4       	brne	.+8      	; 0xbea <main+0x2ce>
					_send_wtm();
     be2:	0e 94 52 11 	call	0x22a4	; 0x22a4 <_send_wtm>
					justconnected = 2;
     be6:	10 93 2e 01 	sts	0x012E, r17
				}		

				//Sending raw data: In continous mode all raw data are sent without compressing
				_send_uncompressed_pdu(x, y, z);
     bea:	60 91 44 01 	lds	r22, 0x0144
     bee:	70 91 45 01 	lds	r23, 0x0145
     bf2:	40 91 46 01 	lds	r20, 0x0146
     bf6:	50 91 47 01 	lds	r21, 0x0147
     bfa:	80 91 42 01 	lds	r24, 0x0142
     bfe:	90 91 43 01 	lds	r25, 0x0143
     c02:	0e 94 30 10 	call	0x2060	; 0x2060 <_send_uncompressed_pdu>

				//sample and send the battery level
				battery = _atmega_a2dConvert10bit(ADC7); 
     c06:	87 e0       	ldi	r24, 0x07	; 7
     c08:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
     c0c:	90 93 6a 38 	sts	0x386A, r25
     c10:	80 93 69 38 	sts	0x3869, r24
				//_send_bl(battery);
				_receive_data();
     c14:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_receive_data>
     c18:	bb c1       	rjmp	.+886    	; 0xf90 <main+0x674>
			}
			
			else { //Bursty modes			
				if (connected) {			// check for the BT connection
     c1a:	80 91 29 01 	lds	r24, 0x0129
     c1e:	88 23       	and	r24, r24
     c20:	09 f4       	brne	.+2      	; 0xc24 <main+0x308>
     c22:	b0 c1       	rjmp	.+864    	; 0xf84 <main+0x668>
					if (shutdown_flag == 0)	
     c24:	80 91 32 01 	lds	r24, 0x0132
     c28:	88 23       	and	r24, r24
     c2a:	11 f4       	brne	.+4      	; 0xc30 <main+0x314>
						_greenled_turn_on();
     c2c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_greenled_turn_on>

					if (_wTM == _WTM_Continuous) // Skips sending the recent batch of raw data if transfer mode is changed 
     c30:	80 91 4e 01 	lds	r24, 0x014E
     c34:	88 23       	and	r24, r24
     c36:	09 f4       	brne	.+2      	; 0xc3a <main+0x31e>
     c38:	b4 ce       	rjmp	.-664    	; 0x9a2 <main+0x86>
     c3a:	8f e0       	ldi	r24, 0x0F	; 15
     c3c:	97 e2       	ldi	r25, 0x27	; 39
     c3e:	01 97       	sbiw	r24, 0x01	; 1
     c40:	f1 f7       	brne	.-4      	; 0xc3e <main+0x322>
     c42:	00 c0       	rjmp	.+0      	; 0xc44 <main+0x328>
     c44:	00 00       	nop
						continue;                   					
                   
				    _delay_ms(5);
					_receive_data();
     c46:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_receive_data>
     c4a:	c4 e6       	ldi	r28, 0x64	; 100
     c4c:	d0 e0       	ldi	r29, 0x00	; 0
					Instead, we delay the transmission of the actual data (activity counts or raw data) 
					by sending padding bytes. The decoder software on the phone ignores the (0xff) bytes
					received by the phone.*/

					for (int ixz = 0; (ixz < 100); ixz++) {                                                                                
       					_bluetooth_transmit_uart0_byte(0xff); // The decoder on the phone ignores these packets 
     c4e:	8f ef       	ldi	r24, 0xFF	; 255
     c50:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
							
						if (sampleFlag)
     c54:	80 91 26 01 	lds	r24, 0x0126
     c58:	88 23       	and	r24, r24
     c5a:	11 f0       	breq	.+4      	; 0xc60 <main+0x344>
							do_sampling();
     c5c:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <do_sampling>
     c60:	21 97       	sbiw	r28, 0x01	; 1
					the wockets does not have the capability to allow flow control using RTS/CTS. 
					Instead, we delay the transmission of the actual data (activity counts or raw data) 
					by sending padding bytes. The decoder software on the phone ignores the (0xff) bytes
					received by the phone.*/

					for (int ixz = 0; (ixz < 100); ixz++) {                                                                                
     c62:	a9 f7       	brne	.-22     	; 0xc4e <main+0x332>
							do_sampling();
					} 
				    //------------------------------------------------------------------										
					//_send_sr();			// Send the sampling rate to the phone 				 
					//_send_wtm();		    // Send the wocket transmission mode to the phone					
					battery = _atmega_a2dConvert10bit(ADC7); 
     c64:	87 e0       	ldi	r24, 0x07	; 7
     c66:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
     c6a:	90 93 6a 38 	sts	0x386A, r25
     c6e:	80 93 69 38 	sts	0x3869, r24
					_send_bl(battery);		//sample and send the battery level										
     c72:	0e 94 20 11 	call	0x2240	; 0x2240 <_send_bl>
					_send_acs();			// Send the Activity counts information 
     c76:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <_send_acs>
					
					rawTail = dataIndex;
     c7a:	20 91 0e 01 	lds	r18, 0x010E
     c7e:	30 91 0f 01 	lds	r19, 0x010F
     c82:	30 93 14 01 	sts	0x0114, r19
     c86:	20 93 13 01 	sts	0x0113, r18
					if (batch_counter == (DATA_SIZE - 1)) //in case of memory overflow
     c8a:	80 91 0c 01 	lds	r24, 0x010C
     c8e:	90 91 0d 01 	lds	r25, 0x010D
     c92:	e2 e0       	ldi	r30, 0x02	; 2
     c94:	8d 3e       	cpi	r24, 0xED	; 237
     c96:	9e 07       	cpc	r25, r30
     c98:	31 f4       	brne	.+12     	; 0xca6 <main+0x38a>
						rawHead = dataIndex + 1;
     c9a:	2f 5f       	subi	r18, 0xFF	; 255
     c9c:	3f 4f       	sbci	r19, 0xFF	; 255
     c9e:	30 93 12 01 	sts	0x0112, r19
     ca2:	20 93 11 01 	sts	0x0111, r18
					/*if (rawTail - rawHead >= 0)
						batch_counter = rawTail - rawHead;
					else 
						batch_counter = DATA_SIZE - rawHead - 1 + rawTail;*/
					_send_batch_count(batch_counter);	// Send the number (devided by 4) of raw data packets that are going to be sent 
     ca6:	0e 94 ab 10 	call	0x2156	; 0x2156 <_send_batch_count>
					batch_counter = 0;
     caa:	10 92 0d 01 	sts	0x010D, r1
     cae:	10 92 0c 01 	sts	0x010C, r1
					
					while(rawHead != rawTail) { //Send raw data from Circular buffer
     cb2:	25 c1       	rjmp	.+586    	; 0xefe <main+0x5e2>
					
						m_GET_X(x, data[rawHead].byte1,  data[rawHead].byte2,  0);
     cb4:	fc 01       	movw	r30, r24
     cb6:	54 e0       	ldi	r21, 0x04	; 4
     cb8:	ee 0f       	add	r30, r30
     cba:	ff 1f       	adc	r31, r31
     cbc:	5a 95       	dec	r21
     cbe:	e1 f7       	brne	.-8      	; 0xcb8 <main+0x39c>
     cc0:	e8 1b       	sub	r30, r24
     cc2:	f9 0b       	sbc	r31, r25
     cc4:	e1 59       	subi	r30, 0x91	; 145
     cc6:	f3 4f       	sbci	r31, 0xF3	; 243
     cc8:	61 81       	ldd	r22, Z+1	; 0x01
     cca:	86 2f       	mov	r24, r22
     ccc:	82 95       	swap	r24
     cce:	86 95       	lsr	r24
     cd0:	86 95       	lsr	r24
     cd2:	83 70       	andi	r24, 0x03	; 3
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	20 81       	ld	r18, Z
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	22 0f       	add	r18, r18
     cdc:	33 1f       	adc	r19, r19
     cde:	22 0f       	add	r18, r18
     ce0:	33 1f       	adc	r19, r19
     ce2:	82 2b       	or	r24, r18
     ce4:	93 2b       	or	r25, r19
     ce6:	90 93 43 01 	sts	0x0143, r25
     cea:	80 93 42 01 	sts	0x0142, r24
						m_GET_Y(y, data[rawHead].byte2,  data[rawHead].byte3,  0);
     cee:	42 81       	ldd	r20, Z+2	; 0x02
     cf0:	70 e0       	ldi	r23, 0x00	; 0
     cf2:	6f 73       	andi	r22, 0x3F	; 63
     cf4:	70 70       	andi	r23, 0x00	; 0
     cf6:	b4 e0       	ldi	r27, 0x04	; 4
     cf8:	66 0f       	add	r22, r22
     cfa:	77 1f       	adc	r23, r23
     cfc:	ba 95       	dec	r27
     cfe:	e1 f7       	brne	.-8      	; 0xcf8 <main+0x3dc>
     d00:	24 2f       	mov	r18, r20
     d02:	22 95       	swap	r18
     d04:	2f 70       	andi	r18, 0x0F	; 15
     d06:	30 e0       	ldi	r19, 0x00	; 0
     d08:	62 2b       	or	r22, r18
     d0a:	73 2b       	or	r23, r19
     d0c:	70 93 45 01 	sts	0x0145, r23
     d10:	60 93 44 01 	sts	0x0144, r22
						m_GET_Z(z, data[rawHead].byte3,  data[rawHead].byte4,  0);
     d14:	50 e0       	ldi	r21, 0x00	; 0
     d16:	4f 70       	andi	r20, 0x0F	; 15
     d18:	50 70       	andi	r21, 0x00	; 0
     d1a:	a6 e0       	ldi	r26, 0x06	; 6
     d1c:	44 0f       	add	r20, r20
     d1e:	55 1f       	adc	r21, r21
     d20:	aa 95       	dec	r26
     d22:	e1 f7       	brne	.-8      	; 0xd1c <main+0x400>
     d24:	23 81       	ldd	r18, Z+3	; 0x03
     d26:	26 95       	lsr	r18
     d28:	26 95       	lsr	r18
     d2a:	30 e0       	ldi	r19, 0x00	; 0
     d2c:	42 2b       	or	r20, r18
     d2e:	53 2b       	or	r21, r19
     d30:	50 93 47 01 	sts	0x0147, r21
     d34:	40 93 46 01 	sts	0x0146, r20
						_send_pdu(x, y, z);
     d38:	0e 94 f6 00 	call	0x1ec	; 0x1ec <_send_pdu>

						m_GET_X(x, data[rawHead].byte4,  data[rawHead].byte5,  1);
     d3c:	80 91 11 01 	lds	r24, 0x0111
     d40:	90 91 12 01 	lds	r25, 0x0112
     d44:	fc 01       	movw	r30, r24
     d46:	74 e0       	ldi	r23, 0x04	; 4
     d48:	ee 0f       	add	r30, r30
     d4a:	ff 1f       	adc	r31, r31
     d4c:	7a 95       	dec	r23
     d4e:	e1 f7       	brne	.-8      	; 0xd48 <main+0x42c>
     d50:	e8 1b       	sub	r30, r24
     d52:	f9 0b       	sbc	r31, r25
     d54:	e1 59       	subi	r30, 0x91	; 145
     d56:	f3 4f       	sbci	r31, 0xF3	; 243
     d58:	83 81       	ldd	r24, Z+3	; 0x03
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	83 70       	andi	r24, 0x03	; 3
     d5e:	90 70       	andi	r25, 0x00	; 0
     d60:	98 2f       	mov	r25, r24
     d62:	88 27       	eor	r24, r24
     d64:	24 81       	ldd	r18, Z+4	; 0x04
     d66:	30 e0       	ldi	r19, 0x00	; 0
     d68:	82 2b       	or	r24, r18
     d6a:	93 2b       	or	r25, r19
     d6c:	90 93 43 01 	sts	0x0143, r25
     d70:	80 93 42 01 	sts	0x0142, r24
						m_GET_Y(y, data[rawHead].byte6,  data[rawHead].byte7,  1);
     d74:	46 81       	ldd	r20, Z+6	; 0x06
     d76:	64 2f       	mov	r22, r20
     d78:	62 95       	swap	r22
     d7a:	66 95       	lsr	r22
     d7c:	66 95       	lsr	r22
     d7e:	63 70       	andi	r22, 0x03	; 3
     d80:	70 e0       	ldi	r23, 0x00	; 0
     d82:	25 81       	ldd	r18, Z+5	; 0x05
     d84:	30 e0       	ldi	r19, 0x00	; 0
     d86:	22 0f       	add	r18, r18
     d88:	33 1f       	adc	r19, r19
     d8a:	22 0f       	add	r18, r18
     d8c:	33 1f       	adc	r19, r19
     d8e:	62 2b       	or	r22, r18
     d90:	73 2b       	or	r23, r19
     d92:	70 93 45 01 	sts	0x0145, r23
     d96:	60 93 44 01 	sts	0x0144, r22
						m_GET_Z(z, data[rawHead].byte7,  data[rawHead].byte8,  1);
     d9a:	50 e0       	ldi	r21, 0x00	; 0
     d9c:	4f 73       	andi	r20, 0x3F	; 63
     d9e:	50 70       	andi	r21, 0x00	; 0
     da0:	34 e0       	ldi	r19, 0x04	; 4
     da2:	44 0f       	add	r20, r20
     da4:	55 1f       	adc	r21, r21
     da6:	3a 95       	dec	r19
     da8:	e1 f7       	brne	.-8      	; 0xda2 <main+0x486>
     daa:	27 81       	ldd	r18, Z+7	; 0x07
     dac:	22 95       	swap	r18
     dae:	2f 70       	andi	r18, 0x0F	; 15
     db0:	30 e0       	ldi	r19, 0x00	; 0
     db2:	42 2b       	or	r20, r18
     db4:	53 2b       	or	r21, r19
     db6:	50 93 47 01 	sts	0x0147, r21
     dba:	40 93 46 01 	sts	0x0146, r20
						_send_pdu(x, y, z);
     dbe:	0e 94 f6 00 	call	0x1ec	; 0x1ec <_send_pdu>

						m_GET_X(x, data[rawHead].byte8,  data[rawHead].byte9,  2);
     dc2:	80 91 11 01 	lds	r24, 0x0111
     dc6:	90 91 12 01 	lds	r25, 0x0112
     dca:	fc 01       	movw	r30, r24
     dcc:	24 e0       	ldi	r18, 0x04	; 4
     dce:	ee 0f       	add	r30, r30
     dd0:	ff 1f       	adc	r31, r31
     dd2:	2a 95       	dec	r18
     dd4:	e1 f7       	brne	.-8      	; 0xdce <main+0x4b2>
     dd6:	e8 1b       	sub	r30, r24
     dd8:	f9 0b       	sbc	r31, r25
     dda:	e1 59       	subi	r30, 0x91	; 145
     ddc:	f3 4f       	sbci	r31, 0xF3	; 243
     dde:	60 85       	ldd	r22, Z+8	; 0x08
     de0:	86 2f       	mov	r24, r22
     de2:	86 95       	lsr	r24
     de4:	86 95       	lsr	r24
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	27 81       	ldd	r18, Z+7	; 0x07
     dea:	30 e0       	ldi	r19, 0x00	; 0
     dec:	2f 70       	andi	r18, 0x0F	; 15
     dee:	30 70       	andi	r19, 0x00	; 0
     df0:	b6 e0       	ldi	r27, 0x06	; 6
     df2:	22 0f       	add	r18, r18
     df4:	33 1f       	adc	r19, r19
     df6:	ba 95       	dec	r27
     df8:	e1 f7       	brne	.-8      	; 0xdf2 <main+0x4d6>
     dfa:	82 2b       	or	r24, r18
     dfc:	93 2b       	or	r25, r19
     dfe:	90 93 43 01 	sts	0x0143, r25
     e02:	80 93 42 01 	sts	0x0142, r24
						m_GET_Y(y, data[rawHead].byte9,  data[rawHead].byte10, 2);
     e06:	70 e0       	ldi	r23, 0x00	; 0
     e08:	63 70       	andi	r22, 0x03	; 3
     e0a:	70 70       	andi	r23, 0x00	; 0
     e0c:	76 2f       	mov	r23, r22
     e0e:	66 27       	eor	r22, r22
     e10:	21 85       	ldd	r18, Z+9	; 0x09
     e12:	30 e0       	ldi	r19, 0x00	; 0
     e14:	62 2b       	or	r22, r18
     e16:	73 2b       	or	r23, r19
     e18:	70 93 45 01 	sts	0x0145, r23
     e1c:	60 93 44 01 	sts	0x0144, r22
						m_GET_Z(z, data[rawHead].byte11, data[rawHead].byte12, 2);
     e20:	43 85       	ldd	r20, Z+11	; 0x0b
     e22:	42 95       	swap	r20
     e24:	46 95       	lsr	r20
     e26:	46 95       	lsr	r20
     e28:	43 70       	andi	r20, 0x03	; 3
     e2a:	50 e0       	ldi	r21, 0x00	; 0
     e2c:	22 85       	ldd	r18, Z+10	; 0x0a
     e2e:	30 e0       	ldi	r19, 0x00	; 0
     e30:	22 0f       	add	r18, r18
     e32:	33 1f       	adc	r19, r19
     e34:	22 0f       	add	r18, r18
     e36:	33 1f       	adc	r19, r19
     e38:	42 2b       	or	r20, r18
     e3a:	53 2b       	or	r21, r19
     e3c:	50 93 47 01 	sts	0x0147, r21
     e40:	40 93 46 01 	sts	0x0146, r20
						_send_pdu(x, y, z);
     e44:	0e 94 f6 00 	call	0x1ec	; 0x1ec <_send_pdu>

						m_GET_X(x, data[rawHead].byte12, data[rawHead].byte13, 3);
     e48:	80 91 11 01 	lds	r24, 0x0111
     e4c:	90 91 12 01 	lds	r25, 0x0112
     e50:	fc 01       	movw	r30, r24
     e52:	54 e0       	ldi	r21, 0x04	; 4
     e54:	ee 0f       	add	r30, r30
     e56:	ff 1f       	adc	r31, r31
     e58:	5a 95       	dec	r21
     e5a:	e1 f7       	brne	.-8      	; 0xe54 <main+0x538>
     e5c:	e8 1b       	sub	r30, r24
     e5e:	f9 0b       	sbc	r31, r25
     e60:	e1 59       	subi	r30, 0x91	; 145
     e62:	f3 4f       	sbci	r31, 0xF3	; 243
     e64:	64 85       	ldd	r22, Z+12	; 0x0c
     e66:	86 2f       	mov	r24, r22
     e68:	82 95       	swap	r24
     e6a:	8f 70       	andi	r24, 0x0F	; 15
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	23 85       	ldd	r18, Z+11	; 0x0b
     e70:	30 e0       	ldi	r19, 0x00	; 0
     e72:	2f 73       	andi	r18, 0x3F	; 63
     e74:	30 70       	andi	r19, 0x00	; 0
     e76:	44 e0       	ldi	r20, 0x04	; 4
     e78:	22 0f       	add	r18, r18
     e7a:	33 1f       	adc	r19, r19
     e7c:	4a 95       	dec	r20
     e7e:	e1 f7       	brne	.-8      	; 0xe78 <main+0x55c>
     e80:	82 2b       	or	r24, r18
     e82:	93 2b       	or	r25, r19
     e84:	90 93 43 01 	sts	0x0143, r25
     e88:	80 93 42 01 	sts	0x0142, r24
						m_GET_Y(y, data[rawHead].byte13, data[rawHead].byte14, 3);
     e8c:	45 85       	ldd	r20, Z+13	; 0x0d
     e8e:	70 e0       	ldi	r23, 0x00	; 0
     e90:	6f 70       	andi	r22, 0x0F	; 15
     e92:	70 70       	andi	r23, 0x00	; 0
     e94:	36 e0       	ldi	r19, 0x06	; 6
     e96:	66 0f       	add	r22, r22
     e98:	77 1f       	adc	r23, r23
     e9a:	3a 95       	dec	r19
     e9c:	e1 f7       	brne	.-8      	; 0xe96 <main+0x57a>
     e9e:	24 2f       	mov	r18, r20
     ea0:	26 95       	lsr	r18
     ea2:	26 95       	lsr	r18
     ea4:	30 e0       	ldi	r19, 0x00	; 0
     ea6:	62 2b       	or	r22, r18
     ea8:	73 2b       	or	r23, r19
     eaa:	70 93 45 01 	sts	0x0145, r23
     eae:	60 93 44 01 	sts	0x0144, r22
						m_GET_Z(z, data[rawHead].byte14, data[rawHead].byte15, 3);
     eb2:	50 e0       	ldi	r21, 0x00	; 0
     eb4:	43 70       	andi	r20, 0x03	; 3
     eb6:	50 70       	andi	r21, 0x00	; 0
     eb8:	54 2f       	mov	r21, r20
     eba:	44 27       	eor	r20, r20
     ebc:	26 85       	ldd	r18, Z+14	; 0x0e
     ebe:	30 e0       	ldi	r19, 0x00	; 0
     ec0:	42 2b       	or	r20, r18
     ec2:	53 2b       	or	r21, r19
     ec4:	50 93 47 01 	sts	0x0147, r21
     ec8:	40 93 46 01 	sts	0x0146, r20
						_send_pdu(x, y, z);
     ecc:	0e 94 f6 00 	call	0x1ec	; 0x1ec <_send_pdu>

						rawHead++;
     ed0:	80 91 11 01 	lds	r24, 0x0111
     ed4:	90 91 12 01 	lds	r25, 0x0112
     ed8:	01 96       	adiw	r24, 0x01	; 1
     eda:	90 93 12 01 	sts	0x0112, r25
     ede:	80 93 11 01 	sts	0x0111, r24

						if (rawHead == DATA_SIZE)
     ee2:	f2 e0       	ldi	r31, 0x02	; 2
     ee4:	8e 3e       	cpi	r24, 0xEE	; 238
     ee6:	9f 07       	cpc	r25, r31
     ee8:	21 f4       	brne	.+8      	; 0xef2 <main+0x5d6>
							rawHead = 0;
     eea:	10 92 12 01 	sts	0x0112, r1
     eee:	10 92 11 01 	sts	0x0111, r1

						//_receive_data();

						if (sampleFlag)
     ef2:	80 91 26 01 	lds	r24, 0x0126
     ef6:	88 23       	and	r24, r24
     ef8:	11 f0       	breq	.+4      	; 0xefe <main+0x5e2>
							do_sampling();							
     efa:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <do_sampling>
					else 
						batch_counter = DATA_SIZE - rawHead - 1 + rawTail;*/
					_send_batch_count(batch_counter);	// Send the number (devided by 4) of raw data packets that are going to be sent 
					batch_counter = 0;
					
					while(rawHead != rawTail) { //Send raw data from Circular buffer
     efe:	80 91 11 01 	lds	r24, 0x0111
     f02:	90 91 12 01 	lds	r25, 0x0112
     f06:	20 91 13 01 	lds	r18, 0x0113
     f0a:	30 91 14 01 	lds	r19, 0x0114
     f0e:	82 17       	cp	r24, r18
     f10:	93 07       	cpc	r25, r19
     f12:	09 f0       	breq	.+2      	; 0xf16 <main+0x5fa>
     f14:	cf ce       	rjmp	.-610    	; 0xcb4 <main+0x398>

						if (sampleFlag)
							do_sampling();							
					}					
					
					_send_end_batch();	//tell phone/PC that all data for this minute has been sent 
     f16:	0e 94 3c 11 	call	0x2278	; 0x2278 <_send_end_batch>
					//------------------------------------------------------------------

					seconds_passed = 0;
     f1a:	10 92 28 01 	sts	0x0128, r1
     f1e:	10 92 27 01 	sts	0x0127, r1
					while (seconds_passed < 400) {//The delay provided here helps to not lose the sent data from the phone
     f22:	13 c0       	rjmp	.+38     	; 0xf4a <main+0x62e>
     f24:	ef e0       	ldi	r30, 0x0F	; 15
     f26:	f7 e2       	ldi	r31, 0x27	; 39
     f28:	31 97       	sbiw	r30, 0x01	; 1
     f2a:	f1 f7       	brne	.-4      	; 0xf28 <main+0x60c>
     f2c:	00 c0       	rjmp	.+0      	; 0xf2e <main+0x612>
     f2e:	00 00       	nop
						_delay_ms(5);
						seconds_passed++;
     f30:	01 96       	adiw	r24, 0x01	; 1
     f32:	90 93 28 01 	sts	0x0128, r25
     f36:	80 93 27 01 	sts	0x0127, r24
						_receive_data();
     f3a:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_receive_data>

						if (sampleFlag)
     f3e:	80 91 26 01 	lds	r24, 0x0126
     f42:	88 23       	and	r24, r24
     f44:	11 f0       	breq	.+4      	; 0xf4a <main+0x62e>
							do_sampling();
     f46:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <do_sampling>
					
					_send_end_batch();	//tell phone/PC that all data for this minute has been sent 
					//------------------------------------------------------------------

					seconds_passed = 0;
					while (seconds_passed < 400) {//The delay provided here helps to not lose the sent data from the phone
     f4a:	80 91 27 01 	lds	r24, 0x0127
     f4e:	90 91 28 01 	lds	r25, 0x0128
     f52:	f1 e0       	ldi	r31, 0x01	; 1
     f54:	80 39       	cpi	r24, 0x90	; 144
     f56:	9f 07       	cpc	r25, r31
     f58:	28 f3       	brcs	.-54     	; 0xf24 <main+0x608>
						if (sampleFlag)
							do_sampling();
					} 

					//Don't turn off the radio if a request to switch mode has been received
					if ((_wTM == _WTM_Continuous) && (shutdown_flag == 0))
     f5a:	80 91 4e 01 	lds	r24, 0x014E
     f5e:	88 23       	and	r24, r24
     f60:	39 f4       	brne	.+14     	; 0xf70 <main+0x654>
     f62:	80 91 32 01 	lds	r24, 0x0132
     f66:	88 23       	and	r24, r24
     f68:	19 f4       	brne	.+6      	; 0xf70 <main+0x654>
						_bluetooth_turn_on();	
     f6a:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <_bluetooth_turn_on>
     f6e:	02 c0       	rjmp	.+4      	; 0xf74 <main+0x658>
					else
						_bluetooth_turn_off();		
     f70:	0e 94 de 0a 	call	0x15bc	; 0x15bc <_bluetooth_turn_off>
					
					command_counter = 0;
     f74:	10 92 37 01 	sts	0x0137, r1
					seconds_disconnected = 0;
     f78:	10 92 2b 01 	sts	0x012B, r1
     f7c:	10 92 2a 01 	sts	0x012A, r1
					_greenled_turn_off();
     f80:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>

				} // End if (connected)
				if (sampleFlag)
     f84:	80 91 26 01 	lds	r24, 0x0126
     f88:	88 23       	and	r24, r24
     f8a:	11 f0       	breq	.+4      	; 0xf90 <main+0x674>
					do_sampling();
     f8c:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <do_sampling>

			} // End else (_wTM==_WTM_Continuous) => _wTM is bursty 

			_atmega_adc_turn_off();
     f90:	0e 94 bf 09 	call	0x137e	; 0x137e <_atmega_adc_turn_off>
			power_adc_disable();
     f94:	80 91 64 00 	lds	r24, 0x0064
     f98:	81 60       	ori	r24, 0x01	; 1
     f9a:	80 93 64 00 	sts	0x0064, r24

			connected = 0;			
     f9e:	10 92 29 01 	sts	0x0129, r1
		}// Endof the First if (sampleFlag)	
		
		   
			cli();				// Clear interruptions and set the system to sleep mode
     fa2:	f8 94       	cli
			set_sleep_mode(SLEEP_MODE_IDLE);
     fa4:	83 b7       	in	r24, 0x33	; 51
     fa6:	81 7f       	andi	r24, 0xF1	; 241
     fa8:	83 bf       	out	0x33, r24	; 51
			// Built in functionality to enable interrupts and shutdown of the cpu to save power 
    		sleep_enable();		// sleep.h 
     faa:	83 b7       	in	r24, 0x33	; 51
     fac:	81 60       	ori	r24, 0x01	; 1
     fae:	83 bf       	out	0x33, r24	; 51
    		sei();				// interrupt.h
     fb0:	78 94       	sei
    		sleep_cpu();		// sleep.h 
     fb2:	88 95       	sleep
    		sleep_disable();	// sleep.h 	
     fb4:	83 b7       	in	r24, 0x33	; 51
     fb6:	8e 7f       	andi	r24, 0xFE	; 254
     fb8:	83 bf       	out	0x33, r24	; 51
     fba:	f3 cc       	rjmp	.-1562   	; 0x9a2 <main+0x86>

00000fbc <__vector_11>:



//------------------------ Interrupt service routine for Timer 2------------------------------------
ISR(TIMER2_OVF_vect)
{	
     fbc:	1f 92       	push	r1
     fbe:	0f 92       	push	r0
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	0f 92       	push	r0
     fc4:	0b b6       	in	r0, 0x3b	; 59
     fc6:	0f 92       	push	r0
     fc8:	11 24       	eor	r1, r1
     fca:	1f 93       	push	r17
     fcc:	2f 93       	push	r18
     fce:	3f 93       	push	r19
     fd0:	4f 93       	push	r20
     fd2:	5f 93       	push	r21
     fd4:	6f 93       	push	r22
     fd6:	7f 93       	push	r23
     fd8:	8f 93       	push	r24
     fda:	9f 93       	push	r25
     fdc:	af 93       	push	r26
     fde:	bf 93       	push	r27
     fe0:	ef 93       	push	r30
     fe2:	ff 93       	push	r31
	if (_is_docked()) // Has the wocket been connected to the charger/programmer more than one minitue?		
     fe4:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <_is_docked>
     fe8:	20 91 2f 01 	lds	r18, 0x012F
     fec:	88 23       	and	r24, r24
     fee:	09 f4       	brne	.+2      	; 0xff2 <__vector_11+0x36>
     ff0:	43 c0       	rjmp	.+134    	; 0x1078 <__vector_11+0xbc>
	{
		dockcounter++;		 
     ff2:	80 91 30 01 	lds	r24, 0x0130
     ff6:	90 91 31 01 	lds	r25, 0x0131
     ffa:	01 96       	adiw	r24, 0x01	; 1
     ffc:	90 93 31 01 	sts	0x0131, r25
    1000:	80 93 30 01 	sts	0x0130, r24
		if ((!isdocked)&& (dockcounter > (_SAMPLING_RATE * 60))){				
    1004:	22 23       	and	r18, r18
    1006:	09 f0       	breq	.+2      	; 0x100a <__vector_11+0x4e>
    1008:	59 c1       	rjmp	.+690    	; 0x12bc <__vector_11+0x300>
    100a:	30 91 06 01 	lds	r19, 0x0106
    100e:	2c e3       	ldi	r18, 0x3C	; 60
    1010:	32 9f       	mul	r19, r18
    1012:	90 01       	movw	r18, r0
    1014:	11 24       	eor	r1, r1
    1016:	28 17       	cp	r18, r24
    1018:	39 07       	cpc	r19, r25
    101a:	08 f0       	brcs	.+2      	; 0x101e <__vector_11+0x62>
    101c:	4f c1       	rjmp	.+670    	; 0x12bc <__vector_11+0x300>
			ci   = 0;
    101e:	10 92 20 01 	sts	0x0120, r1
    1022:	10 92 1f 01 	sts	0x011F, r1
			si   = 0;
    1026:	10 92 22 01 	sts	0x0122, r1
    102a:	10 92 21 01 	sts	0x0121, r1
			cseq = 0; 
    102e:	10 92 18 01 	sts	0x0118, r1
    1032:	10 92 17 01 	sts	0x0117, r1
			sseq = 0;		
    1036:	10 92 1a 01 	sts	0x011A, r1
    103a:	10 92 19 01 	sts	0x0119, r1
			_bluetooth_turn_off();
    103e:	0e 94 de 0a 	call	0x15bc	; 0x15bc <_bluetooth_turn_off>
			isdocked = 1;
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	80 93 2f 01 	sts	0x012F, r24
			if (shutdown_flag == 1){
    1048:	80 91 32 01 	lds	r24, 0x0132
    104c:	81 30       	cpi	r24, 0x01	; 1
    104e:	09 f0       	breq	.+2      	; 0x1052 <__vector_11+0x96>
    1050:	35 c1       	rjmp	.+618    	; 0x12bc <__vector_11+0x300>
				//_wocket_initialize();
				_bluetooth_turn_on();
    1052:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <_bluetooth_turn_on>
				shutdown_flag = 0;
    1056:	10 92 32 01 	sts	0x0132, r1
				_yellowled_turn_on();
    105a:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <_yellowled_turn_on>
    105e:	88 ec       	ldi	r24, 0xC8	; 200
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	ef e1       	ldi	r30, 0x1F	; 31
    1064:	fe e4       	ldi	r31, 0x4E	; 78
    1066:	31 97       	sbiw	r30, 0x01	; 1
    1068:	f1 f7       	brne	.-4      	; 0x1066 <__vector_11+0xaa>
    106a:	00 c0       	rjmp	.+0      	; 0x106c <__vector_11+0xb0>
    106c:	00 00       	nop
    106e:	01 97       	sbiw	r24, 0x01	; 1
				for(int i = 0;(i < 200);i++)
    1070:	c1 f7       	brne	.-16     	; 0x1062 <__vector_11+0xa6>
					_delay_ms(10);
				_yellowled_turn_off();
    1072:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>
    1076:	22 c1       	rjmp	.+580    	; 0x12bc <__vector_11+0x300>
			}
							
		}
		return;
	} else {
		dockcounter = 0;
    1078:	10 92 31 01 	sts	0x0131, r1
    107c:	10 92 30 01 	sts	0x0130, r1
		if (isdocked) {
    1080:	22 23       	and	r18, r18
    1082:	21 f0       	breq	.+8      	; 0x108c <__vector_11+0xd0>
			_bluetooth_turn_on();
    1084:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <_bluetooth_turn_on>
			isdocked = 0;			
    1088:	10 92 2f 01 	sts	0x012F, r1
		}
	}

	if ((connected == 0)&& (shutdown_flag == 0)){
    108c:	80 91 29 01 	lds	r24, 0x0129
    1090:	88 23       	and	r24, r24
    1092:	21 f5       	brne	.+72     	; 0x10dc <__vector_11+0x120>
    1094:	80 91 32 01 	lds	r24, 0x0132
    1098:	88 23       	and	r24, r24
    109a:	01 f5       	brne	.+64     	; 0x10dc <__vector_11+0x120>
		blink_counter++;
    109c:	80 91 65 38 	lds	r24, 0x3865
    10a0:	90 91 66 38 	lds	r25, 0x3866
    10a4:	01 96       	adiw	r24, 0x01	; 1
    10a6:	90 93 66 38 	sts	0x3866, r25
    10aa:	80 93 65 38 	sts	0x3865, r24
		if (blink_counter == (_SAMPLING_RATE * 5))		// ON period
    10ae:	30 91 06 01 	lds	r19, 0x0106
    10b2:	25 e0       	ldi	r18, 0x05	; 5
    10b4:	32 9f       	mul	r19, r18
    10b6:	90 01       	movw	r18, r0
    10b8:	11 24       	eor	r1, r1
    10ba:	82 17       	cp	r24, r18
    10bc:	93 07       	cpc	r25, r19
    10be:	19 f4       	brne	.+6      	; 0x10c6 <__vector_11+0x10a>
			_greenled_turn_on();
    10c0:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_greenled_turn_on>
    10c4:	0b c0       	rjmp	.+22     	; 0x10dc <__vector_11+0x120>
		else if (blink_counter == ((_SAMPLING_RATE * 5) + 10)) { 	// OFF period
    10c6:	26 5f       	subi	r18, 0xF6	; 246
    10c8:	3f 4f       	sbci	r19, 0xFF	; 255
    10ca:	82 17       	cp	r24, r18
    10cc:	93 07       	cpc	r25, r19
    10ce:	31 f4       	brne	.+12     	; 0x10dc <__vector_11+0x120>
			_greenled_turn_off();
    10d0:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>
			blink_counter = 0;
    10d4:	10 92 66 38 	sts	0x3866, r1
    10d8:	10 92 65 38 	sts	0x3865, r1
		}
	}

	// Adjusting the counter for the sampling rate 
	//REFER to _wocket_initialize_timer2_interrupt in the wocket.c	
 	if (interrupt_reps == 0) {	
    10dc:	80 91 2d 01 	lds	r24, 0x012D
    10e0:	88 23       	and	r24, r24
    10e2:	89 f4       	brne	.+34     	; 0x1106 <__vector_11+0x14a>
		interrupt_reps = _wTCNT2_reps;
    10e4:	80 91 07 01 	lds	r24, 0x0107
    10e8:	80 93 2d 01 	sts	0x012D, r24
		TCNT2 = _wTCNT2;
    10ec:	80 91 4c 01 	lds	r24, 0x014C
    10f0:	80 93 b2 00 	sts	0x00B2, r24
		interrupt_reps--;
		return;
	}
	
	// When this flag is set, accelerometer should be sampled
	sampleFlag = 1;
    10f4:	11 e0       	ldi	r17, 0x01	; 1
    10f6:	10 93 26 01 	sts	0x0126, r17

	if (_wTM == _WTM_Continuous) {
    10fa:	80 91 4e 01 	lds	r24, 0x014E
    10fe:	88 23       	and	r24, r24
    1100:	09 f0       	breq	.+2      	; 0x1104 <__vector_11+0x148>
    1102:	52 c0       	rjmp	.+164    	; 0x11a8 <__vector_11+0x1ec>
    1104:	0f c0       	rjmp	.+30     	; 0x1124 <__vector_11+0x168>
 	if (interrupt_reps == 0) {	
		interrupt_reps = _wTCNT2_reps;
		TCNT2 = _wTCNT2;
	}
	else { //otherwise wait
		if (interrupt_reps == 1)	
    1106:	81 30       	cpi	r24, 0x01	; 1
    1108:	19 f4       	brne	.+6      	; 0x1110 <__vector_11+0x154>
			TCNT2 = _wTCNT2_last;	
    110a:	80 91 4d 01 	lds	r24, 0x014D
    110e:	02 c0       	rjmp	.+4      	; 0x1114 <__vector_11+0x158>
		else		
			TCNT2 = _wTCNT2;					
    1110:	80 91 4c 01 	lds	r24, 0x014C
    1114:	80 93 b2 00 	sts	0x00B2, r24
		interrupt_reps--;
    1118:	80 91 2d 01 	lds	r24, 0x012D
    111c:	81 50       	subi	r24, 0x01	; 1
    111e:	80 93 2d 01 	sts	0x012D, r24
		return;
    1122:	cc c0       	rjmp	.+408    	; 0x12bc <__vector_11+0x300>
	
	// When this flag is set, accelerometer should be sampled
	sampleFlag = 1;

	if (_wTM == _WTM_Continuous) {
		_wPC++;
    1124:	80 91 4f 01 	lds	r24, 0x014F
    1128:	90 91 50 01 	lds	r25, 0x0150
    112c:	a0 91 51 01 	lds	r26, 0x0151
    1130:	b0 91 52 01 	lds	r27, 0x0152
    1134:	01 96       	adiw	r24, 0x01	; 1
    1136:	a1 1d       	adc	r26, r1
    1138:	b1 1d       	adc	r27, r1
    113a:	80 93 4f 01 	sts	0x014F, r24
    113e:	90 93 50 01 	sts	0x0150, r25
    1142:	a0 93 51 01 	sts	0x0151, r26
    1146:	b0 93 52 01 	sts	0x0152, r27
		// Section of the code to indicate that the wocket got connected
		if (!_bluetooth_is_connected()){
    114a:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <_bluetooth_is_connected>
    114e:	88 23       	and	r24, r24
    1150:	29 f4       	brne	.+10     	; 0x115c <__vector_11+0x1a0>
			justconnected = 0;
    1152:	10 92 2e 01 	sts	0x012E, r1
			compress = 0;
    1156:	10 92 25 01 	sts	0x0125, r1
			return;		
    115a:	b0 c0       	rjmp	.+352    	; 0x12bc <__vector_11+0x300>
		}
		else if (justconnected == 0)
    115c:	80 91 2e 01 	lds	r24, 0x012E
    1160:	88 23       	and	r24, r24
    1162:	11 f4       	brne	.+4      	; 0x1168 <__vector_11+0x1ac>
			justconnected = 1;
    1164:	10 93 2e 01 	sts	0x012E, r17

		if (_wShutdownTimer != _DEFAULT_SHUTDOWN)
    1168:	80 91 5b 01 	lds	r24, 0x015B
    116c:	90 91 5c 01 	lds	r25, 0x015C
    1170:	a0 91 5d 01 	lds	r26, 0x015D
    1174:	b0 91 5e 01 	lds	r27, 0x015E
    1178:	20 91 57 01 	lds	r18, 0x0157
    117c:	30 91 58 01 	lds	r19, 0x0158
    1180:	40 91 59 01 	lds	r20, 0x0159
    1184:	50 91 5a 01 	lds	r21, 0x015A
    1188:	28 17       	cp	r18, r24
    118a:	39 07       	cpc	r19, r25
    118c:	4a 07       	cpc	r20, r26
    118e:	5b 07       	cpc	r21, r27
    1190:	41 f0       	breq	.+16     	; 0x11a2 <__vector_11+0x1e6>
			_wShutdownTimer  = _DEFAULT_SHUTDOWN;
    1192:	80 93 57 01 	sts	0x0157, r24
    1196:	90 93 58 01 	sts	0x0158, r25
    119a:	a0 93 59 01 	sts	0x0159, r26
    119e:	b0 93 5a 01 	sts	0x015A, r27

		_receive_data();
    11a2:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_receive_data>
    11a6:	8a c0       	rjmp	.+276    	; 0x12bc <__vector_11+0x300>
	}

	else if (_wTM == _WTM_Burst_60)	{
    11a8:	82 30       	cpi	r24, 0x02	; 2
    11aa:	09 f0       	breq	.+2      	; 0x11ae <__vector_11+0x1f2>
    11ac:	87 c0       	rjmp	.+270    	; 0x12bc <__vector_11+0x300>
		//This only works for Timer1,doesn't have any effect for this timer (Timer2)
		if (_wPDT != 0)
    11ae:	80 91 85 38 	lds	r24, 0x3885
    11b2:	88 23       	and	r24, r24
    11b4:	99 f0       	breq	.+38     	; 0x11dc <__vector_11+0x220>
			_wShutdownTimer--;
    11b6:	80 91 57 01 	lds	r24, 0x0157
    11ba:	90 91 58 01 	lds	r25, 0x0158
    11be:	a0 91 59 01 	lds	r26, 0x0159
    11c2:	b0 91 5a 01 	lds	r27, 0x015A
    11c6:	01 97       	sbiw	r24, 0x01	; 1
    11c8:	a1 09       	sbc	r26, r1
    11ca:	b1 09       	sbc	r27, r1
    11cc:	80 93 57 01 	sts	0x0157, r24
    11d0:	90 93 58 01 	sts	0x0158, r25
    11d4:	a0 93 59 01 	sts	0x0159, r26
    11d8:	b0 93 5a 01 	sts	0x015A, r27

		_wPC++;
    11dc:	80 91 4f 01 	lds	r24, 0x014F
    11e0:	90 91 50 01 	lds	r25, 0x0150
    11e4:	a0 91 51 01 	lds	r26, 0x0151
    11e8:	b0 91 52 01 	lds	r27, 0x0152
    11ec:	01 96       	adiw	r24, 0x01	; 1
    11ee:	a1 1d       	adc	r26, r1
    11f0:	b1 1d       	adc	r27, r1
    11f2:	80 93 4f 01 	sts	0x014F, r24
    11f6:	90 93 50 01 	sts	0x0150, r25
    11fa:	a0 93 51 01 	sts	0x0151, r26
    11fe:	b0 93 52 01 	sts	0x0152, r27
		
		 // Turns the Bluetooth ON approximately every 45 seconds after the previous transmission 
		if (!_bluetooth_is_connected()) {			
    1202:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <_bluetooth_is_connected>
    1206:	88 23       	and	r24, r24
    1208:	99 f5       	brne	.+102    	; 0x1270 <__vector_11+0x2b4>
			compress = 0; 
    120a:	10 92 25 01 	sts	0x0125, r1

			if (seconds_disconnected < (_SAMPLING_RATE * 45)) // 45 Sec
    120e:	80 91 2a 01 	lds	r24, 0x012A
    1212:	90 91 2b 01 	lds	r25, 0x012B
    1216:	30 91 06 01 	lds	r19, 0x0106
    121a:	2d e2       	ldi	r18, 0x2D	; 45
    121c:	32 9f       	mul	r19, r18
    121e:	90 01       	movw	r18, r0
    1220:	11 24       	eor	r1, r1
    1222:	82 17       	cp	r24, r18
    1224:	93 07       	cpc	r25, r19
    1226:	30 f4       	brcc	.+12     	; 0x1234 <__vector_11+0x278>
				seconds_disconnected++;
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	90 93 2b 01 	sts	0x012B, r25
    122e:	80 93 2a 01 	sts	0x012A, r24
    1232:	44 c0       	rjmp	.+136    	; 0x12bc <__vector_11+0x300>
			else if (seconds_disconnected == (_SAMPLING_RATE * 45))	{
    1234:	82 17       	cp	r24, r18
    1236:	93 07       	cpc	r25, r19
    1238:	09 f0       	breq	.+2      	; 0x123c <__vector_11+0x280>
    123a:	40 c0       	rjmp	.+128    	; 0x12bc <__vector_11+0x300>
				//before turning on the bluetooth make sure the receive buffer is flushed
				_receive_uart0_flush();
    123c:	0e 94 03 0b 	call	0x1606	; 0x1606 <_receive_uart0_flush>
				if (shutdown_flag == 0)
    1240:	80 91 32 01 	lds	r24, 0x0132
    1244:	88 23       	and	r24, r24
    1246:	11 f4       	brne	.+4      	; 0x124c <__vector_11+0x290>
					_bluetooth_turn_on();		
    1248:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <_bluetooth_turn_on>
				seconds_disconnected = (_SAMPLING_RATE * 45) + 1;			
    124c:	90 91 06 01 	lds	r25, 0x0106
    1250:	8d e2       	ldi	r24, 0x2D	; 45
    1252:	98 9f       	mul	r25, r24
    1254:	c0 01       	movw	r24, r0
    1256:	11 24       	eor	r1, r1
    1258:	01 96       	adiw	r24, 0x01	; 1
    125a:	90 93 2b 01 	sts	0x012B, r25
    125e:	80 93 2a 01 	sts	0x012A, r24
    1262:	8f e1       	ldi	r24, 0x1F	; 31
    1264:	9e e4       	ldi	r25, 0x4E	; 78
    1266:	01 97       	sbiw	r24, 0x01	; 1
    1268:	f1 f7       	brne	.-4      	; 0x1266 <__vector_11+0x2aa>
    126a:	00 c0       	rjmp	.+0      	; 0x126c <__vector_11+0x2b0>
    126c:	00 00       	nop
    126e:	26 c0       	rjmp	.+76     	; 0x12bc <__vector_11+0x300>

			return;	
		}

		//reset shutdown timer if connected
		if ((_wPDT != 0) && (_wShutdownTimer != _DEFAULT_SHUTDOWN))
    1270:	80 91 85 38 	lds	r24, 0x3885
    1274:	88 23       	and	r24, r24
    1276:	e9 f0       	breq	.+58     	; 0x12b2 <__vector_11+0x2f6>
    1278:	80 91 5b 01 	lds	r24, 0x015B
    127c:	90 91 5c 01 	lds	r25, 0x015C
    1280:	a0 91 5d 01 	lds	r26, 0x015D
    1284:	b0 91 5e 01 	lds	r27, 0x015E
    1288:	20 91 57 01 	lds	r18, 0x0157
    128c:	30 91 58 01 	lds	r19, 0x0158
    1290:	40 91 59 01 	lds	r20, 0x0159
    1294:	50 91 5a 01 	lds	r21, 0x015A
    1298:	28 17       	cp	r18, r24
    129a:	39 07       	cpc	r19, r25
    129c:	4a 07       	cpc	r20, r26
    129e:	5b 07       	cpc	r21, r27
    12a0:	41 f0       	breq	.+16     	; 0x12b2 <__vector_11+0x2f6>
			_wShutdownTimer = _DEFAULT_SHUTDOWN;
    12a2:	80 93 57 01 	sts	0x0157, r24
    12a6:	90 93 58 01 	sts	0x0158, r25
    12aa:	a0 93 59 01 	sts	0x0159, r26
    12ae:	b0 93 5a 01 	sts	0x015A, r27

		_receive_data();		
    12b2:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_receive_data>
		connected = 1;		
    12b6:	81 e0       	ldi	r24, 0x01	; 1
    12b8:	80 93 29 01 	sts	0x0129, r24
	}
}
    12bc:	ff 91       	pop	r31
    12be:	ef 91       	pop	r30
    12c0:	bf 91       	pop	r27
    12c2:	af 91       	pop	r26
    12c4:	9f 91       	pop	r25
    12c6:	8f 91       	pop	r24
    12c8:	7f 91       	pop	r23
    12ca:	6f 91       	pop	r22
    12cc:	5f 91       	pop	r21
    12ce:	4f 91       	pop	r20
    12d0:	3f 91       	pop	r19
    12d2:	2f 91       	pop	r18
    12d4:	1f 91       	pop	r17
    12d6:	0f 90       	pop	r0
    12d8:	0b be       	out	0x3b, r0	; 59
    12da:	0f 90       	pop	r0
    12dc:	0f be       	out	0x3f, r0	; 63
    12de:	0f 90       	pop	r0
    12e0:	1f 90       	pop	r1
    12e2:	18 95       	reti

000012e4 <_atmega_set_adc_clock>:
/* Local Function Definitions */


/* Different prescalars are made available if the Sampling rate is changed*/
void _atmega_set_adc_clock(unsigned char prescalar){
        if (prescalar==ADC_PRESCALAR_2){
    12e4:	88 23       	and	r24, r24
    12e6:	21 f4       	brne	.+8      	; 0x12f0 <_atmega_set_adc_clock+0xc>
                ADCSRA &= ~((1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0));
    12e8:	80 91 7a 00 	lds	r24, 0x007A
    12ec:	88 7f       	andi	r24, 0xF8	; 248
    12ee:	36 c0       	rjmp	.+108    	; 0x135c <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_4){
    12f0:	81 30       	cpi	r24, 0x01	; 1
    12f2:	49 f4       	brne	.+18     	; 0x1306 <_atmega_set_adc_clock+0x22>
                ADCSRA &= ~((1 << ADPS2) | (1 << ADPS0));
    12f4:	80 91 7a 00 	lds	r24, 0x007A
    12f8:	8a 7f       	andi	r24, 0xFA	; 250
    12fa:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= (1 << ADPS1);
    12fe:	80 91 7a 00 	lds	r24, 0x007A
    1302:	82 60       	ori	r24, 0x02	; 2
    1304:	2b c0       	rjmp	.+86     	; 0x135c <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_8){
    1306:	82 30       	cpi	r24, 0x02	; 2
    1308:	49 f4       	brne	.+18     	; 0x131c <_atmega_set_adc_clock+0x38>
                ADCSRA &= ~(1 << ADPS2);
    130a:	80 91 7a 00 	lds	r24, 0x007A
    130e:	8b 7f       	andi	r24, 0xFB	; 251
    1310:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= ((1 << ADPS1) |(1 << ADPS0)) ;
    1314:	80 91 7a 00 	lds	r24, 0x007A
    1318:	83 60       	ori	r24, 0x03	; 3
    131a:	20 c0       	rjmp	.+64     	; 0x135c <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_16){
    131c:	83 30       	cpi	r24, 0x03	; 3
    131e:	49 f4       	brne	.+18     	; 0x1332 <_atmega_set_adc_clock+0x4e>
                ADCSRA &= ~((1 << ADPS1) |(1 << ADPS0));
    1320:	80 91 7a 00 	lds	r24, 0x007A
    1324:	8c 7f       	andi	r24, 0xFC	; 252
    1326:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= (1 << ADPS2);
    132a:	80 91 7a 00 	lds	r24, 0x007A
    132e:	84 60       	ori	r24, 0x04	; 4
    1330:	15 c0       	rjmp	.+42     	; 0x135c <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_32){
    1332:	84 30       	cpi	r24, 0x04	; 4
    1334:	49 f4       	brne	.+18     	; 0x1348 <_atmega_set_adc_clock+0x64>
                ADCSRA &= ~(1 << ADPS1);
    1336:	80 91 7a 00 	lds	r24, 0x007A
    133a:	8d 7f       	andi	r24, 0xFD	; 253
    133c:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= ((1 << ADPS2)|(1 << ADPS0));
    1340:	80 91 7a 00 	lds	r24, 0x007A
    1344:	85 60       	ori	r24, 0x05	; 5
    1346:	0a c0       	rjmp	.+20     	; 0x135c <_atmega_set_adc_clock+0x78>
        }else if (prescalar==ADC_PRESCALAR_64){
    1348:	85 30       	cpi	r24, 0x05	; 5
    134a:	59 f4       	brne	.+22     	; 0x1362 <_atmega_set_adc_clock+0x7e>
                ADCSRA &= ~(1 << ADPS0);
    134c:	80 91 7a 00 	lds	r24, 0x007A
    1350:	8e 7f       	andi	r24, 0xFE	; 254
    1352:	80 93 7a 00 	sts	0x007A, r24
                ADCSRA |= ((1 << ADPS2)|(1 << ADPS1));
    1356:	80 91 7a 00 	lds	r24, 0x007A
    135a:	86 60       	ori	r24, 0x06	; 6
    135c:	80 93 7a 00 	sts	0x007A, r24
    1360:	08 95       	ret
        }else if (prescalar==ADC_PRESCALAR_128){            
    1362:	86 30       	cpi	r24, 0x06	; 6
    1364:	29 f4       	brne	.+10     	; 0x1370 <_atmega_set_adc_clock+0x8c>
                ADCSRA |= ((1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0));
    1366:	80 91 7a 00 	lds	r24, 0x007A
    136a:	87 60       	ori	r24, 0x07	; 7
    136c:	80 93 7a 00 	sts	0x007A, r24
    1370:	08 95       	ret

00001372 <_atmega_adc_turn_on>:

/* Function to turn ON the adc by setting ADEN*/
void _atmega_adc_turn_on()
{

	sbi(ADCSRA,ADEN);
    1372:	ea e7       	ldi	r30, 0x7A	; 122
    1374:	f0 e0       	ldi	r31, 0x00	; 0
    1376:	80 81       	ld	r24, Z
    1378:	80 68       	ori	r24, 0x80	; 128
    137a:	80 83       	st	Z, r24
}
    137c:	08 95       	ret

0000137e <_atmega_adc_turn_off>:

/* Function to turn OFF the adc by clearinging ADEN*/
void _atmega_adc_turn_off()
{
	cbi(ADCSRA,ADEN);
    137e:	ea e7       	ldi	r30, 0x7A	; 122
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	80 81       	ld	r24, Z
    1384:	8f 77       	andi	r24, 0x7F	; 127
    1386:	80 83       	st	Z, r24
}
    1388:	08 95       	ret

0000138a <_atmega_select_adc>:

/* Function to select adc channels*/
void _atmega_select_adc(unsigned char channel){
        if (channel==ADC0){
    138a:	88 23       	and	r24, r24
    138c:	21 f4       	brne	.+8      	; 0x1396 <_atmega_select_adc+0xc>
                cbi(ADMUX,0);
    138e:	80 91 7c 00 	lds	r24, 0x007C
    1392:	8e 7f       	andi	r24, 0xFE	; 254
    1394:	05 c0       	rjmp	.+10     	; 0x13a0 <_atmega_select_adc+0x16>
                cbi(ADMUX,1);
                cbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }
        else if (channel==ADC1){
    1396:	81 30       	cpi	r24, 0x01	; 1
    1398:	71 f4       	brne	.+28     	; 0x13b6 <_atmega_select_adc+0x2c>
                sbi(ADMUX,0);
    139a:	80 91 7c 00 	lds	r24, 0x007C
    139e:	81 60       	ori	r24, 0x01	; 1
    13a0:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,1);
    13a4:	80 91 7c 00 	lds	r24, 0x007C
    13a8:	8d 7f       	andi	r24, 0xFD	; 253
    13aa:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,2);
    13ae:	80 91 7c 00 	lds	r24, 0x007C
    13b2:	8b 7f       	andi	r24, 0xFB	; 251
    13b4:	2b c0       	rjmp	.+86     	; 0x140c <_atmega_select_adc+0x82>
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC2){
    13b6:	82 30       	cpi	r24, 0x02	; 2
    13b8:	21 f4       	brne	.+8      	; 0x13c2 <_atmega_select_adc+0x38>
                cbi(ADMUX,0);
    13ba:	80 91 7c 00 	lds	r24, 0x007C
    13be:	8e 7f       	andi	r24, 0xFE	; 254
    13c0:	05 c0       	rjmp	.+10     	; 0x13cc <_atmega_select_adc+0x42>
                sbi(ADMUX,1);
                cbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC3){
    13c2:	83 30       	cpi	r24, 0x03	; 3
    13c4:	49 f4       	brne	.+18     	; 0x13d8 <_atmega_select_adc+0x4e>
                sbi(ADMUX,0);
    13c6:	80 91 7c 00 	lds	r24, 0x007C
    13ca:	81 60       	ori	r24, 0x01	; 1
    13cc:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,1);
    13d0:	80 91 7c 00 	lds	r24, 0x007C
    13d4:	82 60       	ori	r24, 0x02	; 2
    13d6:	e9 cf       	rjmp	.-46     	; 0x13aa <_atmega_select_adc+0x20>
                cbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC4){
    13d8:	84 30       	cpi	r24, 0x04	; 4
    13da:	49 f4       	brne	.+18     	; 0x13ee <_atmega_select_adc+0x64>
                cbi(ADMUX,0);
    13dc:	80 91 7c 00 	lds	r24, 0x007C
    13e0:	8e 7f       	andi	r24, 0xFE	; 254
    13e2:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,1);
    13e6:	80 91 7c 00 	lds	r24, 0x007C
    13ea:	8d 7f       	andi	r24, 0xFD	; 253
    13ec:	0a c0       	rjmp	.+20     	; 0x1402 <_atmega_select_adc+0x78>
                sbi(ADMUX,2);
                cbi(ADMUX,3);
                cbi(ADMUX,4);
        }else if (channel==ADC6)
    13ee:	86 30       	cpi	r24, 0x06	; 6
    13f0:	d1 f4       	brne	.+52     	; 0x1426 <_atmega_select_adc+0x9c>
        {
                cbi(ADMUX,0);
    13f2:	80 91 7c 00 	lds	r24, 0x007C
    13f6:	8e 7f       	andi	r24, 0xFE	; 254
    13f8:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,1);
    13fc:	80 91 7c 00 	lds	r24, 0x007C
    1400:	82 60       	ori	r24, 0x02	; 2
    1402:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,2);
    1406:	80 91 7c 00 	lds	r24, 0x007C
    140a:	84 60       	ori	r24, 0x04	; 4
    140c:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,3);
    1410:	80 91 7c 00 	lds	r24, 0x007C
    1414:	87 7f       	andi	r24, 0xF7	; 247
    1416:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,4);
    141a:	80 91 7c 00 	lds	r24, 0x007C
    141e:	8f 7e       	andi	r24, 0xEF	; 239
    1420:	80 93 7c 00 	sts	0x007C, r24
    1424:	08 95       	ret
        }
        else if (channel==ADC7)
    1426:	87 30       	cpi	r24, 0x07	; 7
    1428:	c9 f4       	brne	.+50     	; 0x145c <_atmega_select_adc+0xd2>
        {
                sbi(ADMUX,0);
    142a:	80 91 7c 00 	lds	r24, 0x007C
    142e:	81 60       	ori	r24, 0x01	; 1
    1430:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,1);
    1434:	80 91 7c 00 	lds	r24, 0x007C
    1438:	82 60       	ori	r24, 0x02	; 2
    143a:	80 93 7c 00 	sts	0x007C, r24
                sbi(ADMUX,2);
    143e:	80 91 7c 00 	lds	r24, 0x007C
    1442:	84 60       	ori	r24, 0x04	; 4
    1444:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,3);
    1448:	80 91 7c 00 	lds	r24, 0x007C
    144c:	87 7f       	andi	r24, 0xF7	; 247
    144e:	80 93 7c 00 	sts	0x007C, r24
                cbi(ADMUX,4);
    1452:	80 91 7c 00 	lds	r24, 0x007C
    1456:	8f 7e       	andi	r24, 0xEF	; 239
    1458:	80 93 7c 00 	sts	0x007C, r24
    145c:	08 95       	ret

0000145e <_atmega_a2dConvert10bit>:

/* Function to select 10 bit adc convertion*/
unsigned short _atmega_a2dConvert10bit(unsigned char channel){
	
	// Select channel
	_atmega_select_adc(channel);
    145e:	0e 94 c5 09 	call	0x138a	; 0x138a <_atmega_select_adc>
	

	//Start ADC Conversion
	sbi(ADCSRA, ADIF);   // clear hardware "conversion complete" flag 
    1462:	80 91 7a 00 	lds	r24, 0x007A
    1466:	80 61       	ori	r24, 0x10	; 16
    1468:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSRA,ADSC);
    146c:	80 91 7a 00 	lds	r24, 0x007A
    1470:	80 64       	ori	r24, 0x40	; 64
    1472:	80 93 7a 00 	sts	0x007A, r24
	
	// ADSC is 1 while converting, 0 when it is done
	while(bit_is_set(ADCSRA, ADSC)); 
    1476:	80 91 7a 00 	lds	r24, 0x007A
    147a:	86 fd       	sbrc	r24, 6
    147c:	fc cf       	rjmp	.-8      	; 0x1476 <_atmega_a2dConvert10bit+0x18>

	return ((ADCL)|((ADCH)<<8));
    147e:	20 91 78 00 	lds	r18, 0x0078
    1482:	30 91 79 00 	lds	r19, 0x0079
    1486:	93 2f       	mov	r25, r19
    1488:	80 e0       	ldi	r24, 0x00	; 0
    148a:	30 e0       	ldi	r19, 0x00	; 0
    148c:	28 2b       	or	r18, r24
    148e:	39 2b       	or	r19, r25
}
    1490:	c9 01       	movw	r24, r18
    1492:	08 95       	ret

00001494 <_atmega_initialize_uart0>:
	
*/
void _atmega_initialize_uart0(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR0H = (unsigned char)(baud>>8);
    1494:	90 93 c5 00 	sts	0x00C5, r25
        UBRR0L = (unsigned char)baud;
    1498:	80 93 c4 00 	sts	0x00C4, r24
        /* Enable receiver and/or transmitter */
		switch(mode)
    149c:	66 23       	and	r22, r22
    149e:	19 f0       	breq	.+6      	; 0x14a6 <_atmega_initialize_uart0+0x12>
    14a0:	61 30       	cpi	r22, 0x01	; 1
    14a2:	29 f4       	brne	.+10     	; 0x14ae <_atmega_initialize_uart0+0x1a>
    14a4:	02 c0       	rjmp	.+4      	; 0x14aa <_atmega_initialize_uart0+0x16>
		{
			case TX_UART_MODE:
        		UCSR0B = (1<<TXEN0);
    14a6:	88 e0       	ldi	r24, 0x08	; 8
    14a8:	03 c0       	rjmp	.+6      	; 0x14b0 <_atmega_initialize_uart0+0x1c>
				break;
			case RX_UART_MODE:
        		UCSR0B = (1<<RXEN0);
    14aa:	80 e1       	ldi	r24, 0x10	; 16
    14ac:	01 c0       	rjmp	.+2      	; 0x14b0 <_atmega_initialize_uart0+0x1c>
				break;
			default:
        		UCSR0B = (1<<TXEN0)|(1<<RXEN0);
    14ae:	88 e1       	ldi	r24, 0x18	; 24
    14b0:	80 93 c1 00 	sts	0x00C1, r24
		}
        /* Set frame format: 8data, 2stop bit */
        UCSR0C = (3<<UCSZ00);//| (3<<UCSZ01) ;  //change 1 to 0 and &
    14b4:	86 e0       	ldi	r24, 0x06	; 6
    14b6:	80 93 c2 00 	sts	0x00C2, r24
}
    14ba:	08 95       	ret

000014bc <_atmega_initialize_uart1>:
	
*/
void _atmega_initialize_uart1(unsigned int baud, unsigned char mode)
{
        /* Set baud rate */
        UBRR1H = (unsigned char)(baud>>8);
    14bc:	90 93 cd 00 	sts	0x00CD, r25
        UBRR1L = (unsigned char)baud;
    14c0:	80 93 cc 00 	sts	0x00CC, r24
        /* Enable receiver and transmitter */
		switch(mode)
    14c4:	66 23       	and	r22, r22
    14c6:	19 f0       	breq	.+6      	; 0x14ce <_atmega_initialize_uart1+0x12>
    14c8:	61 30       	cpi	r22, 0x01	; 1
    14ca:	29 f4       	brne	.+10     	; 0x14d6 <_atmega_initialize_uart1+0x1a>
    14cc:	02 c0       	rjmp	.+4      	; 0x14d2 <_atmega_initialize_uart1+0x16>
		{
			case TX_UART_MODE:
        		UCSR1B = (1<<TXEN1);
    14ce:	88 e0       	ldi	r24, 0x08	; 8
    14d0:	03 c0       	rjmp	.+6      	; 0x14d8 <_atmega_initialize_uart1+0x1c>
				break;
			case RX_UART_MODE:
        		UCSR1B = (1<<RXEN1);
    14d2:	80 e1       	ldi	r24, 0x10	; 16
    14d4:	01 c0       	rjmp	.+2      	; 0x14d8 <_atmega_initialize_uart1+0x1c>
				break;
			default:
        		UCSR1B = (1<<TXEN1)|(1<<RXEN1);
    14d6:	88 e1       	ldi	r24, 0x18	; 24
    14d8:	80 93 c9 00 	sts	0x00C9, r24
				break;
		}        
        /* Set frame format: 8data, 2stop bit */
        UCSR1C =(3<<UCSZ10);  //change 1 to 0 and &
    14dc:	86 e0       	ldi	r24, 0x06	; 6
    14de:	80 93 ca 00 	sts	0x00CA, r24
}
    14e2:	08 95       	ret

000014e4 <_atmega_disable_JTAG>:
*/
void _atmega_disable_JTAG(void)
{
	unsigned char sreg;

	sreg = SREG;
    14e4:	9f b7       	in	r25, 0x3f	; 63
	cli();
    14e6:	f8 94       	cli
	MCUCR |= ( 1 <<JTD );
    14e8:	85 b7       	in	r24, 0x35	; 53
    14ea:	80 68       	ori	r24, 0x80	; 128
    14ec:	85 bf       	out	0x35, r24	; 53
	MCUCR |= ( 1 <<JTD );
    14ee:	85 b7       	in	r24, 0x35	; 53
    14f0:	80 68       	ori	r24, 0x80	; 128
    14f2:	85 bf       	out	0x35, r24	; 53
	SREG = sreg;
    14f4:	9f bf       	out	0x3f, r25	; 63
}
    14f6:	08 95       	ret

000014f8 <_atmega_set_timer2_prescalar>:

/* Setting prescalar for the timer 2 whose interrupts are used to sample data regularly at 40 Hz */
void _atmega_set_timer2_prescalar(unsigned char prescalar)
{
	switch(prescalar)
    14f8:	82 30       	cpi	r24, 0x02	; 2
    14fa:	b1 f0       	breq	.+44     	; 0x1528 <_atmega_set_timer2_prescalar+0x30>
    14fc:	83 30       	cpi	r24, 0x03	; 3
    14fe:	28 f4       	brcc	.+10     	; 0x150a <_atmega_set_timer2_prescalar+0x12>
    1500:	88 23       	and	r24, r24
    1502:	51 f0       	breq	.+20     	; 0x1518 <_atmega_set_timer2_prescalar+0x20>
    1504:	81 30       	cpi	r24, 0x01	; 1
    1506:	01 f5       	brne	.+64     	; 0x1548 <_atmega_set_timer2_prescalar+0x50>
    1508:	0b c0       	rjmp	.+22     	; 0x1520 <_atmega_set_timer2_prescalar+0x28>
    150a:	84 30       	cpi	r24, 0x04	; 4
    150c:	a9 f0       	breq	.+42     	; 0x1538 <_atmega_set_timer2_prescalar+0x40>
    150e:	84 30       	cpi	r24, 0x04	; 4
    1510:	78 f0       	brcs	.+30     	; 0x1530 <_atmega_set_timer2_prescalar+0x38>
    1512:	85 30       	cpi	r24, 0x05	; 5
    1514:	c9 f4       	brne	.+50     	; 0x1548 <_atmega_set_timer2_prescalar+0x50>
    1516:	14 c0       	rjmp	.+40     	; 0x1540 <_atmega_set_timer2_prescalar+0x48>
	{
		case CPU_CLK_PRESCALAR_NONE:
			TCCR2B |= (1 << CS20);
    1518:	80 91 b1 00 	lds	r24, 0x00B1
    151c:	81 60       	ori	r24, 0x01	; 1
    151e:	17 c0       	rjmp	.+46     	; 0x154e <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_8:
			TCCR2B |= (1 << CS21); 
    1520:	80 91 b1 00 	lds	r24, 0x00B1
    1524:	82 60       	ori	r24, 0x02	; 2
    1526:	13 c0       	rjmp	.+38     	; 0x154e <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_32:
			TCCR2B |= ((1 << CS20) | (1 << CS21));
    1528:	80 91 b1 00 	lds	r24, 0x00B1
    152c:	83 60       	ori	r24, 0x03	; 3
    152e:	0f c0       	rjmp	.+30     	; 0x154e <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_64:
			TCCR2B |= (1 << CS22) ;
    1530:	80 91 b1 00 	lds	r24, 0x00B1
    1534:	84 60       	ori	r24, 0x04	; 4
    1536:	0b c0       	rjmp	.+22     	; 0x154e <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_128:
			TCCR2B |= ((1 << CS20) |(1 << CS22));
    1538:	80 91 b1 00 	lds	r24, 0x00B1
    153c:	85 60       	ori	r24, 0x05	; 5
    153e:	07 c0       	rjmp	.+14     	; 0x154e <_atmega_set_timer2_prescalar+0x56>
			break;
		case CPU_CLK_PRESCALAR_256:
			TCCR2B |= ((1 << CS22) |(1 << CS21));
    1540:	80 91 b1 00 	lds	r24, 0x00B1
    1544:	86 60       	ori	r24, 0x06	; 6
    1546:	03 c0       	rjmp	.+6      	; 0x154e <_atmega_set_timer2_prescalar+0x56>
			break;
		default:
			TCCR2B |= ((1 << CS20) |(1 << CS21) | (1 << CS22)); 
    1548:	80 91 b1 00 	lds	r24, 0x00B1
    154c:	87 60       	ori	r24, 0x07	; 7
    154e:	80 93 b1 00 	sts	0x00B1, r24
    1552:	08 95       	ret

00001554 <_atmega_enable_timer2>:
*/
void _atmega_enable_timer2(unsigned char timer_prescalar)
{

	// Setup the prescaler to 1024		 
	_atmega_set_timer2_prescalar(timer_prescalar);
    1554:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <_atmega_set_timer2_prescalar>
	// Set the counter to 0
	TCNT2=0;
    1558:	10 92 b2 00 	sts	0x00B2, r1
	//Enable the overflow interrupt
	TIMSK2 |= (1 << TOIE2); // Enable CTC interrupt
    155c:	e0 e7       	ldi	r30, 0x70	; 112
    155e:	f0 e0       	ldi	r31, 0x00	; 0
    1560:	80 81       	ld	r24, Z
    1562:	81 60       	ori	r24, 0x01	; 1
    1564:	80 83       	st	Z, r24
	// Enable global interrupts
	sei(); 
    1566:	78 94       	sei
}
    1568:	08 95       	ret

0000156a <_atmega_disable_timer2>:
	
*/
void _atmega_disable_timer2(void)
{	
	//disable timer interrupt
	TIMSK2=0;
    156a:	10 92 70 00 	sts	0x0070, r1
	// reset counter unit
	TCCR2B=0;
    156e:	10 92 b1 00 	sts	0x00B1, r1
}
    1572:	08 95       	ret

00001574 <_atmega_reset>:

/* Watch dog timer is enabled to reset the mcu */

void _atmega_reset(void)
{   
		_atmega_disable_timer2();            
    1574:	0e 94 b5 0a 	call	0x156a	; 0x156a <_atmega_disable_timer2>
        cli(); //irq's off
    1578:	f8 94       	cli
        wdt_enable(WDTO_15MS); //wd on,15ms
    157a:	28 e0       	ldi	r18, 0x08	; 8
    157c:	88 e1       	ldi	r24, 0x18	; 24
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	0f b6       	in	r0, 0x3f	; 63
    1582:	f8 94       	cli
    1584:	a8 95       	wdr
    1586:	80 93 60 00 	sts	0x0060, r24
    158a:	0f be       	out	0x3f, r0	; 63
    158c:	20 93 60 00 	sts	0x0060, r18
    1590:	ff cf       	rjmp	.-2      	; 0x1590 <_atmega_reset+0x1c>

00001592 <_atmega_disable_watchdog>:
	This has to be done at the begining of an application
	
*/
void _atmega_disable_watchdog(void)
{
	MCUSR = 0;
    1592:	14 be       	out	0x34, r1	; 52
	wdt_disable();
    1594:	88 e1       	ldi	r24, 0x18	; 24
    1596:	0f b6       	in	r0, 0x3f	; 63
    1598:	f8 94       	cli
    159a:	80 93 60 00 	sts	0x0060, r24
    159e:	10 92 60 00 	sts	0x0060, r1
    15a2:	0f be       	out	0x3f, r0	; 63
}
    15a4:	08 95       	ret

000015a6 <_bluetooth_turn_on>:
	
*/
void _bluetooth_turn_on(void)
{
	// Set the direction of TX pin as output
	sbi(DDRD,OUT_BT_TXD);
    15a6:	51 9a       	sbi	0x0a, 1	; 10

	// Set the direction of the RESET pin as output and high
	sbi(DDRD,OUT_BT_RESET_N);	
    15a8:	52 9a       	sbi	0x0a, 2	; 10
	sbi(PORTD,OUT_BT_RESET_N);  
    15aa:	5a 9a       	sbi	0x0b, 2	; 11

	// Set the direction of the switch pin as output and low
	sbi(DDRB,OUT_BT_SW_N);
    15ac:	24 9a       	sbi	0x04, 4	; 4
	cbi(PORTB,OUT_BT_SW_N);
    15ae:	2c 98       	cbi	0x05, 4	; 5

	// Set the status of the bluetooth to true
	sbi(atmega_status, BIT0_BLUETOOTH_STATUS);
    15b0:	80 91 70 38 	lds	r24, 0x3870
    15b4:	81 60       	ori	r24, 0x01	; 1
    15b6:	80 93 70 38 	sts	0x3870, r24
}
    15ba:	08 95       	ret

000015bc <_bluetooth_turn_off>:
	
*/
void _bluetooth_turn_off(void)
{
	// Set the direction of TX, RESET and switch pins as input
	cbi(DDRD,OUT_BT_TXD);
    15bc:	51 98       	cbi	0x0a, 1	; 10
	cbi(DDRD,OUT_BT_RESET_N);
    15be:	52 98       	cbi	0x0a, 2	; 10
	cbi(DDRB,OUT_BT_SW_N);		 
    15c0:	24 98       	cbi	0x04, 4	; 4

	// Set the status of bluetooth to false
	cbi(atmega_status, BIT0_BLUETOOTH_STATUS);
    15c2:	80 91 70 38 	lds	r24, 0x3870
    15c6:	8e 7f       	andi	r24, 0xFE	; 254
    15c8:	80 93 70 38 	sts	0x3870, r24
}
    15cc:	08 95       	ret

000015ce <_bluetooth_reset>:
}

/* Reset Bluetooth */
void _bluetooth_reset(void)
{
	_bluetooth_turn_off();
    15ce:	0e 94 de 0a 	call	0x15bc	; 0x15bc <_bluetooth_turn_off>
    15d2:	8f ef       	ldi	r24, 0xFF	; 255
    15d4:	ef e0       	ldi	r30, 0x0F	; 15
    15d6:	f7 e2       	ldi	r31, 0x27	; 39
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	f1 f7       	brne	.-4      	; 0x15d8 <_bluetooth_reset+0xa>
    15dc:	00 c0       	rjmp	.+0      	; 0x15de <_bluetooth_reset+0x10>
    15de:	00 00       	nop
    15e0:	81 50       	subi	r24, 0x01	; 1
	for (unsigned char i=0;(i<255);i++)
    15e2:	c1 f7       	brne	.-16     	; 0x15d4 <_bluetooth_reset+0x6>
		_delay_ms(5);
	_bluetooth_turn_on();
    15e4:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <_bluetooth_turn_on>

}
    15e8:	08 95       	ret

000015ea <_is_bluetooth_on>:
	
*/

unsigned char _is_bluetooth_on(void)
{
	return ((atmega_status>>BIT0_BLUETOOTH_STATUS) & 0x01);
    15ea:	80 91 70 38 	lds	r24, 0x3870
}
    15ee:	81 70       	andi	r24, 0x01	; 1
    15f0:	08 95       	ret

000015f2 <_bluetooth_is_connected>:

/* check if RN-41 is connected to phone via bluetooth*/
unsigned char _bluetooth_is_connected(void){

#ifdef _VERSION==3
        return (0x01 & (PINA>>IN_BT_CONNECT));
    15f2:	80 b1       	in	r24, 0x00	; 0
    15f4:	82 95       	swap	r24
#else
        return (0x01 & (PIND>>IN_BT_CONNECT));
#endif
}
    15f6:	81 70       	andi	r24, 0x01	; 1
    15f8:	08 95       	ret

000015fa <_bluetooth_is_discoverable>:

/* check if RN-41 is discoverable*/
unsigned char _bluetooth_is_discoverable(void){

#ifdef _VERSION==3
        return (0x01 & (PINA>>IN_BT_DISC));
    15fa:	80 b1       	in	r24, 0x00	; 0
    15fc:	82 95       	swap	r24
    15fe:	86 95       	lsr	r24
    1600:	86 95       	lsr	r24
#else
         return (0x01 & (PIND>>IN_BT_DISC));
#endif
}
    1602:	81 70       	andi	r24, 0x01	; 1
    1604:	08 95       	ret

00001606 <_receive_uart0_flush>:

/* Clearing the receive register of the UART0*/
void _receive_uart0_flush( void )
{
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC0) ) dummy = UDR0;
    1606:	02 c0       	rjmp	.+4      	; 0x160c <_receive_uart0_flush+0x6>
    1608:	80 91 c6 00 	lds	r24, 0x00C6
    160c:	80 91 c0 00 	lds	r24, 0x00C0
    1610:	87 fd       	sbrc	r24, 7
    1612:	fa cf       	rjmp	.-12     	; 0x1608 <_receive_uart0_flush+0x2>
}
    1614:	08 95       	ret

00001616 <_bluetooth_receive_uart0_byte>:

/* Receive data from the UART0*/
unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
    1616:	20 91 c0 00 	lds	r18, 0x00C0
    161a:	27 fd       	sbrc	r18, 7
    161c:	04 c0       	rjmp	.+8      	; 0x1626 <_bluetooth_receive_uart0_byte+0x10>
    161e:	20 91 c0 00 	lds	r18, 0x00C0
    1622:	27 ff       	sbrs	r18, 7
    1624:	06 c0       	rjmp	.+12     	; 0x1632 <_bluetooth_receive_uart0_byte+0x1c>
   {
   		if (count++==1) return 0; //timed out
   		//	_delay_ms(1);
   }     /*  Wait for incoming data   */

   *data=UDR0;
    1626:	20 91 c6 00 	lds	r18, 0x00C6
    162a:	fc 01       	movw	r30, r24
    162c:	20 83       	st	Z, r18

   return 1;/* Return success*/
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	08 95       	ret
unsigned char _bluetooth_receive_uart0_byte(unsigned char *data)
  {
  	int count=0;
   while ( !(UCSR0A &  (1<<RXC0)) )
   {
   		if (count++==1) return 0; //timed out
    1632:	80 e0       	ldi	r24, 0x00	; 0
   }     /*  Wait for incoming data   */

   *data=UDR0;

   return 1;/* Return success*/
  }
    1634:	08 95       	ret

00001636 <_bluetooth_transmit_uart0_byte>:

/* Transmit data via UART0*/
void _bluetooth_transmit_uart0_byte( unsigned char data )
{
  while ( !(UCSR0A & (1<<UDRE0)) );        /* Wait for   empty transmit buffer */
    1636:	90 91 c0 00 	lds	r25, 0x00C0
    163a:	95 ff       	sbrs	r25, 5
    163c:	fc cf       	rjmp	.-8      	; 0x1636 <_bluetooth_transmit_uart0_byte>
  UCSR0A=UCSR0A & 0xdf;
    163e:	90 91 c0 00 	lds	r25, 0x00C0
    1642:	9f 7d       	andi	r25, 0xDF	; 223
    1644:	90 93 c0 00 	sts	0x00C0, r25
  
  UDR0 =  data;  /* Start transmission   */
    1648:	80 93 c6 00 	sts	0x00C6, r24
   
}
    164c:	08 95       	ret

0000164e <_bluetooth_get_baud_rate>:
	return 0;
}

/* Get baud rate */
unsigned char _bluetooth_get_baud_rate()
{
    164e:	ff 92       	push	r15
    1650:	0f 93       	push	r16
    1652:	1f 93       	push	r17
    1654:	df 93       	push	r29
    1656:	cf 93       	push	r28
    1658:	0f 92       	push	r0
    165a:	cd b7       	in	r28, 0x3d	; 61
    165c:	de b7       	in	r29, 0x3e	; 62
	unsigned char attempts=0;
	unsigned char baudrate=0;
    165e:	19 82       	std	Y+1, r1	; 0x01
}

/* Get baud rate */
unsigned char _bluetooth_get_baud_rate()
{
	unsigned char attempts=0;
    1660:	ff 24       	eor	r15, r15
		_bluetooth_transmit_uart0_byte(13);
		_delay_ms(5);


		attempts++;
 		if ((attempts>=255) || (_bluetooth_receive_uart0_byte(&baudrate)==0))
    1662:	8e 01       	movw	r16, r28
    1664:	0f 5f       	subi	r16, 0xFF	; 255
    1666:	1f 4f       	sbci	r17, 0xFF	; 255


		//for (int i=0;(i<100);i++)
		//	_bluetooth_receive_uart0_byte(&aByte);

		_bluetooth_transmit_uart0_byte(13);
    1668:	8d e0       	ldi	r24, 0x0D	; 13
    166a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    166e:	8f e0       	ldi	r24, 0x0F	; 15
    1670:	97 e2       	ldi	r25, 0x27	; 39
    1672:	01 97       	sbiw	r24, 0x01	; 1
    1674:	f1 f7       	brne	.-4      	; 0x1672 <_bluetooth_get_baud_rate+0x24>
    1676:	00 c0       	rjmp	.+0      	; 0x1678 <_bluetooth_get_baud_rate+0x2a>
    1678:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
    167a:	8d e0       	ldi	r24, 0x0D	; 13
    167c:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>


		_bluetooth_transmit_uart0_byte('G');
    1680:	87 e4       	ldi	r24, 0x47	; 71
    1682:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1686:	8f e0       	ldi	r24, 0x0F	; 15
    1688:	97 e2       	ldi	r25, 0x27	; 39
    168a:	01 97       	sbiw	r24, 0x01	; 1
    168c:	f1 f7       	brne	.-4      	; 0x168a <_bluetooth_get_baud_rate+0x3c>
    168e:	00 c0       	rjmp	.+0      	; 0x1690 <_bluetooth_get_baud_rate+0x42>
    1690:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte('U');		
    1692:	85 e5       	ldi	r24, 0x55	; 85
    1694:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1698:	8f e0       	ldi	r24, 0x0F	; 15
    169a:	97 e2       	ldi	r25, 0x27	; 39
    169c:	01 97       	sbiw	r24, 0x01	; 1
    169e:	f1 f7       	brne	.-4      	; 0x169c <_bluetooth_get_baud_rate+0x4e>
    16a0:	00 c0       	rjmp	.+0      	; 0x16a2 <_bluetooth_get_baud_rate+0x54>
    16a2:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
    16a4:	8d e0       	ldi	r24, 0x0D	; 13
    16a6:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    16aa:	8f e0       	ldi	r24, 0x0F	; 15
    16ac:	97 e2       	ldi	r25, 0x27	; 39
    16ae:	01 97       	sbiw	r24, 0x01	; 1
    16b0:	f1 f7       	brne	.-4      	; 0x16ae <_bluetooth_get_baud_rate+0x60>
    16b2:	00 c0       	rjmp	.+0      	; 0x16b4 <_bluetooth_get_baud_rate+0x66>
    16b4:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
    16b6:	8d e0       	ldi	r24, 0x0D	; 13
    16b8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    16bc:	8f e0       	ldi	r24, 0x0F	; 15
    16be:	97 e2       	ldi	r25, 0x27	; 39
    16c0:	01 97       	sbiw	r24, 0x01	; 1
    16c2:	f1 f7       	brne	.-4      	; 0x16c0 <_bluetooth_get_baud_rate+0x72>
    16c4:	00 c0       	rjmp	.+0      	; 0x16c6 <_bluetooth_get_baud_rate+0x78>
    16c6:	00 00       	nop
		_delay_ms(5);


		attempts++;
    16c8:	f3 94       	inc	r15
 		if ((attempts>=255) || (_bluetooth_receive_uart0_byte(&baudrate)==0))
    16ca:	9f 2d       	mov	r25, r15
    16cc:	9f 3f       	cpi	r25, 0xFF	; 255
    16ce:	91 f0       	breq	.+36     	; 0x16f4 <_bluetooth_get_baud_rate+0xa6>
    16d0:	c8 01       	movw	r24, r16
    16d2:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_bluetooth_receive_uart0_byte>
    16d6:	88 23       	and	r24, r24
    16d8:	39 f6       	brne	.-114    	; 0x1668 <_bluetooth_get_baud_rate+0x1a>
    16da:	14 c0       	rjmp	.+40     	; 0x1704 <_bluetooth_get_baud_rate+0xb6>
	if (attempts<255)
	{	
		switch(baudrate)
		{
			case '2':
				baudrate=ATMEGA_BAUD_2400;
    16dc:	8f ec       	ldi	r24, 0xCF	; 207
    16de:	09 c0       	rjmp	.+18     	; 0x16f2 <_bluetooth_get_baud_rate+0xa4>
				break;
			case '4':
				baudrate=ATMEGA_BAUD_4800;
    16e0:	87 e6       	ldi	r24, 0x67	; 103
    16e2:	07 c0       	rjmp	.+14     	; 0x16f2 <_bluetooth_get_baud_rate+0xa4>
				break;
			case '9':
				baudrate=ATMEGA_BAUD_9600;
    16e4:	83 e3       	ldi	r24, 0x33	; 51
    16e6:	05 c0       	rjmp	.+10     	; 0x16f2 <_bluetooth_get_baud_rate+0xa4>
				break;
			case '1':
				baudrate=ATMEGA_BAUD_115200;
    16e8:	83 e0       	ldi	r24, 0x03	; 3
    16ea:	03 c0       	rjmp	.+6      	; 0x16f2 <_bluetooth_get_baud_rate+0xa4>
				break;
			case '5':
				baudrate=ATMEGA_BAUD_57600;
    16ec:	88 e0       	ldi	r24, 0x08	; 8
    16ee:	01 c0       	rjmp	.+2      	; 0x16f2 <_bluetooth_get_baud_rate+0xa4>
				break;
			default:
				baudrate=ATMEGA_BAUD_38400;
    16f0:	8c e0       	ldi	r24, 0x0C	; 12
    16f2:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
	}
	
	return baudrate;
}
    16f4:	89 81       	ldd	r24, Y+1	; 0x01
    16f6:	0f 90       	pop	r0
    16f8:	cf 91       	pop	r28
    16fa:	df 91       	pop	r29
    16fc:	1f 91       	pop	r17
    16fe:	0f 91       	pop	r16
    1700:	ff 90       	pop	r15
    1702:	08 95       	ret
			break;

	}
	if (attempts<255)
	{	
		switch(baudrate)
    1704:	89 81       	ldd	r24, Y+1	; 0x01
    1706:	84 33       	cpi	r24, 0x34	; 52
    1708:	59 f3       	breq	.-42     	; 0x16e0 <_bluetooth_get_baud_rate+0x92>
    170a:	85 33       	cpi	r24, 0x35	; 53
    170c:	28 f4       	brcc	.+10     	; 0x1718 <_bluetooth_get_baud_rate+0xca>
    170e:	81 33       	cpi	r24, 0x31	; 49
    1710:	59 f3       	breq	.-42     	; 0x16e8 <_bluetooth_get_baud_rate+0x9a>
    1712:	82 33       	cpi	r24, 0x32	; 50
    1714:	69 f7       	brne	.-38     	; 0x16f0 <_bluetooth_get_baud_rate+0xa2>
    1716:	e2 cf       	rjmp	.-60     	; 0x16dc <_bluetooth_get_baud_rate+0x8e>
    1718:	85 33       	cpi	r24, 0x35	; 53
    171a:	41 f3       	breq	.-48     	; 0x16ec <_bluetooth_get_baud_rate+0x9e>
    171c:	89 33       	cpi	r24, 0x39	; 57
    171e:	41 f7       	brne	.-48     	; 0x16f0 <_bluetooth_get_baud_rate+0xa2>
    1720:	e1 cf       	rjmp	.-62     	; 0x16e4 <_bluetooth_get_baud_rate+0x96>

00001722 <_bluetooth_set_baud_rate>:

}

/* Set baud rate _atmega_initialize() sets the baud rate to 38.4K*/
unsigned char _bluetooth_set_baud_rate(unsigned char baudrate)
{
    1722:	cf 92       	push	r12
    1724:	df 92       	push	r13
    1726:	ef 92       	push	r14
    1728:	ff 92       	push	r15
    172a:	0f 93       	push	r16
    172c:	1f 93       	push	r17
    172e:	df 93       	push	r29
    1730:	cf 93       	push	r28
    1732:	0f 92       	push	r0
    1734:	cd b7       	in	r28, 0x3d	; 61
    1736:	de b7       	in	r29, 0x3e	; 62
    1738:	d8 2e       	mov	r13, r24
	unsigned char attempts=0;
	unsigned char aByte=0;
    173a:	19 82       	std	Y+1, r1	; 0x01
}

/* Set baud rate _atmega_initialize() sets the baud rate to 38.4K*/
unsigned char _bluetooth_set_baud_rate(unsigned char baudrate)
{
	unsigned char attempts=0;
    173c:	cc 24       	eor	r12, r12
	unsigned char aByte=0;

	while(1)  
	{   
		for (int i=0;(i<100);i++)
			_bluetooth_receive_uart0_byte(&aByte);
    173e:	7e 01       	movw	r14, r28
    1740:	08 94       	sec
    1742:	e1 1c       	adc	r14, r1
    1744:	f1 1c       	adc	r15, r1
}

/* Set baud rate _atmega_initialize() sets the baud rate to 38.4K*/
unsigned char _bluetooth_set_baud_rate(unsigned char baudrate)
{
	unsigned char attempts=0;
    1746:	04 e6       	ldi	r16, 0x64	; 100
    1748:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char aByte=0;

	while(1)  
	{   
		for (int i=0;(i<100);i++)
			_bluetooth_receive_uart0_byte(&aByte);
    174a:	c7 01       	movw	r24, r14
    174c:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_bluetooth_receive_uart0_byte>
    1750:	01 50       	subi	r16, 0x01	; 1
    1752:	10 40       	sbci	r17, 0x00	; 0
	unsigned char attempts=0;
	unsigned char aByte=0;

	while(1)  
	{   
		for (int i=0;(i<100);i++)
    1754:	d1 f7       	brne	.-12     	; 0x174a <_bluetooth_set_baud_rate+0x28>
			_bluetooth_receive_uart0_byte(&aByte);

		_bluetooth_transmit_uart0_byte(13);
    1756:	8d e0       	ldi	r24, 0x0D	; 13
    1758:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    175c:	8f e0       	ldi	r24, 0x0F	; 15
    175e:	97 e2       	ldi	r25, 0x27	; 39
    1760:	01 97       	sbiw	r24, 0x01	; 1
    1762:	f1 f7       	brne	.-4      	; 0x1760 <_bluetooth_set_baud_rate+0x3e>
    1764:	00 c0       	rjmp	.+0      	; 0x1766 <_bluetooth_set_baud_rate+0x44>
    1766:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
    1768:	8d e0       	ldi	r24, 0x0D	; 13
    176a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>

		_bluetooth_transmit_uart0_byte('S');
    176e:	83 e5       	ldi	r24, 0x53	; 83
    1770:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1774:	8f e0       	ldi	r24, 0x0F	; 15
    1776:	97 e2       	ldi	r25, 0x27	; 39
    1778:	01 97       	sbiw	r24, 0x01	; 1
    177a:	f1 f7       	brne	.-4      	; 0x1778 <_bluetooth_set_baud_rate+0x56>
    177c:	00 c0       	rjmp	.+0      	; 0x177e <_bluetooth_set_baud_rate+0x5c>
    177e:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte('U');
    1780:	85 e5       	ldi	r24, 0x55	; 85
    1782:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1786:	8f e0       	ldi	r24, 0x0F	; 15
    1788:	97 e2       	ldi	r25, 0x27	; 39
    178a:	01 97       	sbiw	r24, 0x01	; 1
    178c:	f1 f7       	brne	.-4      	; 0x178a <_bluetooth_set_baud_rate+0x68>
    178e:	00 c0       	rjmp	.+0      	; 0x1790 <_bluetooth_set_baud_rate+0x6e>
    1790:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(',');
    1792:	8c e2       	ldi	r24, 0x2C	; 44
    1794:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1798:	8f e0       	ldi	r24, 0x0F	; 15
    179a:	97 e2       	ldi	r25, 0x27	; 39
    179c:	01 97       	sbiw	r24, 0x01	; 1
    179e:	f1 f7       	brne	.-4      	; 0x179c <_bluetooth_set_baud_rate+0x7a>
    17a0:	00 c0       	rjmp	.+0      	; 0x17a2 <_bluetooth_set_baud_rate+0x80>
    17a2:	00 00       	nop
		_delay_ms(5);
		switch(baudrate){
    17a4:	9d 2d       	mov	r25, r13
    17a6:	9c 30       	cpi	r25, 0x0C	; 12
    17a8:	69 f1       	breq	.+90     	; 0x1804 <_bluetooth_set_baud_rate+0xe2>
    17aa:	9d 30       	cpi	r25, 0x0D	; 13
    17ac:	60 f4       	brcc	.+24     	; 0x17c6 <_bluetooth_set_baud_rate+0xa4>
    17ae:	91 30       	cpi	r25, 0x01	; 1
    17b0:	09 f4       	brne	.+2      	; 0x17b4 <_bluetooth_set_baud_rate+0x92>
    17b2:	45 c0       	rjmp	.+138    	; 0x183e <_bluetooth_set_baud_rate+0x11c>
    17b4:	91 30       	cpi	r25, 0x01	; 1
    17b6:	08 f4       	brcc	.+2      	; 0x17ba <_bluetooth_set_baud_rate+0x98>
    17b8:	47 c0       	rjmp	.+142    	; 0x1848 <_bluetooth_set_baud_rate+0x126>
    17ba:	93 30       	cpi	r25, 0x03	; 3
    17bc:	d9 f1       	breq	.+118    	; 0x1834 <_bluetooth_set_baud_rate+0x112>
    17be:	98 30       	cpi	r25, 0x08	; 8
    17c0:	09 f0       	breq	.+2      	; 0x17c4 <_bluetooth_set_baud_rate+0xa2>
    17c2:	47 c0       	rjmp	.+142    	; 0x1852 <_bluetooth_set_baud_rate+0x130>
    17c4:	32 c0       	rjmp	.+100    	; 0x182a <_bluetooth_set_baud_rate+0x108>
    17c6:	8d 2d       	mov	r24, r13
    17c8:	83 33       	cpi	r24, 0x33	; 51
    17ca:	99 f0       	breq	.+38     	; 0x17f2 <_bluetooth_set_baud_rate+0xd0>
    17cc:	84 33       	cpi	r24, 0x34	; 52
    17ce:	28 f4       	brcc	.+10     	; 0x17da <_bluetooth_set_baud_rate+0xb8>
    17d0:	80 31       	cpi	r24, 0x10	; 16
    17d2:	b1 f0       	breq	.+44     	; 0x1800 <_bluetooth_set_baud_rate+0xde>
    17d4:	89 31       	cpi	r24, 0x19	; 25
    17d6:	e9 f5       	brne	.+122    	; 0x1852 <_bluetooth_set_baud_rate+0x130>
    17d8:	0e c0       	rjmp	.+28     	; 0x17f6 <_bluetooth_set_baud_rate+0xd4>
    17da:	9d 2d       	mov	r25, r13
    17dc:	97 36       	cpi	r25, 0x67	; 103
    17de:	39 f0       	breq	.+14     	; 0x17ee <_bluetooth_set_baud_rate+0xcc>
    17e0:	9f 3c       	cpi	r25, 0xCF	; 207
    17e2:	b9 f5       	brne	.+110    	; 0x1852 <_bluetooth_set_baud_rate+0x130>
			case ATMEGA_BAUD_2400:
				_bluetooth_transmit_uart0_byte('2');
    17e4:	82 e3       	ldi	r24, 0x32	; 50
    17e6:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
				_bluetooth_transmit_uart0_byte('4');
    17ea:	84 e3       	ldi	r24, 0x34	; 52
    17ec:	36 c0       	rjmp	.+108    	; 0x185a <_bluetooth_set_baud_rate+0x138>
				break;
			case ATMEGA_BAUD_4800:
				_bluetooth_transmit_uart0_byte('4');
    17ee:	84 e3       	ldi	r24, 0x34	; 52
    17f0:	31 c0       	rjmp	.+98     	; 0x1854 <_bluetooth_set_baud_rate+0x132>
				_bluetooth_transmit_uart0_byte('8');
				break;
			case ATMEGA_BAUD_9600:
				_bluetooth_transmit_uart0_byte('9');
    17f2:	89 e3       	ldi	r24, 0x39	; 57
    17f4:	2a c0       	rjmp	.+84     	; 0x184a <_bluetooth_set_baud_rate+0x128>
				_bluetooth_transmit_uart0_byte('6');
				break;
			case ATMEGA_BAUD_19200:
				_bluetooth_transmit_uart0_byte('1');
    17f6:	81 e3       	ldi	r24, 0x31	; 49
    17f8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
				_bluetooth_transmit_uart0_byte('9');
    17fc:	89 e3       	ldi	r24, 0x39	; 57
    17fe:	2d c0       	rjmp	.+90     	; 0x185a <_bluetooth_set_baud_rate+0x138>
				break;
			case ATMEGA_BAUD_28800:
				_bluetooth_transmit_uart0_byte('2');
    1800:	82 e3       	ldi	r24, 0x32	; 50
    1802:	28 c0       	rjmp	.+80     	; 0x1854 <_bluetooth_set_baud_rate+0x132>
				_bluetooth_transmit_uart0_byte('8');
				break;
			case ATMEGA_BAUD_38400:
				_bluetooth_transmit_uart0_byte('3');
    1804:	83 e3       	ldi	r24, 0x33	; 51
    1806:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    180a:	8f e0       	ldi	r24, 0x0F	; 15
    180c:	97 e2       	ldi	r25, 0x27	; 39
    180e:	01 97       	sbiw	r24, 0x01	; 1
    1810:	f1 f7       	brne	.-4      	; 0x180e <_bluetooth_set_baud_rate+0xec>
    1812:	00 c0       	rjmp	.+0      	; 0x1814 <_bluetooth_set_baud_rate+0xf2>
    1814:	00 00       	nop
				_delay_ms(5);
				_bluetooth_transmit_uart0_byte('8');
    1816:	88 e3       	ldi	r24, 0x38	; 56
    1818:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    181c:	8f e0       	ldi	r24, 0x0F	; 15
    181e:	97 e2       	ldi	r25, 0x27	; 39
    1820:	01 97       	sbiw	r24, 0x01	; 1
    1822:	f1 f7       	brne	.-4      	; 0x1820 <_bluetooth_set_baud_rate+0xfe>
    1824:	00 c0       	rjmp	.+0      	; 0x1826 <_bluetooth_set_baud_rate+0x104>
    1826:	00 00       	nop
    1828:	1a c0       	rjmp	.+52     	; 0x185e <_bluetooth_set_baud_rate+0x13c>
				_delay_ms(5);
				break;
			case ATMEGA_BAUD_57600:
				_bluetooth_transmit_uart0_byte('5');
    182a:	85 e3       	ldi	r24, 0x35	; 53
    182c:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
				_bluetooth_transmit_uart0_byte('7');
    1830:	87 e3       	ldi	r24, 0x37	; 55
    1832:	13 c0       	rjmp	.+38     	; 0x185a <_bluetooth_set_baud_rate+0x138>
				break;
			case ATMEGA_BAUD_115200:
				_bluetooth_transmit_uart0_byte('1');
    1834:	81 e3       	ldi	r24, 0x31	; 49
    1836:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
				_bluetooth_transmit_uart0_byte('1');
    183a:	81 e3       	ldi	r24, 0x31	; 49
    183c:	0e c0       	rjmp	.+28     	; 0x185a <_bluetooth_set_baud_rate+0x138>
				break;
			case ATMEGA_BAUD_230000:
				_bluetooth_transmit_uart0_byte('2');
    183e:	82 e3       	ldi	r24, 0x32	; 50
    1840:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
				_bluetooth_transmit_uart0_byte('3');
    1844:	83 e3       	ldi	r24, 0x33	; 51
    1846:	09 c0       	rjmp	.+18     	; 0x185a <_bluetooth_set_baud_rate+0x138>
				break;
			case ATMEGA_BAUD_460000:
				_bluetooth_transmit_uart0_byte('4');
    1848:	84 e3       	ldi	r24, 0x34	; 52
    184a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
				_bluetooth_transmit_uart0_byte('6');
    184e:	86 e3       	ldi	r24, 0x36	; 54
    1850:	04 c0       	rjmp	.+8      	; 0x185a <_bluetooth_set_baud_rate+0x138>
				break;
			default:
			_bluetooth_transmit_uart0_byte('3');
    1852:	83 e3       	ldi	r24, 0x33	; 51
    1854:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
			_bluetooth_transmit_uart0_byte('8');
    1858:	88 e3       	ldi	r24, 0x38	; 56
    185a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
		}

		_bluetooth_transmit_uart0_byte(13);
    185e:	8d e0       	ldi	r24, 0x0D	; 13
    1860:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1864:	8f e0       	ldi	r24, 0x0F	; 15
    1866:	97 e2       	ldi	r25, 0x27	; 39
    1868:	01 97       	sbiw	r24, 0x01	; 1
    186a:	f1 f7       	brne	.-4      	; 0x1868 <_bluetooth_set_baud_rate+0x146>
    186c:	00 c0       	rjmp	.+0      	; 0x186e <_bluetooth_set_baud_rate+0x14c>
    186e:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
    1870:	8d e0       	ldi	r24, 0x0D	; 13
    1872:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1876:	8f e0       	ldi	r24, 0x0F	; 15
    1878:	97 e2       	ldi	r25, 0x27	; 39
    187a:	01 97       	sbiw	r24, 0x01	; 1
    187c:	f1 f7       	brne	.-4      	; 0x187a <_bluetooth_set_baud_rate+0x158>
    187e:	00 c0       	rjmp	.+0      	; 0x1880 <_bluetooth_set_baud_rate+0x15e>
    1880:	00 00       	nop
		_delay_ms(5);

		attempts++;
		if (_bluetooth_receive_uart0_byte(&aByte))
    1882:	c7 01       	movw	r24, r14
    1884:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_bluetooth_receive_uart0_byte>
    1888:	88 23       	and	r24, r24
    188a:	19 f0       	breq	.+6      	; 0x1892 <_bluetooth_set_baud_rate+0x170>
		{
			if (aByte=='A')			
    188c:	89 81       	ldd	r24, Y+1	; 0x01
    188e:	81 34       	cpi	r24, 0x41	; 65
    1890:	39 f0       	breq	.+14     	; 0x18a0 <_bluetooth_set_baud_rate+0x17e>
		_bluetooth_transmit_uart0_byte(13);
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte(13);
		_delay_ms(5);

		attempts++;
    1892:	c3 94       	inc	r12
		if (_bluetooth_receive_uart0_byte(&aByte))
		{
			if (aByte=='A')			
				return 1;					
		}
		if (attempts>=255)
    1894:	9c 2d       	mov	r25, r12
    1896:	9f 3f       	cpi	r25, 0xFF	; 255
    1898:	09 f0       	breq	.+2      	; 0x189c <_bluetooth_set_baud_rate+0x17a>
    189a:	55 cf       	rjmp	.-342    	; 0x1746 <_bluetooth_set_baud_rate+0x24>
			break;
	}
	
	// succeeded in entering command mode

	return 0;
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	01 c0       	rjmp	.+2      	; 0x18a2 <_bluetooth_set_baud_rate+0x180>

		attempts++;
		if (_bluetooth_receive_uart0_byte(&aByte))
		{
			if (aByte=='A')			
				return 1;					
    18a0:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	// succeeded in entering command mode

	return 0;
}
    18a2:	0f 90       	pop	r0
    18a4:	cf 91       	pop	r28
    18a6:	df 91       	pop	r29
    18a8:	1f 91       	pop	r17
    18aa:	0f 91       	pop	r16
    18ac:	ff 90       	pop	r15
    18ae:	ef 90       	pop	r14
    18b0:	df 90       	pop	r13
    18b2:	cf 90       	pop	r12
    18b4:	08 95       	ret

000018b6 <_bluetooth_exit_command_mode>:
	return 0;
}

/* Exit Command mode of Bluetooth*/
unsigned char _bluetooth_exit_command_mode(void)
{
    18b6:	ff 92       	push	r15
    18b8:	0f 93       	push	r16
    18ba:	1f 93       	push	r17
    18bc:	df 93       	push	r29
    18be:	cf 93       	push	r28
    18c0:	0f 92       	push	r0
    18c2:	cd b7       	in	r28, 0x3d	; 61
    18c4:	de b7       	in	r29, 0x3e	; 62
	unsigned char attempts=0;
	unsigned char aByte=0;
    18c6:	19 82       	std	Y+1, r1	; 0x01
}

/* Exit Command mode of Bluetooth*/
unsigned char _bluetooth_exit_command_mode(void)
{
	unsigned char attempts=0;
    18c8:	ff 24       	eor	r15, r15
				
		_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);
		attempts++;

 		if ((attempts>=255) || (_bluetooth_receive_uart0_byte(&aByte)==0))
    18ca:	8e 01       	movw	r16, r28
    18cc:	0f 5f       	subi	r16, 0xFF	; 255
    18ce:	1f 4f       	sbci	r17, 0xFF	; 255
	unsigned char attempts=0;
	unsigned char aByte=0;

	while(1)  
	{           
		_bluetooth_transmit_uart0_byte('-');		
    18d0:	8d e2       	ldi	r24, 0x2D	; 45
    18d2:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    18d6:	8f e0       	ldi	r24, 0x0F	; 15
    18d8:	97 e2       	ldi	r25, 0x27	; 39
    18da:	01 97       	sbiw	r24, 0x01	; 1
    18dc:	f1 f7       	brne	.-4      	; 0x18da <_bluetooth_exit_command_mode+0x24>
    18de:	00 c0       	rjmp	.+0      	; 0x18e0 <_bluetooth_exit_command_mode+0x2a>
    18e0:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte('-');		
    18e2:	8d e2       	ldi	r24, 0x2D	; 45
    18e4:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    18e8:	8f e0       	ldi	r24, 0x0F	; 15
    18ea:	97 e2       	ldi	r25, 0x27	; 39
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	f1 f7       	brne	.-4      	; 0x18ec <_bluetooth_exit_command_mode+0x36>
    18f0:	00 c0       	rjmp	.+0      	; 0x18f2 <_bluetooth_exit_command_mode+0x3c>
    18f2:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte('-');		
    18f4:	8d e2       	ldi	r24, 0x2D	; 45
    18f6:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    18fa:	8f e0       	ldi	r24, 0x0F	; 15
    18fc:	97 e2       	ldi	r25, 0x27	; 39
    18fe:	01 97       	sbiw	r24, 0x01	; 1
    1900:	f1 f7       	brne	.-4      	; 0x18fe <_bluetooth_exit_command_mode+0x48>
    1902:	00 c0       	rjmp	.+0      	; 0x1904 <_bluetooth_exit_command_mode+0x4e>
    1904:	00 00       	nop
		_delay_ms(5);
				
		_bluetooth_transmit_uart0_byte(13);
    1906:	8d e0       	ldi	r24, 0x0D	; 13
    1908:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
		_bluetooth_transmit_uart0_byte(13);
    190c:	8d e0       	ldi	r24, 0x0D	; 13
    190e:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
		attempts++;
    1912:	f3 94       	inc	r15

 		if ((attempts>=255) || (_bluetooth_receive_uart0_byte(&aByte)==0))
    1914:	9f 2d       	mov	r25, r15
    1916:	9f 3f       	cpi	r25, 0xFF	; 255
    1918:	39 f0       	breq	.+14     	; 0x1928 <_bluetooth_exit_command_mode+0x72>
    191a:	c8 01       	movw	r24, r16
    191c:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_bluetooth_receive_uart0_byte>
    1920:	88 23       	and	r24, r24
    1922:	b1 f6       	brne	.-84     	; 0x18d0 <_bluetooth_exit_command_mode+0x1a>
			break;				
	}

	// succeeded in entering command mode
	if (attempts<255)
		return 1;
    1924:	81 e0       	ldi	r24, 0x01	; 1
    1926:	01 c0       	rjmp	.+2      	; 0x192a <_bluetooth_exit_command_mode+0x74>
	
	return 0;
    1928:	80 e0       	ldi	r24, 0x00	; 0
}
    192a:	0f 90       	pop	r0
    192c:	cf 91       	pop	r28
    192e:	df 91       	pop	r29
    1930:	1f 91       	pop	r17
    1932:	0f 91       	pop	r16
    1934:	ff 90       	pop	r15
    1936:	08 95       	ret

00001938 <_bluetooth_enter_command_mode>:


/* Bluetooth Functions */

unsigned char _bluetooth_enter_command_mode(void)
{
    1938:	0f 93       	push	r16
    193a:	1f 93       	push	r17
    193c:	df 93       	push	r29
    193e:	cf 93       	push	r28
    1940:	00 d0       	rcall	.+0      	; 0x1942 <_bluetooth_enter_command_mode+0xa>
    1942:	cd b7       	in	r28, 0x3d	; 61
    1944:	de b7       	in	r29, 0x3e	; 62
	unsigned char attempts=0;
	unsigned char aByte=0;
    1946:	19 82       	std	Y+1, r1	; 0x01

/* Bluetooth Functions */

unsigned char _bluetooth_enter_command_mode(void)
{
	unsigned char attempts=0;
    1948:	20 e0       	ldi	r18, 0x00	; 0
		_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);*/

		attempts++;

		if (_bluetooth_receive_uart0_byte(&aByte))
    194a:	8e 01       	movw	r16, r28
    194c:	0f 5f       	subi	r16, 0xFF	; 255
    194e:	1f 4f       	sbci	r17, 0xFF	; 255
	unsigned char count=0;

	while(1)  
	{   
		//for (int i=0;(i<255);i++)        
		_bluetooth_transmit_uart0_byte('$');	
    1950:	84 e2       	ldi	r24, 0x24	; 36
    1952:	2a 83       	std	Y+2, r18	; 0x02
    1954:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    1958:	8f e0       	ldi	r24, 0x0F	; 15
    195a:	97 e2       	ldi	r25, 0x27	; 39
    195c:	01 97       	sbiw	r24, 0x01	; 1
    195e:	f1 f7       	brne	.-4      	; 0x195c <_bluetooth_enter_command_mode+0x24>
    1960:	00 c0       	rjmp	.+0      	; 0x1962 <_bluetooth_enter_command_mode+0x2a>
    1962:	00 00       	nop
		_delay_ms(5);	
		_bluetooth_transmit_uart0_byte('$');		
    1964:	84 e2       	ldi	r24, 0x24	; 36
    1966:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    196a:	8f e0       	ldi	r24, 0x0F	; 15
    196c:	97 e2       	ldi	r25, 0x27	; 39
    196e:	01 97       	sbiw	r24, 0x01	; 1
    1970:	f1 f7       	brne	.-4      	; 0x196e <_bluetooth_enter_command_mode+0x36>
    1972:	00 c0       	rjmp	.+0      	; 0x1974 <_bluetooth_enter_command_mode+0x3c>
    1974:	00 00       	nop
		_delay_ms(5);
		_bluetooth_transmit_uart0_byte('$');		
    1976:	84 e2       	ldi	r24, 0x24	; 36
    1978:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    197c:	8f e0       	ldi	r24, 0x0F	; 15
    197e:	97 e2       	ldi	r25, 0x27	; 39
    1980:	01 97       	sbiw	r24, 0x01	; 1
    1982:	f1 f7       	brne	.-4      	; 0x1980 <_bluetooth_enter_command_mode+0x48>
    1984:	00 c0       	rjmp	.+0      	; 0x1986 <_bluetooth_enter_command_mode+0x4e>
    1986:	00 00       	nop
		//_bluetooth_transmit_uart0_byte('$');		
		
		//for (int i=0;(i<10);i++)        		
		
		
		_bluetooth_transmit_uart0_byte(13);	//	RETURN or NEWLINE Character for RN-41
    1988:	8d e0       	ldi	r24, 0x0D	; 13
    198a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
		_bluetooth_transmit_uart0_byte(13);	//	RETURN or NEWLINE Character for RN-41
    198e:	8d e0       	ldi	r24, 0x0D	; 13
    1990:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
		_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);*/

		attempts++;

		if (_bluetooth_receive_uart0_byte(&aByte))
    1994:	c8 01       	movw	r24, r16
    1996:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_bluetooth_receive_uart0_byte>
    199a:	2a 81       	ldd	r18, Y+2	; 0x02
    199c:	88 23       	and	r24, r24
    199e:	81 f0       	breq	.+32     	; 0x19c0 <_bluetooth_enter_command_mode+0x88>
		{			
				if (aByte=='C'){			// RN-41 returns CMD when it enters command mode
    19a0:	89 81       	ldd	r24, Y+1	; 0x01
    19a2:	83 34       	cpi	r24, 0x43	; 67
    19a4:	69 f4       	brne	.+26     	; 0x19c0 <_bluetooth_enter_command_mode+0x88>
					_bluetooth_transmit_uart0_byte(13);						
    19a6:	8d e0       	ldi	r24, 0x0D	; 13
    19a8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    19ac:	0a e0       	ldi	r16, 0x0A	; 10
    19ae:	10 e0       	ldi	r17, 0x00	; 0
					for (int i=0;(i<10);i++)        		
						_bluetooth_transmit_uart0_byte(13);
    19b0:	8d e0       	ldi	r24, 0x0D	; 13
    19b2:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    19b6:	01 50       	subi	r16, 0x01	; 1
    19b8:	10 40       	sbci	r17, 0x00	; 0

		if (_bluetooth_receive_uart0_byte(&aByte))
		{			
				if (aByte=='C'){			// RN-41 returns CMD when it enters command mode
					_bluetooth_transmit_uart0_byte(13);						
					for (int i=0;(i<10);i++)        		
    19ba:	d1 f7       	brne	.-12     	; 0x19b0 <_bluetooth_enter_command_mode+0x78>
						_bluetooth_transmit_uart0_byte(13);
					return 1;	
    19bc:	81 e0       	ldi	r24, 0x01	; 1
    19be:	04 c0       	rjmp	.+8      	; 0x19c8 <_bluetooth_enter_command_mode+0x90>
		_bluetooth_transmit_uart0_byte(13);	//	RETURN or NEWLINE Character for RN-41
		/*_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);
		_bluetooth_transmit_uart0_byte(13);*/

		attempts++;
    19c0:	2f 5f       	subi	r18, 0xFF	; 255
						_bluetooth_transmit_uart0_byte(13);
					return 1;	
				}
		}

 		if (attempts>=255) 
    19c2:	2f 3f       	cpi	r18, 0xFF	; 255
    19c4:	29 f6       	brne	.-118    	; 0x1950 <_bluetooth_enter_command_mode+0x18>
			break;				
	}

	
	return 0;
    19c6:	80 e0       	ldi	r24, 0x00	; 0
}
    19c8:	0f 90       	pop	r0
    19ca:	0f 90       	pop	r0
    19cc:	cf 91       	pop	r28
    19ce:	df 91       	pop	r29
    19d0:	1f 91       	pop	r17
    19d2:	0f 91       	pop	r16
    19d4:	08 95       	ret

000019d6 <_accelerometer_set_sensitivity>:
/* For version 3 the chose sensitivity is 4G */

unsigned char _accelerometer_set_sensitivity(unsigned char level){

#ifdef _VERSION==3
	if (level==_4G){
    19d6:	88 23       	and	r24, r24
    19d8:	11 f4       	brne	.+4      	; 0x19de <_accelerometer_set_sensitivity+0x8>
		cbi(PORTB,OUT_ACCEL_SEL1);
    19da:	28 98       	cbi	0x05, 0	; 5
		return _4G;
    19dc:	08 95       	ret
	}else if (level==_12G){
    19de:	81 30       	cpi	r24, 0x01	; 1
    19e0:	11 f4       	brne	.+4      	; 0x19e6 <_accelerometer_set_sensitivity+0x10>
		sbi(PORTB,OUT_ACCEL_SEL1);		
    19e2:	28 9a       	sbi	0x05, 0	; 5
		return _12G;
    19e4:	08 95       	ret
		sbi(PORTB,OUT_ACCEL_SEL1);
		sbi(PORTB,OUT_ACCEL_SEL2);
		return _6G;
	}
#endif
	return 0;
    19e6:	80 e0       	ldi	r24, 0x00	; 0
}
    19e8:	08 95       	ret

000019ea <_accelerometer_turn_on>:
*/
void _accelerometer_turn_on(void)
{

#ifdef _VERSION 3
	sbi(DDRB,OUT_ACCEL_SEL1);	
    19ea:	20 9a       	sbi	0x04, 0	; 4
	sbi(DDRB,OUT_ACCEL_SLEEP_N);
    19ec:	23 9a       	sbi	0x04, 3	; 4
	sbi(PORTB,OUT_ACCEL_SLEEP_N);	 
    19ee:	2b 9a       	sbi	0x05, 3	; 5
	sbi(DDRB,OUT_ACCEL_SEL2);
	sbi(DDRB,OUT_ACCEL_SLEEP_N);
	sbi(PORTB,OUT_ACCEL_SLEEP_N);
#endif	 			
	// Set the status of the accelerometer to true
	sbi(atmega_status, BIT1_ACCELEROMETER_STATUS);
    19f0:	80 91 70 38 	lds	r24, 0x3870
    19f4:	82 60       	ori	r24, 0x02	; 2
    19f6:	80 93 70 38 	sts	0x3870, r24
}
    19fa:	08 95       	ret

000019fc <_atmega_initialize>:
	
*/
void _atmega_initialize(unsigned char timer_prescalar)
{

	unsigned char prev_osccal=OSCCAL;
    19fc:	80 91 66 00 	lds	r24, 0x0066

	atmega_status=0x00;
    1a00:	10 92 70 38 	sts	0x3870, r1

	//Disable watchdog timer
	//_atmega_disable_watchdog();

	// Disable JTAG interface
	_atmega_disable_JTAG();
    1a04:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <_atmega_disable_JTAG>


#ifdef _VERSION==3
	// By default initialize all ports as input to minimize power consumption
	// Setup Port A pins as input to minimize power consumption		
	cbi(DDRA,IN_ACCEL_Z_FILT);
    1a08:	08 98       	cbi	0x01, 0	; 1
	cbi(DDRA,IN_ACCEL_Y_FILT);
    1a0a:	09 98       	cbi	0x01, 1	; 1
	cbi(DDRA,IN_ACCEL_X_FILT);
    1a0c:	0a 98       	cbi	0x01, 2	; 1
	cbi(DDRA,IN_DOCK_N);
    1a0e:	0b 98       	cbi	0x01, 3	; 1
	cbi(DDRA,IN_USER_N);
    1a10:	0d 98       	cbi	0x01, 5	; 1
	cbi(DDRA,IN_BT_DISC);
    1a12:	0e 98       	cbi	0x01, 6	; 1
	cbi(DDRA,IN_VSENSE_BAT);
    1a14:	0f 98       	cbi	0x01, 7	; 1

	// Setup Port B pins as input to minimize power consumption
	cbi(DDRB,OUT_ACCEL_SEL1);	
    1a16:	20 98       	cbi	0x04, 0	; 4
	cbi(DDRB,PB1);
    1a18:	21 98       	cbi	0x04, 1	; 4
	cbi(PORTB,PB2);
    1a1a:	2a 98       	cbi	0x05, 2	; 5
	cbi(DDRB,OUT_ACCEL_SLEEP_N);
    1a1c:	23 98       	cbi	0x04, 3	; 4
	cbi(DDRB,OUT_BT_SW_N);	
    1a1e:	24 98       	cbi	0x04, 4	; 4
	cbi(DDRB,IN_CPU_PROG_MOSI);
    1a20:	25 98       	cbi	0x04, 5	; 4
	cbi(DDRB,OUT_CPU_PROG_MISO);	
    1a22:	26 98       	cbi	0x04, 6	; 4
	cbi(DDRB,IN_CPU_PROG_SCLK);	
    1a24:	27 98       	cbi	0x04, 7	; 4
	
	// Setup Port C pins as input to minimize power consumption
	cbi(DDRC,PC0);	
    1a26:	38 98       	cbi	0x07, 0	; 7
	cbi(DDRC,PC1);	
    1a28:	39 98       	cbi	0x07, 1	; 7
	cbi(DDRC,PC2);	
    1a2a:	3a 98       	cbi	0x07, 2	; 7
	cbi(DDRC,OUT_LED_YE);	
    1a2c:	3b 98       	cbi	0x07, 3	; 7
	cbi(DDRC,PC4);	
    1a2e:	3c 98       	cbi	0x07, 4	; 7
	cbi(DDRC,PC5);	
    1a30:	3d 98       	cbi	0x07, 5	; 7
	cbi(DDRC,PC6);	
    1a32:	3e 98       	cbi	0x07, 6	; 7
	cbi(DDRC,PC7);	
    1a34:	3f 98       	cbi	0x07, 7	; 7

	// Setup Port D pins as input to minimize power consumption
	cbi(DDRD,IN_BT_RXD);	
    1a36:	50 98       	cbi	0x0a, 0	; 10
	cbi(DDRD,OUT_BT_TXD);	
    1a38:	51 98       	cbi	0x0a, 1	; 10
	cbi(DDRD,OUT_BT_RESET_N);	
    1a3a:	52 98       	cbi	0x0a, 2	; 10
	cbi(DDRD,OUT_LED_GN);	
    1a3c:	53 98       	cbi	0x0a, 3	; 10
	cbi(DDRD,PD4);	
    1a3e:	54 98       	cbi	0x0a, 4	; 10
	cbi(DDRD,PD5);	
    1a40:	55 98       	cbi	0x0a, 5	; 10
	cbi(DDRD,PD6);
    1a42:	56 98       	cbi	0x0a, 6	; 10
	cbi(DDRD,PD7);	
    1a44:	57 98       	cbi	0x0a, 7	; 10
	cbi(DDRD,IN_BT_DISC);	
	cbi(DDRD,PD6);
	cbi(DDRD,PD7);	
#endif
	/* Set peripherials to the lowest power states */
	_bluetooth_turn_on();
    1a46:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <_bluetooth_turn_on>
	_accelerometer_turn_on();
    1a4a:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <_accelerometer_turn_on>
	_accelerometer_set_sensitivity(_4G); /* Sensitivity of the accelerometer is set to 4G*/
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <_accelerometer_set_sensitivity>
		OSCCAL= prev_osccal;	
	}
	
	_yellowled_turn_off();
	*/
	_atmega_initialize_uart0(ATMEGA_BAUD_38400, TX_RX_UART_MODE);	/* Looks like UART0 is being used 
    1a54:	8c e0       	ldi	r24, 0x0C	; 12
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	62 e0       	ldi	r22, 0x02	; 2
    1a5a:	0e 94 4a 0a 	call	0x1494	; 0x1494 <_atmega_initialize_uart0>
	for the radio connection */


	/* Set ADC for conversion */    
    //Set ADC reference to AVCC
     ADMUX |=(1 << REFS0);
    1a5e:	ec e7       	ldi	r30, 0x7C	; 124
    1a60:	f0 e0       	ldi	r31, 0x00	; 0
    1a62:	80 81       	ld	r24, Z
    1a64:	80 64       	ori	r24, 0x40	; 64
    1a66:	80 83       	st	Z, r24
     //Set the ADC conversion clock prescalar       
     _atmega_set_adc_clock(ADC_PRESCALAR_64);
    1a68:	85 e0       	ldi	r24, 0x05	; 5
    1a6a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <_atmega_set_adc_clock>
     //_atmega_adc_turn_on();


	//Turn on ADC conversion_send_data_bufferred
	 _atmega_adc_turn_on();
    1a6e:	0e 94 b9 09 	call	0x1372	; 0x1372 <_atmega_adc_turn_on>

}
    1a72:	08 95       	ret

00001a74 <_accelerometer_turn_off>:
	
*/
void _accelerometer_turn_off(void)
{
#ifdef _VERSION==3
	 _accelerometer_set_sensitivity(_4G);
    1a74:	80 e0       	ldi	r24, 0x00	; 0
    1a76:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <_accelerometer_set_sensitivity>
	 cbi(DDRB,OUT_ACCEL_SEL1);		 
    1a7a:	20 98       	cbi	0x04, 0	; 4
	 sbi(DDRB,OUT_ACCEL_SLEEP_N); //sleep pin in output mode
    1a7c:	23 9a       	sbi	0x04, 3	; 4
	 cbi(PORTB,OUT_ACCEL_SLEEP_N); //clear the pin
    1a7e:	2b 98       	cbi	0x05, 3	; 5
	 cbi(PORTB,OUT_ACCEL_SLEEP_N); //clear the pin
#endif
	 
	 
	 // Set the status of the accelerometer to false
	 cbi(atmega_status, BIT1_ACCELEROMETER_STATUS);
    1a80:	80 91 70 38 	lds	r24, 0x3870
    1a84:	8d 7f       	andi	r24, 0xFD	; 253
    1a86:	80 93 70 38 	sts	0x3870, r24
}
    1a8a:	08 95       	ret

00001a8c <_is_accelerometer_on>:
	
*/

unsigned char _is_accelerometer_on(void)
{
	return ((atmega_status>>BIT1_ACCELEROMETER_STATUS) & 0x01);
    1a8c:	80 91 70 38 	lds	r24, 0x3870
    1a90:	86 95       	lsr	r24
}
    1a92:	81 70       	andi	r24, 0x01	; 1
    1a94:	08 95       	ret

00001a96 <_greenled_turn_on>:
*/

void _greenled_turn_on(void)
{
#ifdef _VERSION==3
	sbi(DDRD,OUT_LED_GN);
    1a96:	53 9a       	sbi	0x0a, 3	; 10
	sbi(PORTD,OUT_LED_GN);
    1a98:	5b 9a       	sbi	0x0b, 3	; 11
	sbi(DDRC,OUT_LED_GN);
	sbi(PORTC,OUT_LED_GN);
#endif
	
	// Set the status of the green led to true
	sbi(atmega_status, BIT2_GREENLED_STATUS); 
    1a9a:	80 91 70 38 	lds	r24, 0x3870
    1a9e:	84 60       	ori	r24, 0x04	; 4
    1aa0:	80 93 70 38 	sts	0x3870, r24
}
    1aa4:	08 95       	ret

00001aa6 <_greenled_turn_off>:

void _greenled_turn_off(void)
{

#ifdef _VERSION==3
	sbi(DDRD,OUT_LED_GN);
    1aa6:	53 9a       	sbi	0x0a, 3	; 10
	cbi(PORTD,OUT_LED_GN);
    1aa8:	5b 98       	cbi	0x0b, 3	; 11
	cbi(DDRD,OUT_LED_GN);
    1aaa:	53 98       	cbi	0x0a, 3	; 10
	cbi(PORTC,OUT_LED_GN);
	cbi(DDRC,OUT_LED_GN);
#endif
	
	// Set the status of the green led to false
	cbi(atmega_status, BIT2_GREENLED_STATUS);
    1aac:	80 91 70 38 	lds	r24, 0x3870
    1ab0:	8b 7f       	andi	r24, 0xFB	; 251
    1ab2:	80 93 70 38 	sts	0x3870, r24

}
    1ab6:	08 95       	ret

00001ab8 <_is_greenled_on>:
	Description: Tests if the green led is on
	
*/
unsigned char _is_greenled_on(void)
{
	return ((atmega_status>>BIT2_GREENLED_STATUS) & 0x01);
    1ab8:	80 91 70 38 	lds	r24, 0x3870
    1abc:	86 95       	lsr	r24
    1abe:	86 95       	lsr	r24
}
    1ac0:	81 70       	andi	r24, 0x01	; 1
    1ac2:	08 95       	ret

00001ac4 <_yellowled_turn_on>:
	Description: This function turns on the yellow led
	
*/
void _yellowled_turn_on(void)
{
	sbi(DDRC,OUT_LED_YE);
    1ac4:	3b 9a       	sbi	0x07, 3	; 7
	sbi(PORTC,OUT_LED_YE);
    1ac6:	43 9a       	sbi	0x08, 3	; 8

	// Set the status of the yellow led to true
	sbi(atmega_status, BIT3_YELLOWLED_STATUS);
    1ac8:	80 91 70 38 	lds	r24, 0x3870
    1acc:	88 60       	ori	r24, 0x08	; 8
    1ace:	80 93 70 38 	sts	0x3870, r24
}
    1ad2:	08 95       	ret

00001ad4 <_yellowled_turn_off>:
	
*/
void _yellowled_turn_off(void)
{

	sbi(DDRC,OUT_LED_YE);
    1ad4:	3b 9a       	sbi	0x07, 3	; 7
	cbi(PORTC,OUT_LED_YE);
    1ad6:	43 98       	cbi	0x08, 3	; 8
	cbi(DDRC,OUT_LED_YE);	
    1ad8:	3b 98       	cbi	0x07, 3	; 7
	
	// Set the status of the yellow led to false
	cbi(atmega_status, BIT3_YELLOWLED_STATUS);
    1ada:	80 91 70 38 	lds	r24, 0x3870
    1ade:	87 7f       	andi	r24, 0xF7	; 247
    1ae0:	80 93 70 38 	sts	0x3870, r24
}
    1ae4:	08 95       	ret

00001ae6 <_atmega_finalize>:
	
*/
void _atmega_finalize(void)
{
	//cli();
	_bluetooth_turn_off();
    1ae6:	0e 94 de 0a 	call	0x15bc	; 0x15bc <_bluetooth_turn_off>
//	_accelerometer_turn_off();
	_greenled_turn_off();
    1aea:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>
	_yellowled_turn_off();
    1aee:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>

	//Set all ports as inputs
	DDRA=0x00;
    1af2:	11 b8       	out	0x01, r1	; 1
	DDRB=0x00;
    1af4:	14 b8       	out	0x04, r1	; 4
	DDRC=0x00;
    1af6:	17 b8       	out	0x07, r1	; 7
	DDRD=0x00;
    1af8:	1a b8       	out	0x0a, r1	; 10

	PORTA=0x00;
    1afa:	12 b8       	out	0x02, r1	; 2
	PORTB=0x00;
    1afc:	15 b8       	out	0x05, r1	; 5
	PORTC=0x00;
    1afe:	18 b8       	out	0x08, r1	; 8
	PORTD=0x00;
    1b00:	1b b8       	out	0x0b, r1	; 11

	// Disable timer
	_atmega_disable_timer2();
    1b02:	0e 94 b5 0a 	call	0x156a	; 0x156a <_atmega_disable_timer2>

	//Disable watchdog
	wdt_disable();
    1b06:	88 e1       	ldi	r24, 0x18	; 24
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	f8 94       	cli
    1b0c:	80 93 60 00 	sts	0x0060, r24
    1b10:	10 92 60 00 	sts	0x0060, r1
    1b14:	0f be       	out	0x3f, r0	; 63

	//Disable ADC Conversion
//
	_atmega_adc_turn_off();
    1b16:	0e 94 bf 09 	call	0x137e	; 0x137e <_atmega_adc_turn_off>


	// Disable pull-ups
  	MCUCR |= (1u << PUD); 
    1b1a:	85 b7       	in	r24, 0x35	; 53
    1b1c:	80 61       	ori	r24, 0x10	; 16
    1b1e:	85 bf       	out	0x35, r24	; 53
	// Disable Analog comparitor
  	ACSR &= ~(1<<ACIE);   // Disable analog comparator interrupt
    1b20:	80 b7       	in	r24, 0x30	; 48
    1b22:	87 7f       	andi	r24, 0xF7	; 247
    1b24:	80 bf       	out	0x30, r24	; 48
  	ACSR |= (1<<ACD);     // Disable analog comparitor 
    1b26:	80 b7       	in	r24, 0x30	; 48
    1b28:	80 68       	ori	r24, 0x80	; 128
    1b2a:	80 bf       	out	0x30, r24	; 48
	// Power Reduction Register, everything off;
  	//PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTWI)); 

	//Power down the MCU

	sleep_enable();
    1b2c:	83 b7       	in	r24, 0x33	; 51
    1b2e:	81 60       	ori	r24, 0x01	; 1
    1b30:	83 bf       	out	0x33, r24	; 51
    //sleep_bod_disable();
    sei();	
    1b32:	78 94       	sei
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
    1b34:	83 b7       	in	r24, 0x33	; 51
    1b36:	81 7f       	andi	r24, 0xF1	; 241
    1b38:	84 60       	ori	r24, 0x04	; 4
    1b3a:	83 bf       	out	0x33, r24	; 51
	sleep_cpu();
    1b3c:	88 95       	sleep
    sleep_disable();
    1b3e:	83 b7       	in	r24, 0x33	; 51
    1b40:	8e 7f       	andi	r24, 0xFE	; 254
    1b42:	83 bf       	out	0x33, r24	; 51

}
    1b44:	08 95       	ret

00001b46 <_wocket_reset>:


void _wocket_reset(void)
{
	_atmega_initialize(CPU_CLK_PRESCALAR_1024);
    1b46:	86 e0       	ldi	r24, 0x06	; 6
    1b48:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <_atmega_initialize>
	_atmega_finalize();
    1b4c:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <_atmega_finalize>
}
    1b50:	08 95       	ret

00001b52 <_is_yellowled_on>:
	Description: Tests if the yellow led is on
	
*/
unsigned char _is_yellowled_on(void)
{
	return ((atmega_status>>BIT3_YELLOWLED_STATUS) & 0x01);
    1b52:	80 91 70 38 	lds	r24, 0x3870
    1b56:	86 95       	lsr	r24
    1b58:	86 95       	lsr	r24
    1b5a:	86 95       	lsr	r24
}
    1b5c:	81 70       	andi	r24, 0x01	; 1
    1b5e:	08 95       	ret

00001b60 <_is_docked>:
	Description: Tests if the wocket is docked
	
*/
unsigned char _is_docked(void)
{	
	return (!( 0x01 & (PINA>>IN_DOCK_N)));
    1b60:	90 b1       	in	r25, 0x00	; 0
    1b62:	81 e0       	ldi	r24, 0x01	; 1
    1b64:	93 fd       	sbrc	r25, 3
    1b66:	80 e0       	ldi	r24, 0x00	; 0
}
    1b68:	08 95       	ret

00001b6a <_wocket_initialize_timer2_interrupt>:
	 to increase every 1024 cycles: (8000000/1024= 7812.5). So, the counter need to overflow with ticks=7812.5/_SAMPLING_RATE. When the counter overflows, an overflow interrupt gets invoked to show the approximate sampling time
	 for the accelerometer.	
*/
void _wocket_initialize_timer2_interrupt(void)
{
	unsigned short ticks = (unsigned short) ((F_CPU / 1024) / _SAMPLING_RATE); 	
    1b6a:	20 91 06 01 	lds	r18, 0x0106
    1b6e:	30 e0       	ldi	r19, 0x00	; 0
    1b70:	40 e0       	ldi	r20, 0x00	; 0
    1b72:	50 e0       	ldi	r21, 0x00	; 0
    1b74:	64 e8       	ldi	r22, 0x84	; 132
    1b76:	7e e1       	ldi	r23, 0x1E	; 30
    1b78:	80 e0       	ldi	r24, 0x00	; 0
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	0e 94 5b 18 	call	0x30b6	; 0x30b6 <__divmodsi4>
    1b80:	82 2f       	mov	r24, r18
    1b82:	80 95       	com	r24

	if (ticks > 256)
    1b84:	91 e0       	ldi	r25, 0x01	; 1
    1b86:	21 30       	cpi	r18, 0x01	; 1
    1b88:	39 07       	cpc	r19, r25
    1b8a:	28 f0       	brcs	.+10     	; 0x1b96 <_wocket_initialize_timer2_interrupt+0x2c>
	{
		_wTCNT2 = 0;
    1b8c:	10 92 4c 01 	sts	0x014C, r1
		_wTCNT2_reps = (ticks / 256);
    1b90:	30 93 07 01 	sts	0x0107, r19
    1b94:	05 c0       	rjmp	.+10     	; 0x1ba0 <_wocket_initialize_timer2_interrupt+0x36>
		_wTCNT2_last = 255 - (ticks % 256);
	}else
	{
		_wTCNT2= 255 - ticks;
    1b96:	80 93 4c 01 	sts	0x014C, r24
		_wTCNT2_reps = 0;
    1b9a:	10 92 07 01 	sts	0x0107, r1
		_wTCNT2_last = 255;
    1b9e:	8f ef       	ldi	r24, 0xFF	; 255
    1ba0:	80 93 4d 01 	sts	0x014D, r24
    1ba4:	08 95       	ret

00001ba6 <_wocket_initialize>:
}

//-------------------------------------------	

void _wocket_initialize(void) //This function initializes the wocket
{
    1ba6:	0f 93       	push	r16
    1ba8:	1f 93       	push	r17
    1baa:	cf 93       	push	r28
    1bac:	df 93       	push	r29
	// Disable the watchdog timer. It has to be done at the beginning of the program.
	_atmega_disable_watchdog();
    1bae:	0e 94 c9 0a 	call	0x1592	; 0x1592 <_atmega_disable_watchdog>
	_atmega_initialize(CPU_CLK_PRESCALAR_1024);
    1bb2:	86 e0       	ldi	r24, 0x06	; 6
    1bb4:	0e 94 fe 0c 	call	0x19fc	; 0x19fc <_atmega_initialize>
	num_skipped_timer_interrupts = 10;//(F_CPU/1024)/PERFECT_SAMPLING_FREQUENCY;
    1bb8:	8a e0       	ldi	r24, 0x0A	; 10
    1bba:	80 93 72 38 	sts	0x3872, r24
	
	unsigned short battery = _atmega_a2dConvert10bit(IN_VSENSE_BAT);
    1bbe:	87 e0       	ldi	r24, 0x07	; 7
    1bc0:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
    1bc4:	ec 01       	movw	r28, r24
	if (battery < 700)
    1bc6:	82 e0       	ldi	r24, 0x02	; 2
    1bc8:	cc 3b       	cpi	r28, 0xBC	; 188
    1bca:	d8 07       	cpc	r29, r24
    1bcc:	00 f5       	brcc	.+64     	; 0x1c0e <_wocket_initialize+0x68>
    1bce:	03 e0       	ldi	r16, 0x03	; 3
    1bd0:	10 e0       	ldi	r17, 0x00	; 0
	{// Blink yellow 3times for 5 seconds if the battery is not fully charged 
		for (int i = 0; (i < 3); i++){
			_yellowled_turn_on();		
    1bd2:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <_yellowled_turn_on>
    1bd6:	88 ec       	ldi	r24, 0xC8	; 200
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	af e0       	ldi	r26, 0x0F	; 15
    1bdc:	b7 e2       	ldi	r27, 0x27	; 39
    1bde:	11 97       	sbiw	r26, 0x01	; 1
    1be0:	f1 f7       	brne	.-4      	; 0x1bde <_wocket_initialize+0x38>
    1be2:	00 c0       	rjmp	.+0      	; 0x1be4 <_wocket_initialize+0x3e>
    1be4:	00 00       	nop
    1be6:	01 97       	sbiw	r24, 0x01	; 1
			for (int j = 0; (j < 200); j++)
    1be8:	c1 f7       	brne	.-16     	; 0x1bda <_wocket_initialize+0x34>
				_delay_ms(5);
			_yellowled_turn_off();
    1bea:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>
    1bee:	88 ec       	ldi	r24, 0xC8	; 200
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	ef e0       	ldi	r30, 0x0F	; 15
    1bf4:	f7 e2       	ldi	r31, 0x27	; 39
    1bf6:	31 97       	sbiw	r30, 0x01	; 1
    1bf8:	f1 f7       	brne	.-4      	; 0x1bf6 <_wocket_initialize+0x50>
    1bfa:	00 c0       	rjmp	.+0      	; 0x1bfc <_wocket_initialize+0x56>
    1bfc:	00 00       	nop
    1bfe:	01 97       	sbiw	r24, 0x01	; 1
			for (int j = 0; (j < 200); j++)
    1c00:	c1 f7       	brne	.-16     	; 0x1bf2 <_wocket_initialize+0x4c>
    1c02:	01 50       	subi	r16, 0x01	; 1
    1c04:	10 40       	sbci	r17, 0x00	; 0
	num_skipped_timer_interrupts = 10;//(F_CPU/1024)/PERFECT_SAMPLING_FREQUENCY;
	
	unsigned short battery = _atmega_a2dConvert10bit(IN_VSENSE_BAT);
	if (battery < 700)
	{// Blink yellow 3times for 5 seconds if the battery is not fully charged 
		for (int i = 0; (i < 3); i++){
    1c06:	29 f7       	brne	.-54     	; 0x1bd2 <_wocket_initialize+0x2c>
			for (int j = 0; (j < 200); j++)
				_delay_ms(5);
		}
	}
	
	if (battery > 100)
    1c08:	c5 36       	cpi	r28, 0x65	; 101
    1c0a:	d1 05       	cpc	r29, r1
    1c0c:	50 f0       	brcs	.+20     	; 0x1c22 <_wocket_initialize+0x7c>
	{//Load the status byte from the EEPROM  
		_INITIALIZED = eeprom_read_byte(&_NV_INITIALIZED);		
    1c0e:	80 e0       	ldi	r24, 0x00	; 0
    1c10:	90 e0       	ldi	r25, 0x00	; 0
    1c12:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1c16:	80 93 4a 01 	sts	0x014A, r24
		_atmega_finalize();
		return;
	}
	
	// If the wocket has been initialized before, read the parameters from EEPROM and blinks green once	
	if (_INITIALIZED == _WOCKET_INITIALIZED)
    1c1a:	85 32       	cpi	r24, 0x25	; 37
    1c1c:	09 f0       	breq	.+2      	; 0x1c20 <_wocket_initialize+0x7a>
    1c1e:	b3 c0       	rjmp	.+358    	; 0x1d86 <_wocket_initialize+0x1e0>
    1c20:	1a c0       	rjmp	.+52     	; 0x1c56 <_wocket_initialize+0xb0>
	{//Load the status byte from the EEPROM  
		_INITIALIZED = eeprom_read_byte(&_NV_INITIALIZED);		
	}
	else
	{ //turn on the yellow led for 5 seconds then shutdown 
		_yellowled_turn_on();		
    1c22:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <_yellowled_turn_on>
    1c26:	88 ee       	ldi	r24, 0xE8	; 232
    1c28:	93 e0       	ldi	r25, 0x03	; 3
    1c2a:	af e0       	ldi	r26, 0x0F	; 15
    1c2c:	b7 e2       	ldi	r27, 0x27	; 39
    1c2e:	11 97       	sbiw	r26, 0x01	; 1
    1c30:	f1 f7       	brne	.-4      	; 0x1c2e <_wocket_initialize+0x88>
    1c32:	00 c0       	rjmp	.+0      	; 0x1c34 <_wocket_initialize+0x8e>
    1c34:	00 00       	nop
    1c36:	01 97       	sbiw	r24, 0x01	; 1
		for(int  i = 0; (i < 1000); i++)
    1c38:	c1 f7       	brne	.-16     	; 0x1c2a <_wocket_initialize+0x84>
			_delay_ms(5);
		_yellowled_turn_off();
    1c3a:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>
    1c3e:	8f ef       	ldi	r24, 0xFF	; 255
    1c40:	94 e3       	ldi	r25, 0x34	; 52
    1c42:	ac e0       	ldi	r26, 0x0C	; 12
    1c44:	81 50       	subi	r24, 0x01	; 1
    1c46:	90 40       	sbci	r25, 0x00	; 0
    1c48:	a0 40       	sbci	r26, 0x00	; 0
    1c4a:	e1 f7       	brne	.-8      	; 0x1c44 <_wocket_initialize+0x9e>
    1c4c:	00 c0       	rjmp	.+0      	; 0x1c4e <_wocket_initialize+0xa8>
    1c4e:	00 00       	nop
		_delay_ms(500);
		_atmega_finalize();
    1c50:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <_atmega_finalize>
		return;
    1c54:	da c1       	rjmp	.+948    	; 0x200a <_wocket_initialize+0x464>
	}
	
	// If the wocket has been initialized before, read the parameters from EEPROM and blinks green once	
	if (_INITIALIZED == _WOCKET_INITIALIZED)
	{		
		if (battery > 300)
    1c56:	91 e0       	ldi	r25, 0x01	; 1
    1c58:	cd 32       	cpi	r28, 0x2D	; 45
    1c5a:	d9 07       	cpc	r29, r25
    1c5c:	08 f4       	brcc	.+2      	; 0x1c60 <_wocket_initialize+0xba>
    1c5e:	b0 c1       	rjmp	.+864    	; 0x1fc0 <_wocket_initialize+0x41a>
		{
			_SAMPLING_RATE = eeprom_read_byte(&_NV_SAMPLING_RATE);
    1c60:	82 e0       	ldi	r24, 0x02	; 2
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1c68:	80 93 06 01 	sts	0x0106, r24
			_wTM = eeprom_read_byte(&_NV_WTM);
    1c6c:	87 e0       	ldi	r24, 0x07	; 7
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1c74:	80 93 4e 01 	sts	0x014E, r24

			_wTCNT2 = eeprom_read_byte(&_NV_TCT);
    1c78:	83 e0       	ldi	r24, 0x03	; 3
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1c80:	80 93 4c 01 	sts	0x014C, r24
			_wTCNT2_reps = eeprom_read_byte(&_NV_TCTREPS);
    1c84:	84 e0       	ldi	r24, 0x04	; 4
    1c86:	90 e0       	ldi	r25, 0x00	; 0
    1c88:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1c8c:	80 93 07 01 	sts	0x0107, r24
			_wTCNT2_last = eeprom_read_byte(&_NV_TCTLAST);
    1c90:	85 e0       	ldi	r24, 0x05	; 5
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1c98:	80 93 4d 01 	sts	0x014D, r24

			_wBTCAL100 = eeprom_read_word(&_NV_BTCAL100);
    1c9c:	89 e0       	ldi	r24, 0x09	; 9
    1c9e:	90 e0       	ldi	r25, 0x00	; 0
    1ca0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1ca4:	90 93 7c 38 	sts	0x387C, r25
    1ca8:	80 93 7b 38 	sts	0x387B, r24
			_wBTCAL80  = eeprom_read_word(&_NV_BTCAL80);
    1cac:	8b e0       	ldi	r24, 0x0B	; 11
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1cb4:	90 93 8b 38 	sts	0x388B, r25
    1cb8:	80 93 8a 38 	sts	0x388A, r24
			_wBTCAL60  = eeprom_read_word(&_NV_BTCAL60);
    1cbc:	8d e0       	ldi	r24, 0x0D	; 13
    1cbe:	90 e0       	ldi	r25, 0x00	; 0
    1cc0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1cc4:	90 93 84 38 	sts	0x3884, r25
    1cc8:	80 93 83 38 	sts	0x3883, r24
			_wBTCAL40  = eeprom_read_word(&_NV_BTCAL40);
    1ccc:	8f e0       	ldi	r24, 0x0F	; 15
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1cd4:	90 93 82 38 	sts	0x3882, r25
    1cd8:	80 93 81 38 	sts	0x3881, r24
			_wBTCAL20  = eeprom_read_word(&_NV_BTCAL20);
    1cdc:	81 e1       	ldi	r24, 0x11	; 17
    1cde:	90 e0       	ldi	r25, 0x00	; 0
    1ce0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1ce4:	90 93 78 38 	sts	0x3878, r25
    1ce8:	80 93 77 38 	sts	0x3877, r24
			_wBTCAL10  = eeprom_read_word(&_NV_BTCAL10);
    1cec:	83 e1       	ldi	r24, 0x13	; 19
    1cee:	90 e0       	ldi	r25, 0x00	; 0
    1cf0:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1cf4:	90 93 88 38 	sts	0x3888, r25
    1cf8:	80 93 87 38 	sts	0x3887, r24

			_wX1G_CAL  = eeprom_read_word(&_NV_X1G_CAL);
    1cfc:	85 e1       	ldi	r24, 0x15	; 21
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1d04:	90 93 74 38 	sts	0x3874, r25
    1d08:	80 93 73 38 	sts	0x3873, r24
			_wXN1G_CAL = eeprom_read_word(&_NV_XN1G_CAL);
    1d0c:	87 e1       	ldi	r24, 0x17	; 23
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1d14:	90 93 76 38 	sts	0x3876, r25
    1d18:	80 93 75 38 	sts	0x3875, r24
			_wY1G_CAL  = eeprom_read_word(&_NV_Y1G_CAL);
    1d1c:	89 e1       	ldi	r24, 0x19	; 25
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1d24:	90 93 8e 38 	sts	0x388E, r25
    1d28:	80 93 8d 38 	sts	0x388D, r24
			_wYN1G_CAL = eeprom_read_word(&_NV_YN1G_CAL);
    1d2c:	8b e1       	ldi	r24, 0x1B	; 27
    1d2e:	90 e0       	ldi	r25, 0x00	; 0
    1d30:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1d34:	90 93 7a 38 	sts	0x387A, r25
    1d38:	80 93 79 38 	sts	0x3879, r24
			_wZ1G_CAL  = eeprom_read_word(&_NV_Z1G_CAL);
    1d3c:	8d e1       	ldi	r24, 0x1D	; 29
    1d3e:	90 e0       	ldi	r25, 0x00	; 0
    1d40:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1d44:	90 93 80 38 	sts	0x3880, r25
    1d48:	80 93 7f 38 	sts	0x387F, r24
			_wZN1G_CAL = eeprom_read_word(&_NV_ZN1G_CAL);
    1d4c:	8f e1       	ldi	r24, 0x1F	; 31
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	0e 94 7e 18 	call	0x30fc	; 0x30fc <__eerd_word_m1284p>
    1d54:	90 93 7e 38 	sts	0x387E, r25
    1d58:	80 93 7d 38 	sts	0x387D, r24

			_wPDT = eeprom_read_byte(&_NV_PDT);
    1d5c:	81 e2       	ldi	r24, 0x21	; 33
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	0e 94 76 18 	call	0x30ec	; 0x30ec <__eerd_byte_m1284p>
    1d64:	80 93 85 38 	sts	0x3885, r24

			_greenled_turn_on();		
    1d68:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_greenled_turn_on>
    1d6c:	88 ec       	ldi	r24, 0xC8	; 200
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	af e1       	ldi	r26, 0x1F	; 31
    1d72:	be e4       	ldi	r27, 0x4E	; 78
    1d74:	11 97       	sbiw	r26, 0x01	; 1
    1d76:	f1 f7       	brne	.-4      	; 0x1d74 <_wocket_initialize+0x1ce>
    1d78:	00 c0       	rjmp	.+0      	; 0x1d7a <_wocket_initialize+0x1d4>
    1d7a:	00 00       	nop
    1d7c:	01 97       	sbiw	r24, 0x01	; 1
			for(int i = 0; (i < 200); i++)
    1d7e:	c1 f7       	brne	.-16     	; 0x1d70 <_wocket_initialize+0x1ca>
				_delay_ms(10);
			_greenled_turn_off();
    1d80:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>
    1d84:	1d c1       	rjmp	.+570    	; 0x1fc0 <_wocket_initialize+0x41a>

		
	// If the wocket has never been initialized, write the default settings and blink green 3 times 
	else
	{ 
		_SAMPLING_RATE = 40; 
    1d86:	08 e2       	ldi	r16, 0x28	; 40
    1d88:	00 93 06 01 	sts	0x0106, r16
		_wTM = _WTM_Continuous;
    1d8c:	10 92 4e 01 	sts	0x014E, r1
		//_wTM = _WTM_Burst_60;

		// Calculate the timer variables used to sample at the right frequency
		_wocket_initialize_timer2_interrupt();
    1d90:	0e 94 b5 0d 	call	0x1b6a	; 0x1b6a <_wocket_initialize_timer2_interrupt>
		
		// Set the overflow interrupt timer 		
		switch(_wTM)
    1d94:	80 91 4e 01 	lds	r24, 0x014E
    1d98:	82 30       	cpi	r24, 0x02	; 2
    1d9a:	81 f0       	breq	.+32     	; 0x1dbc <_wocket_initialize+0x216>
    1d9c:	83 30       	cpi	r24, 0x03	; 3
    1d9e:	28 f4       	brcc	.+10     	; 0x1daa <_wocket_initialize+0x204>
    1da0:	88 23       	and	r24, r24
    1da2:	41 f0       	breq	.+16     	; 0x1db4 <_wocket_initialize+0x20e>
    1da4:	81 30       	cpi	r24, 0x01	; 1
    1da6:	91 f4       	brne	.+36     	; 0x1dcc <_wocket_initialize+0x226>
    1da8:	07 c0       	rjmp	.+14     	; 0x1db8 <_wocket_initialize+0x212>
    1daa:	83 30       	cpi	r24, 0x03	; 3
    1dac:	51 f0       	breq	.+20     	; 0x1dc2 <_wocket_initialize+0x21c>
    1dae:	84 30       	cpi	r24, 0x04	; 4
    1db0:	69 f4       	brne	.+26     	; 0x1dcc <_wocket_initialize+0x226>
    1db2:	09 c0       	rjmp	.+18     	; 0x1dc6 <_wocket_initialize+0x220>
		{
			case _WTM_Continuous:	
				_MAX_SAMPLING_RATE = 126; //This limitation is due to the definition of SEND_SR  and GET_SR commands
    1db4:	8e e7       	ldi	r24, 0x7E	; 126
    1db6:	08 c0       	rjmp	.+16     	; 0x1dc8 <_wocket_initialize+0x222>
				break;					  // The MCU provided in wocket able to sample at higher rates 								
			case _WTM_Burst_30:    	//a transfer mode that send the burst every 30 secs
				_MAX_SAMPLING_RATE = 80;		
    1db8:	80 e5       	ldi	r24, 0x50	; 80
    1dba:	06 c0       	rjmp	.+12     	; 0x1dc8 <_wocket_initialize+0x222>
				break;
			case _WTM_Burst_60:		//a transfer mode that send the burst every 60 secs
				_MAX_SAMPLING_RATE = 40;		
    1dbc:	00 93 5f 01 	sts	0x015F, r16
				break;
    1dc0:	05 c0       	rjmp	.+10     	; 0x1dcc <_wocket_initialize+0x226>
			case _WTM_Burst_90:		//a transfer mode that send the burst every 90 secs
				_MAX_SAMPLING_RATE = 30;		
    1dc2:	8e e1       	ldi	r24, 0x1E	; 30
    1dc4:	01 c0       	rjmp	.+2      	; 0x1dc8 <_wocket_initialize+0x222>
				break;
			case _WTM_Burst_120:		//a transfer mode that send the burst every 120 secs
				_MAX_SAMPLING_RATE = 20;		
    1dc6:	84 e1       	ldi	r24, 0x14	; 20
    1dc8:	80 93 5f 01 	sts	0x015F, r24
				break;
			default:
				break;
		}
		
		if (_SAMPLING_RATE > _MAX_SAMPLING_RATE)
    1dcc:	80 91 5f 01 	lds	r24, 0x015F
    1dd0:	90 91 06 01 	lds	r25, 0x0106
    1dd4:	89 17       	cp	r24, r25
    1dd6:	10 f4       	brcc	.+4      	; 0x1ddc <_wocket_initialize+0x236>
		{
			_SAMPLING_RATE = _MAX_SAMPLING_RATE;
    1dd8:	80 93 06 01 	sts	0x0106, r24
		
		}
		if (_SAMPLING_RATE < _MIN_SAMPLING_RATE)
    1ddc:	80 91 0b 01 	lds	r24, 0x010B
    1de0:	90 91 06 01 	lds	r25, 0x0106
    1de4:	98 17       	cp	r25, r24
    1de6:	10 f4       	brcc	.+4      	; 0x1dec <_wocket_initialize+0x246>
		{
			_SAMPLING_RATE = _MIN_SAMPLING_RATE;		
    1de8:	80 93 06 01 	sts	0x0106, r24
		}
			
		
		if (battery > 300)
    1dec:	b1 e0       	ldi	r27, 0x01	; 1
    1dee:	cd 32       	cpi	r28, 0x2D	; 45
    1df0:	db 07       	cpc	r29, r27
    1df2:	08 f4       	brcc	.+2      	; 0x1df6 <_wocket_initialize+0x250>
    1df4:	c1 c0       	rjmp	.+386    	; 0x1f78 <_wocket_initialize+0x3d2>
		{	
			// Write the parameters to the EEPROM
			eeprom_write_byte(&_NV_SAMPLING_RATE,_SAMPLING_RATE);
    1df6:	82 e0       	ldi	r24, 0x02	; 2
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	60 91 06 01 	lds	r22, 0x0106
    1dfe:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
				
			eeprom_write_byte(&_NV_TCT,_wTCNT2);
    1e02:	83 e0       	ldi	r24, 0x03	; 3
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	60 91 4c 01 	lds	r22, 0x014C
    1e0a:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
			eeprom_write_byte(&_NV_TCTREPS,_wTCNT2_reps);
    1e0e:	84 e0       	ldi	r24, 0x04	; 4
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	60 91 07 01 	lds	r22, 0x0107
    1e16:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
			eeprom_write_byte(&_NV_TCTLAST,_wTCNT2_last);			
    1e1a:	85 e0       	ldi	r24, 0x05	; 5
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	60 91 4d 01 	lds	r22, 0x014D
    1e22:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>

			eeprom_write_byte(&_NV_WTM,_wTM);
    1e26:	87 e0       	ldi	r24, 0x07	; 7
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	60 91 4e 01 	lds	r22, 0x014E
    1e2e:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
			eeprom_write_byte(&_NV_STATUS_BYTE,0x00);
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	60 e0       	ldi	r22, 0x00	; 0
    1e38:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
			eeprom_write_byte(&_NV_SENS,_wSENS);
    1e3c:	88 e0       	ldi	r24, 0x08	; 8
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	60 91 08 01 	lds	r22, 0x0108
    1e44:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>

			//Set default battery calibration values
			eeprom_write_word(&_NV_BTCAL100,_DEFAULTBTCAL100);
    1e48:	89 e0       	ldi	r24, 0x09	; 9
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	65 ed       	ldi	r22, 0xD5	; 213
    1e4e:	72 e0       	ldi	r23, 0x02	; 2
    1e50:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_BTCAL80, _DEFAULTBTCAL80);
    1e54:	8b e0       	ldi	r24, 0x0B	; 11
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	68 ea       	ldi	r22, 0xA8	; 168
    1e5a:	72 e0       	ldi	r23, 0x02	; 2
    1e5c:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_BTCAL60, _DEFAULTBTCAL60);
    1e60:	8d e0       	ldi	r24, 0x0D	; 13
    1e62:	90 e0       	ldi	r25, 0x00	; 0
    1e64:	60 e8       	ldi	r22, 0x80	; 128
    1e66:	72 e0       	ldi	r23, 0x02	; 2
    1e68:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_BTCAL40, _DEFAULTBTCAL40);
    1e6c:	8f e0       	ldi	r24, 0x0F	; 15
    1e6e:	90 e0       	ldi	r25, 0x00	; 0
    1e70:	68 e5       	ldi	r22, 0x58	; 88
    1e72:	72 e0       	ldi	r23, 0x02	; 2
    1e74:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_BTCAL20, _DEFAULTBTCAL20);
    1e78:	81 e1       	ldi	r24, 0x11	; 17
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	60 e3       	ldi	r22, 0x30	; 48
    1e7e:	72 e0       	ldi	r23, 0x02	; 2
    1e80:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_BTCAL10, _DEFAULTBTCAL10);
    1e84:	83 e1       	ldi	r24, 0x13	; 19
    1e86:	90 e0       	ldi	r25, 0x00	; 0
    1e88:	6c e1       	ldi	r22, 0x1C	; 28
    1e8a:	72 e0       	ldi	r23, 0x02	; 2
    1e8c:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>

			_wBTCAL100 = _DEFAULTBTCAL100;
    1e90:	85 ed       	ldi	r24, 0xD5	; 213
    1e92:	92 e0       	ldi	r25, 0x02	; 2
    1e94:	90 93 7c 38 	sts	0x387C, r25
    1e98:	80 93 7b 38 	sts	0x387B, r24
			_wBTCAL80  = _DEFAULTBTCAL80;
    1e9c:	88 ea       	ldi	r24, 0xA8	; 168
    1e9e:	92 e0       	ldi	r25, 0x02	; 2
    1ea0:	90 93 8b 38 	sts	0x388B, r25
    1ea4:	80 93 8a 38 	sts	0x388A, r24
			_wBTCAL60  = _DEFAULTBTCAL60;
    1ea8:	80 e8       	ldi	r24, 0x80	; 128
    1eaa:	92 e0       	ldi	r25, 0x02	; 2
    1eac:	90 93 84 38 	sts	0x3884, r25
    1eb0:	80 93 83 38 	sts	0x3883, r24
			_wBTCAL40  = _DEFAULTBTCAL40;
    1eb4:	88 e5       	ldi	r24, 0x58	; 88
    1eb6:	92 e0       	ldi	r25, 0x02	; 2
    1eb8:	90 93 82 38 	sts	0x3882, r25
    1ebc:	80 93 81 38 	sts	0x3881, r24
			_wBTCAL20  = _DEFAULTBTCAL20;
    1ec0:	80 e3       	ldi	r24, 0x30	; 48
    1ec2:	92 e0       	ldi	r25, 0x02	; 2
    1ec4:	90 93 78 38 	sts	0x3878, r25
    1ec8:	80 93 77 38 	sts	0x3877, r24
			_wBTCAL10  = _DEFAULTBTCAL10;
    1ecc:	8c e1       	ldi	r24, 0x1C	; 28
    1ece:	92 e0       	ldi	r25, 0x02	; 2
    1ed0:	90 93 88 38 	sts	0x3888, r25
    1ed4:	80 93 87 38 	sts	0x3887, r24

			//Set default Accelerometer calibration values
			eeprom_write_word(&_NV_X1G_CAL, _DEFAULT_X1G_CAL);
    1ed8:	85 e1       	ldi	r24, 0x15	; 21
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	64 ef       	ldi	r22, 0xF4	; 244
    1ede:	71 e0       	ldi	r23, 0x01	; 1
    1ee0:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_XN1G_CAL,_DEFAULT_XN1G_CAL);
    1ee4:	87 e1       	ldi	r24, 0x17	; 23
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	65 ef       	ldi	r22, 0xF5	; 245
    1eea:	71 e0       	ldi	r23, 0x01	; 1
    1eec:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_Y1G_CAL, _DEFAULT_Y1G_CAL);
    1ef0:	89 e1       	ldi	r24, 0x19	; 25
    1ef2:	90 e0       	ldi	r25, 0x00	; 0
    1ef4:	66 ef       	ldi	r22, 0xF6	; 246
    1ef6:	71 e0       	ldi	r23, 0x01	; 1
    1ef8:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_YN1G_CAL,_DEFAULT_YN1G_CAL);
    1efc:	8b e1       	ldi	r24, 0x1B	; 27
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	67 ef       	ldi	r22, 0xF7	; 247
    1f02:	71 e0       	ldi	r23, 0x01	; 1
    1f04:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_Z1G_CAL, _DEFAULT_Z1G_CAL);
    1f08:	8d e1       	ldi	r24, 0x1D	; 29
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	68 ef       	ldi	r22, 0xF8	; 248
    1f0e:	71 e0       	ldi	r23, 0x01	; 1
    1f10:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
			eeprom_write_word(&_NV_ZN1G_CAL,_DEFAULT_ZN1G_CAL);
    1f14:	8f e1       	ldi	r24, 0x1F	; 31
    1f16:	90 e0       	ldi	r25, 0x00	; 0
    1f18:	69 ef       	ldi	r22, 0xF9	; 249
    1f1a:	71 e0       	ldi	r23, 0x01	; 1
    1f1c:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>

			_wX1G_CAL  = _DEFAULT_X1G_CAL;
    1f20:	84 ef       	ldi	r24, 0xF4	; 244
    1f22:	91 e0       	ldi	r25, 0x01	; 1
    1f24:	90 93 74 38 	sts	0x3874, r25
    1f28:	80 93 73 38 	sts	0x3873, r24
			_wXN1G_CAL = _DEFAULT_XN1G_CAL;
    1f2c:	85 ef       	ldi	r24, 0xF5	; 245
    1f2e:	91 e0       	ldi	r25, 0x01	; 1
    1f30:	90 93 76 38 	sts	0x3876, r25
    1f34:	80 93 75 38 	sts	0x3875, r24
			_wY1G_CAL  = _DEFAULT_Y1G_CAL;
    1f38:	86 ef       	ldi	r24, 0xF6	; 246
    1f3a:	91 e0       	ldi	r25, 0x01	; 1
    1f3c:	90 93 8e 38 	sts	0x388E, r25
    1f40:	80 93 8d 38 	sts	0x388D, r24
			_wYN1G_CAL = _DEFAULT_YN1G_CAL;
    1f44:	87 ef       	ldi	r24, 0xF7	; 247
    1f46:	91 e0       	ldi	r25, 0x01	; 1
    1f48:	90 93 7a 38 	sts	0x387A, r25
    1f4c:	80 93 79 38 	sts	0x3879, r24
			_wZ1G_CAL  = _DEFAULT_Z1G_CAL;
    1f50:	88 ef       	ldi	r24, 0xF8	; 248
    1f52:	91 e0       	ldi	r25, 0x01	; 1
    1f54:	90 93 80 38 	sts	0x3880, r25
    1f58:	80 93 7f 38 	sts	0x387F, r24
			_wZN1G_CAL = _DEFAULT_ZN1G_CAL;
    1f5c:	89 ef       	ldi	r24, 0xF9	; 249
    1f5e:	91 e0       	ldi	r25, 0x01	; 1
    1f60:	90 93 7e 38 	sts	0x387E, r25
    1f64:	80 93 7d 38 	sts	0x387D, r24

			_wPDT = _DEFAULT_PDT;
    1f68:	8f e7       	ldi	r24, 0x7F	; 127
    1f6a:	80 93 85 38 	sts	0x3885, r24
			eeprom_write_byte(&_NV_PDT, _wPDT);
    1f6e:	81 e2       	ldi	r24, 0x21	; 33
    1f70:	90 e0       	ldi	r25, 0x00	; 0
    1f72:	6f e7       	ldi	r22, 0x7F	; 127
    1f74:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
		}

		// Set the initialized flag in the status byte
		_INITIALIZED = _WOCKET_INITIALIZED;
    1f78:	85 e2       	ldi	r24, 0x25	; 37
    1f7a:	80 93 4a 01 	sts	0x014A, r24

		// Write the status byte to the EEPROM		
		eeprom_write_byte(&_NV_INITIALIZED,_INITIALIZED);
    1f7e:	80 e0       	ldi	r24, 0x00	; 0
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	65 e2       	ldi	r22, 0x25	; 37
    1f84:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
    1f88:	c3 e0       	ldi	r28, 0x03	; 3
    1f8a:	d0 e0       	ldi	r29, 0x00	; 0
				
		// Blink green for 5 seconds	
		for (int i = 0; (i < 3); i++){
			_greenled_turn_on();		
    1f8c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_greenled_turn_on>
    1f90:	88 ec       	ldi	r24, 0xC8	; 200
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	ef e0       	ldi	r30, 0x0F	; 15
    1f96:	f7 e2       	ldi	r31, 0x27	; 39
    1f98:	31 97       	sbiw	r30, 0x01	; 1
    1f9a:	f1 f7       	brne	.-4      	; 0x1f98 <_wocket_initialize+0x3f2>
    1f9c:	00 c0       	rjmp	.+0      	; 0x1f9e <_wocket_initialize+0x3f8>
    1f9e:	00 00       	nop
    1fa0:	01 97       	sbiw	r24, 0x01	; 1
			for(int j = 0;(j < 200); j++)
    1fa2:	c1 f7       	brne	.-16     	; 0x1f94 <_wocket_initialize+0x3ee>
				_delay_ms(5);
			_greenled_turn_off();
    1fa4:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>
    1fa8:	88 ec       	ldi	r24, 0xC8	; 200
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	af e0       	ldi	r26, 0x0F	; 15
    1fae:	b7 e2       	ldi	r27, 0x27	; 39
    1fb0:	11 97       	sbiw	r26, 0x01	; 1
    1fb2:	f1 f7       	brne	.-4      	; 0x1fb0 <_wocket_initialize+0x40a>
    1fb4:	00 c0       	rjmp	.+0      	; 0x1fb6 <_wocket_initialize+0x410>
    1fb6:	00 00       	nop
    1fb8:	01 97       	sbiw	r24, 0x01	; 1
			for(int j = 0; (j < 200); j++)
    1fba:	c1 f7       	brne	.-16     	; 0x1fac <_wocket_initialize+0x406>
    1fbc:	21 97       	sbiw	r28, 0x01	; 1

		// Write the status byte to the EEPROM		
		eeprom_write_byte(&_NV_INITIALIZED,_INITIALIZED);
				
		// Blink green for 5 seconds	
		for (int i = 0; (i < 3); i++){
    1fbe:	31 f7       	brne	.-52     	; 0x1f8c <_wocket_initialize+0x3e6>
			for(int j = 0; (j < 200); j++)
				_delay_ms(5);
		}		
	}

	_DEFAULT_SHUTDOWN = (unsigned long)_wPDT * (unsigned long)_SAMPLING_RATE * (unsigned long)60;
    1fc0:	60 91 85 38 	lds	r22, 0x3885
    1fc4:	70 e0       	ldi	r23, 0x00	; 0
    1fc6:	80 e0       	ldi	r24, 0x00	; 0
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	20 91 06 01 	lds	r18, 0x0106
    1fce:	30 e0       	ldi	r19, 0x00	; 0
    1fd0:	40 e0       	ldi	r20, 0x00	; 0
    1fd2:	50 e0       	ldi	r21, 0x00	; 0
    1fd4:	0e 94 06 18 	call	0x300c	; 0x300c <__mulsi3>
    1fd8:	2c e3       	ldi	r18, 0x3C	; 60
    1fda:	30 e0       	ldi	r19, 0x00	; 0
    1fdc:	40 e0       	ldi	r20, 0x00	; 0
    1fde:	50 e0       	ldi	r21, 0x00	; 0
    1fe0:	0e 94 06 18 	call	0x300c	; 0x300c <__mulsi3>
    1fe4:	60 93 5b 01 	sts	0x015B, r22
    1fe8:	70 93 5c 01 	sts	0x015C, r23
    1fec:	80 93 5d 01 	sts	0x015D, r24
    1ff0:	90 93 5e 01 	sts	0x015E, r25
	_wShutdownTimer = _DEFAULT_SHUTDOWN;
    1ff4:	60 93 57 01 	sts	0x0157, r22
    1ff8:	70 93 58 01 	sts	0x0158, r23
    1ffc:	80 93 59 01 	sts	0x0159, r24
    2000:	90 93 5a 01 	sts	0x015A, r25
	
    // Enable Timer 2 
    _atmega_enable_timer2(CPU_CLK_PRESCALAR_1024); 
    2004:	86 e0       	ldi	r24, 0x06	; 6
    2006:	0e 94 aa 0a 	call	0x1554	; 0x1554 <_atmega_enable_timer2>
}
    200a:	df 91       	pop	r29
    200c:	cf 91       	pop	r28
    200e:	1f 91       	pop	r17
    2010:	0f 91       	pop	r16
    2012:	08 95       	ret

00002014 <_wocket_set_flag>:

//-------------------------------------------
void _wocket_set_flag(unsigned char flag)
{
	sbi(_STATUS_BYTE, flag);
    2014:	21 e0       	ldi	r18, 0x01	; 1
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	02 c0       	rjmp	.+4      	; 0x201e <_wocket_set_flag+0xa>
    201a:	22 0f       	add	r18, r18
    201c:	33 1f       	adc	r19, r19
    201e:	8a 95       	dec	r24
    2020:	e2 f7       	brpl	.-8      	; 0x201a <_wocket_set_flag+0x6>
    2022:	80 91 4b 01 	lds	r24, 0x014B
    2026:	82 2b       	or	r24, r18
    2028:	80 93 4b 01 	sts	0x014B, r24
}
    202c:	08 95       	ret

0000202e <_wocket_reset_flag>:

//-------------------------------------------
void _wocket_reset_flag(unsigned char flag)
{
	cbi(_STATUS_BYTE, flag);
    202e:	21 e0       	ldi	r18, 0x01	; 1
    2030:	30 e0       	ldi	r19, 0x00	; 0
    2032:	02 c0       	rjmp	.+4      	; 0x2038 <_wocket_reset_flag+0xa>
    2034:	22 0f       	add	r18, r18
    2036:	33 1f       	adc	r19, r19
    2038:	8a 95       	dec	r24
    203a:	e2 f7       	brpl	.-8      	; 0x2034 <_wocket_reset_flag+0x6>
    203c:	20 95       	com	r18
    203e:	80 91 4b 01 	lds	r24, 0x014B
    2042:	82 23       	and	r24, r18
    2044:	80 93 4b 01 	sts	0x014B, r24
}
    2048:	08 95       	ret

0000204a <_wocket_is_flag_set>:

//-------------------------------------------
unsigned char _wocket_is_flag_set(unsigned char flag)
{	
	return ((_STATUS_BYTE >> flag) & 0x01);
    204a:	20 91 4b 01 	lds	r18, 0x014B
    204e:	30 e0       	ldi	r19, 0x00	; 0
    2050:	02 c0       	rjmp	.+4      	; 0x2056 <_wocket_is_flag_set+0xc>
    2052:	35 95       	asr	r19
    2054:	27 95       	ror	r18
    2056:	8a 95       	dec	r24
    2058:	e2 f7       	brpl	.-8      	; 0x2052 <_wocket_is_flag_set+0x8>
}
    205a:	82 2f       	mov	r24, r18
    205c:	81 70       	andi	r24, 0x01	; 1
    205e:	08 95       	ret

00002060 <_send_uncompressed_pdu>:

//-------------------------------------------
// sends uncompressed data via bluetooth (in both Continuous and Burst modes)
void _send_uncompressed_pdu(unsigned short x, unsigned short y, unsigned short z)
{
    2060:	cf 92       	push	r12
    2062:	df 92       	push	r13
    2064:	ef 92       	push	r14
    2066:	ff 92       	push	r15
    2068:	0f 93       	push	r16
    206a:	1f 93       	push	r17
    206c:	cf 93       	push	r28
    206e:	df 93       	push	r29
    2070:	ec 01       	movw	r28, r24
    2072:	8b 01       	movw	r16, r22
    2074:	7a 01       	movw	r14, r20
	aBuffer[0] = 0x80 | ((x >> 8) & 0x03);
    2076:	6c 01       	movw	r12, r24
    2078:	8d 2d       	mov	r24, r13
    207a:	83 70       	andi	r24, 0x03	; 3
    207c:	80 68       	ori	r24, 0x80	; 128
    207e:	80 93 99 38 	sts	0x3899, r24
	_bluetooth_transmit_uart0_byte(aBuffer[0]);
    2082:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
	aBuffer[1] = ((unsigned char) ((x >> 1) & 0x7f));
    2086:	ce 01       	movw	r24, r28
    2088:	96 95       	lsr	r25
    208a:	87 95       	ror	r24
    208c:	8f 77       	andi	r24, 0x7F	; 127
    208e:	80 93 9a 38 	sts	0x389A, r24
	_bluetooth_transmit_uart0_byte(aBuffer[1]);
    2092:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
	aBuffer[2] = ((unsigned char) ((x << 6) & 0x40)) | ((unsigned char) ((y >> 4) & 0x3f));
    2096:	c8 01       	movw	r24, r16
    2098:	34 e0       	ldi	r19, 0x04	; 4
    209a:	96 95       	lsr	r25
    209c:	87 95       	ror	r24
    209e:	3a 95       	dec	r19
    20a0:	e1 f7       	brne	.-8      	; 0x209a <_send_uncompressed_pdu+0x3a>
    20a2:	8f 73       	andi	r24, 0x3F	; 63
    20a4:	9e 01       	movw	r18, r28
    20a6:	22 95       	swap	r18
    20a8:	22 0f       	add	r18, r18
    20aa:	22 0f       	add	r18, r18
    20ac:	20 7c       	andi	r18, 0xC0	; 192
    20ae:	92 2f       	mov	r25, r18
    20b0:	90 74       	andi	r25, 0x40	; 64
    20b2:	89 2b       	or	r24, r25
    20b4:	80 93 9b 38 	sts	0x389B, r24
	_bluetooth_transmit_uart0_byte(aBuffer[2]);
    20b8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
	aBuffer[3] = ((unsigned char) ((y << 3) & 0x78)) | ((unsigned char) ((z >> 7) & 0x07));
    20bc:	c7 01       	movw	r24, r14
    20be:	88 0f       	add	r24, r24
    20c0:	89 2f       	mov	r24, r25
    20c2:	88 1f       	adc	r24, r24
    20c4:	99 0b       	sbc	r25, r25
    20c6:	91 95       	neg	r25
    20c8:	87 70       	andi	r24, 0x07	; 7
    20ca:	00 0f       	add	r16, r16
    20cc:	00 0f       	add	r16, r16
    20ce:	00 0f       	add	r16, r16
    20d0:	08 77       	andi	r16, 0x78	; 120
    20d2:	80 2b       	or	r24, r16
    20d4:	80 93 9c 38 	sts	0x389C, r24
	_bluetooth_transmit_uart0_byte(aBuffer[3]);
    20d8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
	aBuffer[4] = ((unsigned char) (z & 0x7f));
    20dc:	8e 2d       	mov	r24, r14
    20de:	8f 77       	andi	r24, 0x7F	; 127
    20e0:	80 93 9d 38 	sts	0x389D, r24
	_bluetooth_transmit_uart0_byte(aBuffer[4]);
    20e4:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    20e8:	df 91       	pop	r29
    20ea:	cf 91       	pop	r28
    20ec:	1f 91       	pop	r17
    20ee:	0f 91       	pop	r16
    20f0:	ff 90       	pop	r15
    20f2:	ef 90       	pop	r14
    20f4:	df 90       	pop	r13
    20f6:	cf 90       	pop	r12
    20f8:	08 95       	ret

000020fa <_send_compressed_pdu>:

//-------------------------------------------
// 	sends compressed data via bluetooth(in both Continuous and Burst modes)
void _send_compressed_pdu(unsigned char x, unsigned char y, unsigned char z)
{
    20fa:	1f 93       	push	r17
    20fc:	df 93       	push	r29
    20fe:	cf 93       	push	r28
    2100:	00 d0       	rcall	.+0      	; 0x2102 <_send_compressed_pdu+0x8>
    2102:	cd b7       	in	r28, 0x3d	; 61
    2104:	de b7       	in	r29, 0x3e	; 62
    2106:	18 2f       	mov	r17, r24
	aBuffer[0] = 0xe0| ((x >> 1) & 0x1f);
    2108:	86 95       	lsr	r24
    210a:	80 6e       	ori	r24, 0xE0	; 224
    210c:	80 93 99 38 	sts	0x3899, r24
	_bluetooth_transmit_uart0_byte(aBuffer[0]);
    2110:	4a 83       	std	Y+2, r20	; 0x02
    2112:	69 83       	std	Y+1, r22	; 0x01
    2114:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
	aBuffer[1] = ((x & 0x01) << 6) | (y & 0x3f);
    2118:	21 2f       	mov	r18, r17
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	21 70       	andi	r18, 0x01	; 1
    211e:	30 70       	andi	r19, 0x00	; 0
    2120:	56 e0       	ldi	r21, 0x06	; 6
    2122:	22 0f       	add	r18, r18
    2124:	33 1f       	adc	r19, r19
    2126:	5a 95       	dec	r21
    2128:	e1 f7       	brne	.-8      	; 0x2122 <_send_compressed_pdu+0x28>
    212a:	69 81       	ldd	r22, Y+1	; 0x01
    212c:	86 2f       	mov	r24, r22
    212e:	8f 73       	andi	r24, 0x3F	; 63
    2130:	82 2b       	or	r24, r18
    2132:	80 93 9a 38 	sts	0x389A, r24
	_bluetooth_transmit_uart0_byte(aBuffer[1]);
    2136:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
	aBuffer[2] = (z << 1) & 0x7e;
    213a:	4a 81       	ldd	r20, Y+2	; 0x02
    213c:	84 2f       	mov	r24, r20
    213e:	88 0f       	add	r24, r24
    2140:	8e 77       	andi	r24, 0x7E	; 126
    2142:	80 93 9b 38 	sts	0x389B, r24
	_bluetooth_transmit_uart0_byte(aBuffer[2]);	
    2146:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    214a:	0f 90       	pop	r0
    214c:	0f 90       	pop	r0
    214e:	cf 91       	pop	r28
    2150:	df 91       	pop	r29
    2152:	1f 91       	pop	r17
    2154:	08 95       	ret

00002156 <_send_batch_count>:

//-------------------------------------------
//	sends the number of stored raw data 
void _send_batch_count(unsigned short count)
{
    2156:	cf 93       	push	r28
    2158:	df 93       	push	r29
    aBuffer[0] = m_BC_RSP_BYTE0;
    215a:	2c ec       	ldi	r18, 0xCC	; 204
    215c:	20 93 99 38 	sts	0x3899, r18
    aBuffer[1] = m_BC_RSP_BYTE1(count);
    2160:	29 2f       	mov	r18, r25
    2162:	26 95       	lsr	r18
    2164:	20 93 9a 38 	sts	0x389A, r18
    aBuffer[2] = m_BC_RSP_BYTE2(count);
    2168:	9c 01       	movw	r18, r24
    216a:	36 95       	lsr	r19
    216c:	27 95       	ror	r18
    216e:	36 95       	lsr	r19
    2170:	27 95       	ror	r18
    2172:	2f 77       	andi	r18, 0x7F	; 127
    2174:	20 93 9b 38 	sts	0x389B, r18
	aBuffer[3] = m_BC_RSP_BYTE3(count);
    2178:	83 70       	andi	r24, 0x03	; 3
    217a:	82 95       	swap	r24
    217c:	88 0f       	add	r24, r24
    217e:	80 7e       	andi	r24, 0xE0	; 224
    2180:	80 93 9c 38 	sts	0x389C, r24
    2184:	c9 e9       	ldi	r28, 0x99	; 153
    2186:	d8 e3       	ldi	r29, 0x38	; 56
	for (int i = 0; (i < 4); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]);  
    2188:	89 91       	ld	r24, Y+
    218a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
{
    aBuffer[0] = m_BC_RSP_BYTE0;
    aBuffer[1] = m_BC_RSP_BYTE1(count);
    aBuffer[2] = m_BC_RSP_BYTE2(count);
	aBuffer[3] = m_BC_RSP_BYTE3(count);
	for (int i = 0; (i < 4); i++)                                                                                       
    218e:	88 e3       	ldi	r24, 0x38	; 56
    2190:	cd 39       	cpi	r28, 0x9D	; 157
    2192:	d8 07       	cpc	r29, r24
    2194:	c9 f7       	brne	.-14     	; 0x2188 <_send_batch_count+0x32>
       	_bluetooth_transmit_uart0_byte(aBuffer[i]);  
}
    2196:	df 91       	pop	r29
    2198:	cf 91       	pop	r28
    219a:	08 95       	ret

0000219c <_send_ac_count>:

//-------------------------------------------
// 	sends the number of activity counts 
void _send_ac_count(unsigned short count)
{ 
    aBuffer[0] = m_ACC_RSP_BYTE0;
    219c:	2f ec       	ldi	r18, 0xCF	; 207
    219e:	20 93 99 38 	sts	0x3899, r18
    aBuffer[1] = m_ACC_RSP_BYTE1(count);
    21a2:	9c 01       	movw	r18, r24
    21a4:	22 0f       	add	r18, r18
    21a6:	23 2f       	mov	r18, r19
    21a8:	22 1f       	adc	r18, r18
    21aa:	33 0b       	sbc	r19, r19
    21ac:	31 95       	neg	r19
    21ae:	2f 77       	andi	r18, 0x7F	; 127
    21b0:	20 93 9a 38 	sts	0x389A, r18
    aBuffer[2] = m_ACC_RSP_BYTE2(count);
    21b4:	8f 77       	andi	r24, 0x7F	; 127
    21b6:	80 93 9b 38 	sts	0x389B, r24
	for (int i = 0; (i < 3); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]);  
    21ba:	8f ec       	ldi	r24, 0xCF	; 207
    21bc:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    21c0:	80 91 9a 38 	lds	r24, 0x389A
    21c4:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    21c8:	80 91 9b 38 	lds	r24, 0x389B
    21cc:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    21d0:	08 95       	ret

000021d2 <_send_ac_offset>:

//-------------------------------------------
//	Activity count offset 
void _send_ac_offset(unsigned short offset)
{
    aBuffer[0] = m_OFT_RSP_BYTE0;
    21d2:	20 ed       	ldi	r18, 0xD0	; 208
    21d4:	20 93 99 38 	sts	0x3899, r18
    aBuffer[1] = m_OFT_RSP_BYTE1(offset);
    21d8:	9c 01       	movw	r18, r24
    21da:	22 0f       	add	r18, r18
    21dc:	23 2f       	mov	r18, r19
    21de:	22 1f       	adc	r18, r18
    21e0:	33 0b       	sbc	r19, r19
    21e2:	31 95       	neg	r19
    21e4:	2f 77       	andi	r18, 0x7F	; 127
    21e6:	20 93 9a 38 	sts	0x389A, r18
    aBuffer[2] = m_OFT_RSP_BYTE2(offset);
    21ea:	8f 77       	andi	r24, 0x7F	; 127
    21ec:	80 93 9b 38 	sts	0x389B, r24
	for (int i = 0; (i < 3); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]); 
    21f0:	80 ed       	ldi	r24, 0xD0	; 208
    21f2:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    21f6:	80 91 9a 38 	lds	r24, 0x389A
    21fa:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    21fe:	80 91 9b 38 	lds	r24, 0x389B
    2202:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    2206:	08 95       	ret

00002208 <_send_fv>:

//-------------------------------------------
//	sends the firmware version 
void _send_fv()
{
    aBuffer[0] = m_FV_RSP_BYTE0;
    2208:	8b ec       	ldi	r24, 0xCB	; 203
    220a:	80 93 99 38 	sts	0x3899, r24
    aBuffer[1] = m_FV_RSP_BYTE1(_FVERSION);    
    220e:	86 e0       	ldi	r24, 0x06	; 6
    2210:	80 93 9a 38 	sts	0x389A, r24
	for (int i = 0; (i < 2); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]); 
    2214:	8b ec       	ldi	r24, 0xCB	; 203
    2216:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    221a:	80 91 9a 38 	lds	r24, 0x389A
    221e:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    2222:	08 95       	ret

00002224 <_send_hv>:

//-------------------------------------------
// 	sends the hardware version
void _send_hv()
{
    aBuffer[0] = m_HV_RSP_BYTE0;
    2224:	8a ec       	ldi	r24, 0xCA	; 202
    2226:	80 93 99 38 	sts	0x3899, r24
    aBuffer[1] = m_HV_RSP_BYTE1(_VERSION);    
    222a:	83 e0       	ldi	r24, 0x03	; 3
    222c:	80 93 9a 38 	sts	0x389A, r24
	for (int i = 0; (i < 2); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]); 
    2230:	8a ec       	ldi	r24, 0xCA	; 202
    2232:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    2236:	80 91 9a 38 	lds	r24, 0x389A
    223a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    223e:	08 95       	ret

00002240 <_send_bl>:

//-------------------------------------------
// 	sends the battery level
void _send_bl(unsigned short level)
{
   aBuffer[0] = m_BL_RSP_BYTE0;
    2240:	20 ec       	ldi	r18, 0xC0	; 192
    2242:	20 93 99 38 	sts	0x3899, r18
   aBuffer[1] = m_BL_RSP_BYTE1(level);
    2246:	9c 01       	movw	r18, r24
    2248:	f3 e0       	ldi	r31, 0x03	; 3
    224a:	36 95       	lsr	r19
    224c:	27 95       	ror	r18
    224e:	fa 95       	dec	r31
    2250:	e1 f7       	brne	.-8      	; 0x224a <_send_bl+0xa>
    2252:	20 93 9a 38 	sts	0x389A, r18
   aBuffer[2] = m_BL_RSP_BYTE2(level);
    2256:	87 70       	andi	r24, 0x07	; 7
    2258:	82 95       	swap	r24
    225a:	80 7f       	andi	r24, 0xF0	; 240
    225c:	80 93 9b 38 	sts	0x389B, r24
   for (int i = 0; (i < 3); i++)
       _bluetooth_transmit_uart0_byte(aBuffer[i]);
    2260:	80 ec       	ldi	r24, 0xC0	; 192
    2262:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    2266:	80 91 9a 38 	lds	r24, 0x389A
    226a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    226e:	80 91 9b 38 	lds	r24, 0x389B
    2272:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    2276:	08 95       	ret

00002278 <_send_end_batch>:

//-------------------------------------------
// sends confirmation of end of batch data for bursty mode
void _send_end_batch()
{
	aBuffer[0] = m_END_BATCH_BYTE0;    	
    2278:	82 ed       	ldi	r24, 0xD2	; 210
    227a:	80 93 99 38 	sts	0x3899, r24
    _bluetooth_transmit_uart0_byte(aBuffer[0]); 
    227e:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    2282:	08 95       	ret

00002284 <_send_sr>:

//-------------------------------------------
// sends sampling rate
void _send_sr()
{
	aBuffer[0] = m_SR_RSP_BYTE0;
    2284:	85 ec       	ldi	r24, 0xC5	; 197
    2286:	80 93 99 38 	sts	0x3899, r24
    aBuffer[1] = m_SR_RSP_BYTE1(_SAMPLING_RATE);
    228a:	80 91 06 01 	lds	r24, 0x0106
    228e:	8f 77       	andi	r24, 0x7F	; 127
    2290:	80 93 9a 38 	sts	0x389A, r24
	for (int i = 0; (i < 2); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]); 
    2294:	85 ec       	ldi	r24, 0xC5	; 197
    2296:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    229a:	80 91 9a 38 	lds	r24, 0x389A
    229e:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    22a2:	08 95       	ret

000022a4 <_send_wtm>:

//-------------------------------------------
//	sends wocket transmission mode 
void _send_wtm()
{ 
	aBuffer[0] = m_WTM_RSP_BYTE0;
    22a4:	88 ec       	ldi	r24, 0xC8	; 200
    22a6:	80 93 99 38 	sts	0x3899, r24
    aBuffer[1] = m_WTM_RSP_BYTE1(_wTM);
    22aa:	80 91 4e 01 	lds	r24, 0x014E
    22ae:	87 70       	andi	r24, 0x07	; 7
    22b0:	82 95       	swap	r24
    22b2:	80 7f       	andi	r24, 0xF0	; 240
    22b4:	80 93 9a 38 	sts	0x389A, r24
	for (int i = 0; (i < 2); i++)                                                                                       
       	_bluetooth_transmit_uart0_byte(aBuffer[i]); 
    22b8:	88 ec       	ldi	r24, 0xC8	; 200
    22ba:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    22be:	80 91 9a 38 	lds	r24, 0x389A
    22c2:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
}
    22c6:	08 95       	ret

000022c8 <_receive_data>:

//-------------------------------------------
// 	Receive commands from the phone	
void _receive_data(void)
{
    22c8:	ef 92       	push	r14
    22ca:	ff 92       	push	r15
    22cc:	0f 93       	push	r16
    22ce:	1f 93       	push	r17
    22d0:	df 93       	push	r29
    22d2:	cf 93       	push	r28
    22d4:	0f 92       	push	r0
    22d6:	cd b7       	in	r28, 0x3d	; 61
    22d8:	de b7       	in	r29, 0x3e	; 62

	// Attempt to receive a byte only if no command is being received or a partial command has been received
	// This line was replaced with results from Harshit experiments
	// if ( ((command_counter==0)||(command_counter<command_length))  && (_bluetooth_receive_uart0_byte(&aByte)) )
    
	if(_bluetooth_receive_uart0_byte(&aByte))
    22da:	ce 01       	movw	r24, r28
    22dc:	01 96       	adiw	r24, 0x01	; 1
    22de:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_bluetooth_receive_uart0_byte>
    22e2:	88 23       	and	r24, r24
    22e4:	e1 f1       	breq	.+120    	; 0x235e <_receive_data+0x96>
	{
		rBuffer[command_counter++] = aByte;
    22e6:	80 91 37 01 	lds	r24, 0x0137
    22ea:	e9 81       	ldd	r30, Y+1	; 0x01
    22ec:	a8 2f       	mov	r26, r24
    22ee:	b0 e0       	ldi	r27, 0x00	; 0
    22f0:	a1 57       	subi	r26, 0x71	; 113
    22f2:	b7 4c       	sbci	r27, 0xC7	; 199
    22f4:	ec 93       	st	X, r30
    22f6:	8f 5f       	subi	r24, 0xFF	; 255
    22f8:	80 93 37 01 	sts	0x0137, r24
				
		if ((aByte >> 5) == COMMAND_PREFIX)
    22fc:	8e 2f       	mov	r24, r30
    22fe:	82 95       	swap	r24
    2300:	86 95       	lsr	r24
    2302:	87 70       	andi	r24, 0x07	; 7
    2304:	85 30       	cpi	r24, 0x05	; 5
    2306:	59 f5       	brne	.+86     	; 0x235e <_receive_data+0x96>
    	{
        	opcode = aByte & 0x1f;                                              
    2308:	ef 71       	andi	r30, 0x1F	; 31
    230a:	e0 93 86 38 	sts	0x3886, r30
        	switch (opcode)
    230e:	f0 e0       	ldi	r31, 0x00	; 0
    2310:	ef 31       	cpi	r30, 0x1F	; 31
    2312:	f1 05       	cpc	r31, r1
    2314:	98 f4       	brcc	.+38     	; 0x233c <_receive_data+0x74>
    2316:	ea 5b       	subi	r30, 0xBA	; 186
    2318:	ff 4f       	sbci	r31, 0xFF	; 255
    231a:	ee 0f       	add	r30, r30
    231c:	ff 1f       	adc	r31, r31
    231e:	05 90       	lpm	r0, Z+
    2320:	f4 91       	lpm	r31, Z+
    2322:	e0 2d       	mov	r30, r0
    2324:	09 94       	ijmp
				case (unsigned char)GetBatteryCalibration:
				case (unsigned char)GetHardwareVersion:
				case (unsigned char)GetFirmwareVersion:				
				case (unsigned char)GetTCT:
				case (unsigned char)ShutdownWocket:
                	command_length = 1;
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	07 c0       	rjmp	.+14     	; 0x2338 <_receive_data+0x70>
                case (unsigned char)SetAliveTimer:
                case (unsigned char)SetPowerDownTimer:
                case (unsigned char)SetRadioTransmissionMode:                
				case (unsigned char)SetWocketTransmissionMode:  
				case (unsigned char)SetLED:
                     command_length = 2;
    232a:	82 e0       	ldi	r24, 0x02	; 2
    232c:	05 c0       	rjmp	.+10     	; 0x2338 <_receive_data+0x70>
                     break;
     			case (unsigned char)ACK:
					 command_length = 4;
    232e:	84 e0       	ldi	r24, 0x04	; 4
    2330:	03 c0       	rjmp	.+6      	; 0x2338 <_receive_data+0x70>
                     break;
				case (unsigned char)SetTCT:                
                     command_length = 5;
    2332:	85 e0       	ldi	r24, 0x05	; 5
    2334:	01 c0       	rjmp	.+2      	; 0x2338 <_receive_data+0x70>
                     break;
                case (unsigned char)SetCalibrationValues:
				case (unsigned char)SetBatteryCalibration:
                      command_length = 10;                                                              
    2336:	8a e0       	ldi	r24, 0x0A	; 10
    2338:	80 93 38 01 	sts	0x0138, r24
                      break;                                                          
    		}
    		command_counter = 1;
    233c:	81 e0       	ldi	r24, 0x01	; 1
    233e:	80 93 37 01 	sts	0x0137, r24
    		command_timer = 0;
    2342:	10 92 3a 01 	sts	0x013A, r1
    2346:	10 92 39 01 	sts	0x0139, r1
    		processed_counter = 0;                                            
    234a:	10 92 3b 01 	sts	0x013B, r1
    		address = 0xffff;
    234e:	8f ef       	ldi	r24, 0xFF	; 255
    2350:	9f ef       	ldi	r25, 0xFF	; 255
    2352:	90 93 05 01 	sts	0x0105, r25
    2356:	80 93 04 01 	sts	0x0104, r24
    		response_length = 0;
    235a:	10 92 3c 01 	sts	0x013C, r1
		}
	}

	// increment timer as long as the command is still being received
    if (command_counter > 0)
    235e:	60 91 37 01 	lds	r22, 0x0137
    2362:	66 23       	and	r22, r22
    2364:	09 f4       	brne	.+2      	; 0x2368 <_receive_data+0xa0>
    2366:	b5 c5       	rjmp	.+2922   	; 0x2ed2 <_receive_data+0xc0a>
		command_timer++;
    2368:	80 91 39 01 	lds	r24, 0x0139
    236c:	90 91 3a 01 	lds	r25, 0x013A
    2370:	01 96       	adiw	r24, 0x01	; 1
    2372:	90 93 3a 01 	sts	0x013A, r25
    2376:	80 93 39 01 	sts	0x0139, r24

 	//if all command is received, start processing it
    if ((command_counter > 0) && (command_counter == command_length))
    237a:	80 91 38 01 	lds	r24, 0x0138
    237e:	68 17       	cp	r22, r24
    2380:	09 f0       	breq	.+2      	; 0x2384 <_receive_data+0xbc>
    2382:	a7 c5       	rjmp	.+2894   	; 0x2ed2 <_receive_data+0xc0a>
    {                                       
            switch (opcode)
    2384:	e0 91 86 38 	lds	r30, 0x3886
    2388:	f0 e0       	ldi	r31, 0x00	; 0
    238a:	ef 31       	cpi	r30, 0x1F	; 31
    238c:	f1 05       	cpc	r31, r1
    238e:	08 f0       	brcs	.+2      	; 0x2392 <_receive_data+0xca>
    2390:	85 c5       	rjmp	.+2826   	; 0x2e9c <_receive_data+0xbd4>
    2392:	eb 59       	subi	r30, 0x9B	; 155
    2394:	ff 4f       	sbci	r31, 0xFF	; 255
    2396:	ee 0f       	add	r30, r30
    2398:	ff 1f       	adc	r31, r31
    239a:	05 90       	lpm	r0, Z+
    239c:	f4 91       	lpm	r31, Z+
    239e:	e0 2d       	mov	r30, r0
    23a0:	09 94       	ijmp
            {
				case (unsigned char) ACK:																
					kseq = rBuffer[1] & 0x7f;
    23a2:	80 91 90 38 	lds	r24, 0x3890
    23a6:	90 e0       	ldi	r25, 0x00	; 0
    23a8:	8f 77       	andi	r24, 0x7F	; 127
    23aa:	90 70       	andi	r25, 0x00	; 0
					kseq = kseq << 7 | (rBuffer[2] & 0x7f);
    23ac:	96 95       	lsr	r25
    23ae:	98 2f       	mov	r25, r24
    23b0:	88 27       	eor	r24, r24
    23b2:	97 95       	ror	r25
    23b4:	87 95       	ror	r24
    23b6:	20 91 91 38 	lds	r18, 0x3891
    23ba:	30 e0       	ldi	r19, 0x00	; 0
    23bc:	2f 77       	andi	r18, 0x7F	; 127
    23be:	30 70       	andi	r19, 0x00	; 0
    23c0:	82 2b       	or	r24, r18
    23c2:	93 2b       	or	r25, r19
					kseq = kseq << 2 | ((rBuffer[3] >> 5) & 0x03);
    23c4:	88 0f       	add	r24, r24
    23c6:	99 1f       	adc	r25, r25
    23c8:	88 0f       	add	r24, r24
    23ca:	99 1f       	adc	r25, r25
    23cc:	20 91 92 38 	lds	r18, 0x3892
    23d0:	22 95       	swap	r18
    23d2:	26 95       	lsr	r18
    23d4:	27 70       	andi	r18, 0x07	; 7
    23d6:	30 e0       	ldi	r19, 0x00	; 0
    23d8:	23 70       	andi	r18, 0x03	; 3
    23da:	30 70       	andi	r19, 0x00	; 0
    23dc:	82 2b       	or	r24, r18
    23de:	93 2b       	or	r25, r19
					kseq ++;
    23e0:	01 96       	adiw	r24, 0x01	; 1
    23e2:	90 93 1c 01 	sts	0x011C, r25
    23e6:	80 93 1b 01 	sts	0x011B, r24
					if ( (kseq <= cseq) && ((kseq - sseq) < AC_BUFFER_SIZE) && ((kseq - sseq) > 0) ) {					
    23ea:	20 91 17 01 	lds	r18, 0x0117
    23ee:	30 91 18 01 	lds	r19, 0x0118
    23f2:	28 17       	cp	r18, r24
    23f4:	39 07       	cpc	r19, r25
    23f6:	08 f4       	brcc	.+2      	; 0x23fa <_receive_data+0x132>
    23f8:	75 c0       	rjmp	.+234    	; 0x24e4 <_receive_data+0x21c>
    23fa:	40 91 19 01 	lds	r20, 0x0119
    23fe:	50 91 1a 01 	lds	r21, 0x011A
    2402:	fc 01       	movw	r30, r24
    2404:	e4 1b       	sub	r30, r20
    2406:	f5 0b       	sbc	r31, r21
    2408:	73 e0       	ldi	r23, 0x03	; 3
    240a:	e0 3c       	cpi	r30, 0xC0	; 192
    240c:	f7 07       	cpc	r31, r23
    240e:	08 f0       	brcs	.+2      	; 0x2412 <_receive_data+0x14a>
    2410:	69 c0       	rjmp	.+210    	; 0x24e4 <_receive_data+0x21c>
    2412:	84 17       	cp	r24, r20
    2414:	95 07       	cpc	r25, r21
    2416:	09 f4       	brne	.+2      	; 0x241a <_receive_data+0x152>
    2418:	65 c0       	rjmp	.+202    	; 0x24e4 <_receive_data+0x21c>
						sseq = kseq;						
    241a:	90 93 1a 01 	sts	0x011A, r25
    241e:	80 93 19 01 	sts	0x0119, r24
						dseq = cseq - kseq;
    2422:	28 1b       	sub	r18, r24
    2424:	39 0b       	sbc	r19, r25
    2426:	30 93 1e 01 	sts	0x011E, r19
    242a:	20 93 1d 01 	sts	0x011D, r18
						if (dseq >= 0)
							si = ci - dseq;
    242e:	80 91 1f 01 	lds	r24, 0x011F
    2432:	90 91 20 01 	lds	r25, 0x0120
    2436:	82 1b       	sub	r24, r18
    2438:	93 0b       	sbc	r25, r19
    243a:	90 93 22 01 	sts	0x0122, r25
    243e:	80 93 21 01 	sts	0x0121, r24
    2442:	50 c0       	rjmp	.+160    	; 0x24e4 <_receive_data+0x21c>
					break;	

		        //This command calibrates the wocket sampling rate by determining how much off it is from the 
				//_SAMPLING_RATE by counting timer interrupts and using that value to adjust the sampling rate.
			    case (unsigned char) SetTCT:  
			   		_wTCNT2 = m_SET_TCT (rBuffer[1], rBuffer[2]);
    2444:	20 91 91 38 	lds	r18, 0x3891
    2448:	62 2f       	mov	r22, r18
    244a:	62 95       	swap	r22
    244c:	66 95       	lsr	r22
    244e:	66 95       	lsr	r22
    2450:	61 70       	andi	r22, 0x01	; 1
    2452:	80 91 90 38 	lds	r24, 0x3890
    2456:	88 0f       	add	r24, r24
    2458:	68 2b       	or	r22, r24
    245a:	60 93 4c 01 	sts	0x014C, r22
					_wTCNT2_reps = m_SET_TCTREPS (rBuffer[2], rBuffer[3]);
    245e:	90 91 92 38 	lds	r25, 0x3892
    2462:	89 2f       	mov	r24, r25
    2464:	82 95       	swap	r24
    2466:	86 95       	lsr	r24
    2468:	83 70       	andi	r24, 0x03	; 3
    246a:	22 0f       	add	r18, r18
    246c:	22 0f       	add	r18, r18
    246e:	82 2b       	or	r24, r18
    2470:	80 93 07 01 	sts	0x0107, r24
					_wTCNT2_last = m_SET_TCTLAST (rBuffer[3], rBuffer[4]);
    2474:	80 91 93 38 	lds	r24, 0x3893
    2478:	82 95       	swap	r24
    247a:	87 70       	andi	r24, 0x07	; 7
    247c:	99 0f       	add	r25, r25
    247e:	99 0f       	add	r25, r25
    2480:	99 0f       	add	r25, r25
    2482:	89 2b       	or	r24, r25
    2484:	80 93 4d 01 	sts	0x014D, r24
					eeprom_write_byte (&_NV_TCT, _wTCNT2);
    2488:	83 e0       	ldi	r24, 0x03	; 3
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					eeprom_write_byte (&_NV_TCTREPS, _wTCNT2_reps);
    2490:	84 e0       	ldi	r24, 0x04	; 4
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	60 91 07 01 	lds	r22, 0x0107
    2498:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					eeprom_write_byte (&_NV_TCTLAST, _wTCNT2_last);
    249c:	85 e0       	ldi	r24, 0x05	; 5
    249e:	90 e0       	ldi	r25, 0x00	; 0
    24a0:	60 91 4d 01 	lds	r22, 0x014D
    24a4:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					processed_counter = command_counter;
    24a8:	80 91 37 01 	lds	r24, 0x0137
    24ac:	80 93 3b 01 	sts	0x013B, r24
					_yellowled_turn_on();	
    24b0:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <_yellowled_turn_on>
    24b4:	8f ef       	ldi	r24, 0xFF	; 255
    24b6:	94 e3       	ldi	r25, 0x34	; 52
    24b8:	ac e0       	ldi	r26, 0x0C	; 12
    24ba:	81 50       	subi	r24, 0x01	; 1
    24bc:	90 40       	sbci	r25, 0x00	; 0
    24be:	a0 40       	sbci	r26, 0x00	; 0
    24c0:	e1 f7       	brne	.-8      	; 0x24ba <_receive_data+0x1f2>
    24c2:	00 c0       	rjmp	.+0      	; 0x24c4 <_receive_data+0x1fc>
    24c4:	00 00       	nop
					_delay_ms(500);						
					_yellowled_turn_off(); 
    24c6:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>
    24ca:	8f ef       	ldi	r24, 0xFF	; 255
    24cc:	94 e3       	ldi	r25, 0x34	; 52
    24ce:	ac e0       	ldi	r26, 0x0C	; 12
    24d0:	81 50       	subi	r24, 0x01	; 1
    24d2:	90 40       	sbci	r25, 0x00	; 0
    24d4:	a0 40       	sbci	r26, 0x00	; 0
    24d6:	e1 f7       	brne	.-8      	; 0x24d0 <_receive_data+0x208>
    24d8:	00 c0       	rjmp	.+0      	; 0x24da <_receive_data+0x212>
    24da:	00 00       	nop
    24dc:	df c4       	rjmp	.+2494   	; 0x2e9c <_receive_data+0xbd4>
					_delay_ms(500);
					break;

                case (unsigned char)PausePacket:                                                      
                    paused = 1;
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	80 93 3d 01 	sts	0x013D, r24
                    processed_counter = command_counter;                                                      
    24e4:	60 93 3b 01 	sts	0x013B, r22
                    break;
    24e8:	d9 c4       	rjmp	.+2482   	; 0x2e9c <_receive_data+0xbd4>

                case (unsigned char)ResumePacket:                                                     
                    paused = 0;
    24ea:	10 92 3d 01 	sts	0x013D, r1
    24ee:	fa cf       	rjmp	.-12     	; 0x24e4 <_receive_data+0x21c>
                    processed_counter = command_counter;                                                      
                    break;

                //reset alive timer if it is alive
                case (unsigned char)Alive:                                                      
                    alive_timer = 0;
    24f0:	10 92 3f 01 	sts	0x013F, r1
    24f4:	10 92 3e 01 	sts	0x013E, r1
    24f8:	f5 cf       	rjmp	.-22     	; 0x24e4 <_receive_data+0x21c>
                    processed_counter = command_counter;		
                    break;

            	case (unsigned char) GetBatteryLevel: 
                    word = _atmega_a2dConvert10bit(ADC7);
    24fa:	87 e0       	ldi	r24, 0x07	; 7
    24fc:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
    2500:	90 93 41 01 	sts	0x0141, r25
    2504:	80 93 40 01 	sts	0x0140, r24
                    aBuffer[0] = m_BL_RSP_BYTE0;
    2508:	20 ec       	ldi	r18, 0xC0	; 192
    250a:	20 93 99 38 	sts	0x3899, r18
                    aBuffer[1] = m_BL_RSP_BYTE1(word);
    250e:	9c 01       	movw	r18, r24
    2510:	13 e0       	ldi	r17, 0x03	; 3
    2512:	36 95       	lsr	r19
    2514:	27 95       	ror	r18
    2516:	1a 95       	dec	r17
    2518:	e1 f7       	brne	.-8      	; 0x2512 <_receive_data+0x24a>
    251a:	20 93 9a 38 	sts	0x389A, r18
                    aBuffer[2] = m_BL_RSP_BYTE2(word);
    251e:	87 70       	andi	r24, 0x07	; 7
    2520:	82 95       	swap	r24
    2522:	80 7f       	andi	r24, 0xF0	; 240
    2524:	80 93 9b 38 	sts	0x389B, r24
                    processed_counter = command_counter;
    2528:	80 91 37 01 	lds	r24, 0x0137
    252c:	80 93 3b 01 	sts	0x013B, r24
                    response_length = 3;		                                                                          
    2530:	83 e0       	ldi	r24, 0x03	; 3
    2532:	a4 c4       	rjmp	.+2376   	; 0x2e7c <_receive_data+0xbb4>
                    break;	
						
            	case (unsigned char) GetSensorSentivity:           			  
                    aBuffer[0] = m_SENS_RSP_BYTE0;
    2534:	83 ec       	ldi	r24, 0xC3	; 195
    2536:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_SENS_RSP_BYTE1(_wSENS);                       
    253a:	80 91 08 01 	lds	r24, 0x0108
    253e:	41 c1       	rjmp	.+642    	; 0x27c2 <_receive_data+0x4fa>
                    processed_counter = command_counter;
                    response_length = 2;		                                                                          
                    break;
						
				case (unsigned char) SetSensorSentivity:           			  
                    _wSENS = m_SET_SEN(rBuffer[1]);
    2540:	60 91 90 38 	lds	r22, 0x3890
    2544:	66 95       	lsr	r22
    2546:	66 95       	lsr	r22
    2548:	66 95       	lsr	r22
    254a:	67 70       	andi	r22, 0x07	; 7
    254c:	60 93 08 01 	sts	0x0108, r22
					eeprom_write_byte(&_NV_SENS, _wSENS);                       
    2550:	88 e0       	ldi	r24, 0x08	; 8
    2552:	90 e0       	ldi	r25, 0x00	; 0
    2554:	9d c4       	rjmp	.+2362   	; 0x2e90 <_receive_data+0xbc8>
                    processed_counter = command_counter;                                                                 
                    break;

            	case (unsigned char) GetBatteryPercent: 				
                    word = _atmega_a2dConvert10bit(ADC7);								  
    2556:	87 e0       	ldi	r24, 0x07	; 7
    2558:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
					if (word > _wBTCAL100) // Calculate the battery percent
    255c:	60 91 7b 38 	lds	r22, 0x387B
    2560:	70 91 7c 38 	lds	r23, 0x387C
    2564:	68 17       	cp	r22, r24
    2566:	79 07       	cpc	r23, r25
    2568:	38 f4       	brcc	.+14     	; 0x2578 <_receive_data+0x2b0>
						word = 100;
    256a:	84 e6       	ldi	r24, 0x64	; 100
    256c:	90 e0       	ldi	r25, 0x00	; 0
    256e:	90 93 41 01 	sts	0x0141, r25
    2572:	80 93 40 01 	sts	0x0140, r24
    2576:	8f c0       	rjmp	.+286    	; 0x2696 <_receive_data+0x3ce>
					else if (word > _wBTCAL80)
    2578:	40 91 8a 38 	lds	r20, 0x388A
    257c:	50 91 8b 38 	lds	r21, 0x388B
    2580:	48 17       	cp	r20, r24
    2582:	59 07       	cpc	r21, r25
    2584:	98 f4       	brcc	.+38     	; 0x25ac <_receive_data+0x2e4>
						word = 80 + ((word - _wBTCAL80) * 20) / (_wBTCAL100 - _wBTCAL80);
    2586:	fc 01       	movw	r30, r24
    2588:	e4 1b       	sub	r30, r20
    258a:	f5 0b       	sbc	r31, r21
    258c:	24 e1       	ldi	r18, 0x14	; 20
    258e:	30 e0       	ldi	r19, 0x00	; 0
    2590:	e2 9f       	mul	r30, r18
    2592:	c0 01       	movw	r24, r0
    2594:	e3 9f       	mul	r30, r19
    2596:	90 0d       	add	r25, r0
    2598:	f2 9f       	mul	r31, r18
    259a:	90 0d       	add	r25, r0
    259c:	11 24       	eor	r1, r1
    259e:	64 1b       	sub	r22, r20
    25a0:	75 0b       	sbc	r23, r21
    25a2:	0e 94 25 18 	call	0x304a	; 0x304a <__udivmodhi4>
    25a6:	60 5b       	subi	r22, 0xB0	; 176
    25a8:	7f 4f       	sbci	r23, 0xFF	; 255
    25aa:	1a c0       	rjmp	.+52     	; 0x25e0 <_receive_data+0x318>
					else if (word > _wBTCAL60)
    25ac:	20 91 83 38 	lds	r18, 0x3883
    25b0:	30 91 84 38 	lds	r19, 0x3884
    25b4:	28 17       	cp	r18, r24
    25b6:	39 07       	cpc	r19, r25
    25b8:	c0 f4       	brcc	.+48     	; 0x25ea <_receive_data+0x322>
						word = 60 + ((word - _wBTCAL60) * 20) / (_wBTCAL80  - _wBTCAL60);
    25ba:	fc 01       	movw	r30, r24
    25bc:	e2 1b       	sub	r30, r18
    25be:	f3 0b       	sbc	r31, r19
    25c0:	64 e1       	ldi	r22, 0x14	; 20
    25c2:	70 e0       	ldi	r23, 0x00	; 0
    25c4:	e6 9f       	mul	r30, r22
    25c6:	c0 01       	movw	r24, r0
    25c8:	e7 9f       	mul	r30, r23
    25ca:	90 0d       	add	r25, r0
    25cc:	f6 9f       	mul	r31, r22
    25ce:	90 0d       	add	r25, r0
    25d0:	11 24       	eor	r1, r1
    25d2:	ba 01       	movw	r22, r20
    25d4:	62 1b       	sub	r22, r18
    25d6:	73 0b       	sbc	r23, r19
    25d8:	0e 94 25 18 	call	0x304a	; 0x304a <__udivmodhi4>
    25dc:	64 5c       	subi	r22, 0xC4	; 196
    25de:	7f 4f       	sbci	r23, 0xFF	; 255
    25e0:	70 93 41 01 	sts	0x0141, r23
    25e4:	60 93 40 01 	sts	0x0140, r22
    25e8:	56 c0       	rjmp	.+172    	; 0x2696 <_receive_data+0x3ce>
					else if (word > _wBTCAL40)
    25ea:	40 91 81 38 	lds	r20, 0x3881
    25ee:	50 91 82 38 	lds	r21, 0x3882
    25f2:	48 17       	cp	r20, r24
    25f4:	59 07       	cpc	r21, r25
    25f6:	a0 f4       	brcc	.+40     	; 0x2620 <_receive_data+0x358>
						word = 40 + ((word - _wBTCAL40) * 20) / (_wBTCAL60  - _wBTCAL40);
    25f8:	fc 01       	movw	r30, r24
    25fa:	e4 1b       	sub	r30, r20
    25fc:	f5 0b       	sbc	r31, r21
    25fe:	64 e1       	ldi	r22, 0x14	; 20
    2600:	70 e0       	ldi	r23, 0x00	; 0
    2602:	e6 9f       	mul	r30, r22
    2604:	c0 01       	movw	r24, r0
    2606:	e7 9f       	mul	r30, r23
    2608:	90 0d       	add	r25, r0
    260a:	f6 9f       	mul	r31, r22
    260c:	90 0d       	add	r25, r0
    260e:	11 24       	eor	r1, r1
    2610:	b9 01       	movw	r22, r18
    2612:	64 1b       	sub	r22, r20
    2614:	75 0b       	sbc	r23, r21
    2616:	0e 94 25 18 	call	0x304a	; 0x304a <__udivmodhi4>
    261a:	68 5d       	subi	r22, 0xD8	; 216
    261c:	7f 4f       	sbci	r23, 0xFF	; 255
    261e:	e0 cf       	rjmp	.-64     	; 0x25e0 <_receive_data+0x318>
					else if (word > _wBTCAL20)
    2620:	20 91 77 38 	lds	r18, 0x3877
    2624:	30 91 78 38 	lds	r19, 0x3878
    2628:	28 17       	cp	r18, r24
    262a:	39 07       	cpc	r19, r25
    262c:	a0 f4       	brcc	.+40     	; 0x2656 <_receive_data+0x38e>
						word = 20 + ((word - _wBTCAL20) * 20) / (_wBTCAL40  - _wBTCAL20);
    262e:	fc 01       	movw	r30, r24
    2630:	e2 1b       	sub	r30, r18
    2632:	f3 0b       	sbc	r31, r19
    2634:	64 e1       	ldi	r22, 0x14	; 20
    2636:	70 e0       	ldi	r23, 0x00	; 0
    2638:	e6 9f       	mul	r30, r22
    263a:	c0 01       	movw	r24, r0
    263c:	e7 9f       	mul	r30, r23
    263e:	90 0d       	add	r25, r0
    2640:	f6 9f       	mul	r31, r22
    2642:	90 0d       	add	r25, r0
    2644:	11 24       	eor	r1, r1
    2646:	ba 01       	movw	r22, r20
    2648:	62 1b       	sub	r22, r18
    264a:	73 0b       	sbc	r23, r19
    264c:	0e 94 25 18 	call	0x304a	; 0x304a <__udivmodhi4>
    2650:	6c 5e       	subi	r22, 0xEC	; 236
    2652:	7f 4f       	sbci	r23, 0xFF	; 255
    2654:	c5 cf       	rjmp	.-118    	; 0x25e0 <_receive_data+0x318>
					else if (word > _wBTCAL10)
    2656:	40 91 87 38 	lds	r20, 0x3887
    265a:	50 91 88 38 	lds	r21, 0x3888
    265e:	48 17       	cp	r20, r24
    2660:	59 07       	cpc	r21, r25
    2662:	a8 f4       	brcc	.+42     	; 0x268e <_receive_data+0x3c6>
						word = 10 + ((word - _wBTCAL10) * 10) / (_wBTCAL20  - _wBTCAL10);
    2664:	bc 01       	movw	r22, r24
    2666:	64 1b       	sub	r22, r20
    2668:	75 0b       	sbc	r23, r21
    266a:	cb 01       	movw	r24, r22
    266c:	88 0f       	add	r24, r24
    266e:	99 1f       	adc	r25, r25
    2670:	a3 e0       	ldi	r26, 0x03	; 3
    2672:	66 0f       	add	r22, r22
    2674:	77 1f       	adc	r23, r23
    2676:	aa 95       	dec	r26
    2678:	e1 f7       	brne	.-8      	; 0x2672 <_receive_data+0x3aa>
    267a:	86 0f       	add	r24, r22
    267c:	97 1f       	adc	r25, r23
    267e:	b9 01       	movw	r22, r18
    2680:	64 1b       	sub	r22, r20
    2682:	75 0b       	sbc	r23, r21
    2684:	0e 94 25 18 	call	0x304a	; 0x304a <__udivmodhi4>
    2688:	66 5f       	subi	r22, 0xF6	; 246
    268a:	7f 4f       	sbci	r23, 0xFF	; 255
    268c:	a9 cf       	rjmp	.-174    	; 0x25e0 <_receive_data+0x318>
					else
						word = 0;
    268e:	10 92 41 01 	sts	0x0141, r1
    2692:	10 92 40 01 	sts	0x0140, r1

                    aBuffer[0] = m_BP_RSP_BYTE0;
    2696:	81 ec       	ldi	r24, 0xC1	; 193
    2698:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_BP_RSP_BYTE1(word);
    269c:	80 91 40 01 	lds	r24, 0x0140
    26a0:	8f 77       	andi	r24, 0x7F	; 127
    26a2:	80 93 9a 38 	sts	0x389A, r24
                    processed_counter = command_counter;
    26a6:	80 91 37 01 	lds	r24, 0x0137
    26aa:	80 93 3b 01 	sts	0x013B, r24
    26ae:	e5 c3       	rjmp	.+1994   	; 0x2e7a <_receive_data+0xbb2>
                    response_length = 2;		                                                                          
                    break;
			   
			   case (unsigned char) GetPowerDownTimer:  
			   		aBuffer[0] = m_PDT_RSP_BYTE0;
    26b0:	87 ec       	ldi	r24, 0xC7	; 199
    26b2:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_PDT_RSP_BYTE1(_wPDT);
    26b6:	80 91 85 38 	lds	r24, 0x3885
    26ba:	da c3       	rjmp	.+1972   	; 0x2e70 <_receive_data+0xba8>
					processed_counter = command_counter;
					response_length = 2;
					break;	
							
               case (unsigned char) SetPowerDownTimer:  
			   		_wPDT = m_SET_PDT(rBuffer[1]);
    26bc:	60 91 90 38 	lds	r22, 0x3890
    26c0:	6f 77       	andi	r22, 0x7F	; 127
    26c2:	60 93 85 38 	sts	0x3885, r22
					eeprom_write_byte(&_NV_PDT, _wPDT);
    26c6:	81 e2       	ldi	r24, 0x21	; 33
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	e2 c3       	rjmp	.+1988   	; 0x2e90 <_receive_data+0xbc8>
					processed_counter = command_counter;
					break;
																									
               case (unsigned char) GetSamplingRate:  
			   		aBuffer[0] = m_SR_RSP_BYTE0;
    26cc:	85 ec       	ldi	r24, 0xC5	; 197
    26ce:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_SR_RSP_BYTE1(_SAMPLING_RATE);
    26d2:	80 91 06 01 	lds	r24, 0x0106
    26d6:	cc c3       	rjmp	.+1944   	; 0x2e70 <_receive_data+0xba8>
					processed_counter = command_counter;
					response_length = 2;
					break;

               case (unsigned char) GetPacketCount:  
			   		aBuffer[0] = m_PC_RSP_BYTE0;
    26d8:	82 ec       	ldi	r24, 0xC2	; 194
    26da:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_PC_RSP_BYTE1(_wPC);
    26de:	80 91 4f 01 	lds	r24, 0x014F
    26e2:	90 91 50 01 	lds	r25, 0x0150
    26e6:	a0 91 51 01 	lds	r26, 0x0151
    26ea:	b0 91 52 01 	lds	r27, 0x0152
    26ee:	9c 01       	movw	r18, r24
    26f0:	ad 01       	movw	r20, r26
    26f2:	f9 e1       	ldi	r31, 0x19	; 25
    26f4:	56 95       	lsr	r21
    26f6:	47 95       	ror	r20
    26f8:	37 95       	ror	r19
    26fa:	27 95       	ror	r18
    26fc:	fa 95       	dec	r31
    26fe:	d1 f7       	brne	.-12     	; 0x26f4 <_receive_data+0x42c>
    2700:	20 93 9a 38 	sts	0x389A, r18
					aBuffer[2] = m_PC_RSP_BYTE2(_wPC);
    2704:	9c 01       	movw	r18, r24
    2706:	ad 01       	movw	r20, r26
    2708:	e2 e1       	ldi	r30, 0x12	; 18
    270a:	56 95       	lsr	r21
    270c:	47 95       	ror	r20
    270e:	37 95       	ror	r19
    2710:	27 95       	ror	r18
    2712:	ea 95       	dec	r30
    2714:	d1 f7       	brne	.-12     	; 0x270a <_receive_data+0x442>
    2716:	2f 77       	andi	r18, 0x7F	; 127
    2718:	20 93 9b 38 	sts	0x389B, r18
                    aBuffer[3] = m_PC_RSP_BYTE3(_wPC);
    271c:	9c 01       	movw	r18, r24
    271e:	ad 01       	movw	r20, r26
    2720:	7b e0       	ldi	r23, 0x0B	; 11
    2722:	56 95       	lsr	r21
    2724:	47 95       	ror	r20
    2726:	37 95       	ror	r19
    2728:	27 95       	ror	r18
    272a:	7a 95       	dec	r23
    272c:	d1 f7       	brne	.-12     	; 0x2722 <_receive_data+0x45a>
    272e:	2f 77       	andi	r18, 0x7F	; 127
    2730:	20 93 9c 38 	sts	0x389C, r18
					aBuffer[4] = m_PC_RSP_BYTE4(_wPC);
    2734:	9c 01       	movw	r18, r24
    2736:	ad 01       	movw	r20, r26
    2738:	04 e0       	ldi	r16, 0x04	; 4
    273a:	56 95       	lsr	r21
    273c:	47 95       	ror	r20
    273e:	37 95       	ror	r19
    2740:	27 95       	ror	r18
    2742:	0a 95       	dec	r16
    2744:	d1 f7       	brne	.-12     	; 0x273a <_receive_data+0x472>
    2746:	2f 77       	andi	r18, 0x7F	; 127
    2748:	20 93 9d 38 	sts	0x389D, r18
                    aBuffer[5] = m_PC_RSP_BYTE5(_wPC);
    274c:	8f 70       	andi	r24, 0x0F	; 15
    274e:	88 0f       	add	r24, r24
    2750:	88 0f       	add	r24, r24
    2752:	88 0f       	add	r24, r24
    2754:	80 93 9e 38 	sts	0x389E, r24
					processed_counter = command_counter;
    2758:	60 93 3b 01 	sts	0x013B, r22
					response_length = 6;
    275c:	86 e0       	ldi	r24, 0x06	; 6
    275e:	8e c3       	rjmp	.+1820   	; 0x2e7c <_receive_data+0xbb4>
					break;

               case (unsigned char) SetSamplingRate:  
			   		_SAMPLING_RATE = m_SET_SR(rBuffer[1]);
    2760:	80 91 90 38 	lds	r24, 0x3890
    2764:	8f 77       	andi	r24, 0x7F	; 127
    2766:	80 93 06 01 	sts	0x0106, r24
					if (_SAMPLING_RATE > _MAX_SAMPLING_RATE)
    276a:	90 91 5f 01 	lds	r25, 0x015F
    276e:	98 17       	cp	r25, r24
    2770:	10 f4       	brcc	.+4      	; 0x2776 <_receive_data+0x4ae>
					{
						_SAMPLING_RATE = _MAX_SAMPLING_RATE;		
    2772:	90 93 06 01 	sts	0x0106, r25
					}
					if (_SAMPLING_RATE < _MIN_SAMPLING_RATE)
    2776:	80 91 0b 01 	lds	r24, 0x010B
    277a:	90 91 06 01 	lds	r25, 0x0106
    277e:	98 17       	cp	r25, r24
    2780:	10 f4       	brcc	.+4      	; 0x2786 <_receive_data+0x4be>
					{
						_SAMPLING_RATE = _MIN_SAMPLING_RATE;		
    2782:	80 93 06 01 	sts	0x0106, r24
					}
					_wocket_initialize_timer2_interrupt();
    2786:	0e 94 b5 0d 	call	0x1b6a	; 0x1b6a <_wocket_initialize_timer2_interrupt>
					eeprom_write_byte(&_NV_SAMPLING_RATE, _SAMPLING_RATE);
    278a:	82 e0       	ldi	r24, 0x02	; 2
    278c:	90 e0       	ldi	r25, 0x00	; 0
    278e:	60 91 06 01 	lds	r22, 0x0106
    2792:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					eeprom_write_byte(&_NV_TCT, _wTCNT2);
    2796:	83 e0       	ldi	r24, 0x03	; 3
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	60 91 4c 01 	lds	r22, 0x014C
    279e:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					eeprom_write_byte(&_NV_TCTREPS, _wTCNT2_reps);
    27a2:	84 e0       	ldi	r24, 0x04	; 4
    27a4:	90 e0       	ldi	r25, 0x00	; 0
    27a6:	60 91 07 01 	lds	r22, 0x0107
    27aa:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					eeprom_write_byte(&_NV_TCTLAST, _wTCNT2_last);
    27ae:	85 e0       	ldi	r24, 0x05	; 5
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	60 91 4d 01 	lds	r22, 0x014D
    27b6:	6c c3       	rjmp	.+1752   	; 0x2e90 <_receive_data+0xbc8>
					processed_counter = command_counter;
					break;

 			   case (unsigned char) GetRadioTransmissionMode:  
			   		aBuffer[0] = m_TM_RSP_BYTE0;
    27b8:	81 ed       	ldi	r24, 0xD1	; 209
    27ba:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_TM_RSP_BYTE1(_TM);
    27be:	80 91 8c 38 	lds	r24, 0x388C
    27c2:	87 70       	andi	r24, 0x07	; 7
    27c4:	82 95       	swap	r24
    27c6:	80 7f       	andi	r24, 0xF0	; 240
    27c8:	54 c3       	rjmp	.+1704   	; 0x2e72 <_receive_data+0xbaa>
					processed_counter = command_counter;
					response_length = 2;
					break;

               case (unsigned char) SetRadioTransmissionMode:  
			   		_TM = m_SET_TM(rBuffer[1]);
    27ca:	60 91 90 38 	lds	r22, 0x3890
    27ce:	62 95       	swap	r22
    27d0:	67 70       	andi	r22, 0x07	; 7
    27d2:	60 93 8c 38 	sts	0x388C, r22
					eeprom_write_byte(&_NV_TM, _TM);
    27d6:	86 e0       	ldi	r24, 0x06	; 6
    27d8:	90 e0       	ldi	r25, 0x00	; 0
    27da:	5a c3       	rjmp	.+1716   	; 0x2e90 <_receive_data+0xbc8>
					processed_counter = command_counter;
					break;

			   case (unsigned char) GetWocketTransmissionMode:  
			   		aBuffer[0] = m_WTM_RSP_BYTE0;
    27dc:	88 ec       	ldi	r24, 0xC8	; 200
    27de:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_WTM_RSP_BYTE1(_wTM);
    27e2:	80 91 4e 01 	lds	r24, 0x014E
    27e6:	ed cf       	rjmp	.-38     	; 0x27c2 <_receive_data+0x4fa>
					processed_counter = command_counter;
					response_length = 2;
					break;

               case (unsigned char) SetWocketTransmissionMode:  
			   		_wTM = m_SET_WTM(rBuffer[1]);
    27e8:	60 91 90 38 	lds	r22, 0x3890
    27ec:	62 95       	swap	r22
    27ee:	67 70       	andi	r22, 0x07	; 7
    27f0:	60 93 4e 01 	sts	0x014E, r22
					eeprom_write_byte(&_NV_WTM, _wTM);
    27f4:	87 e0       	ldi	r24, 0x07	; 7
    27f6:	90 e0       	ldi	r25, 0x00	; 0
    27f8:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					switch(_wTM)
    27fc:	80 91 4e 01 	lds	r24, 0x014E
    2800:	82 30       	cpi	r24, 0x02	; 2
    2802:	91 f0       	breq	.+36     	; 0x2828 <_receive_data+0x560>
    2804:	83 30       	cpi	r24, 0x03	; 3
    2806:	30 f4       	brcc	.+12     	; 0x2814 <_receive_data+0x54c>
    2808:	88 23       	and	r24, r24
    280a:	51 f0       	breq	.+20     	; 0x2820 <_receive_data+0x558>
    280c:	81 30       	cpi	r24, 0x01	; 1
    280e:	09 f0       	breq	.+2      	; 0x2812 <_receive_data+0x54a>
    2810:	41 c3       	rjmp	.+1666   	; 0x2e94 <_receive_data+0xbcc>
    2812:	08 c0       	rjmp	.+16     	; 0x2824 <_receive_data+0x55c>
    2814:	83 30       	cpi	r24, 0x03	; 3
    2816:	51 f0       	breq	.+20     	; 0x282c <_receive_data+0x564>
    2818:	84 30       	cpi	r24, 0x04	; 4
    281a:	09 f0       	breq	.+2      	; 0x281e <_receive_data+0x556>
    281c:	3b c3       	rjmp	.+1654   	; 0x2e94 <_receive_data+0xbcc>
    281e:	08 c0       	rjmp	.+16     	; 0x2830 <_receive_data+0x568>
					{
						case _WTM_Continuous:	
							_MAX_SAMPLING_RATE = 126; //This limitation is due to the definition of SEND_SR  and GET_SR commands
    2820:	8e e7       	ldi	r24, 0x7E	; 126
    2822:	07 c0       	rjmp	.+14     	; 0x2832 <_receive_data+0x56a>
							break;					  // The MCU provided in wocket able to sample at higher rates 							
						case _WTM_Burst_30:    	//a transfer mode that send the burst every 30 secs
							_MAX_SAMPLING_RATE = 80;		
    2824:	80 e5       	ldi	r24, 0x50	; 80
    2826:	05 c0       	rjmp	.+10     	; 0x2832 <_receive_data+0x56a>
							break;
						case _WTM_Burst_60:		//a transfer mode that send the burst every 60 secs
							_MAX_SAMPLING_RATE = 40;		
    2828:	88 e2       	ldi	r24, 0x28	; 40
    282a:	03 c0       	rjmp	.+6      	; 0x2832 <_receive_data+0x56a>
							break;
						case _WTM_Burst_90:		//a transfer mode that send the burst every 90 secs
							_MAX_SAMPLING_RATE = 30;		
    282c:	8e e1       	ldi	r24, 0x1E	; 30
    282e:	01 c0       	rjmp	.+2      	; 0x2832 <_receive_data+0x56a>
							break;
						case _WTM_Burst_120:	//a transfer mode that send the burst every 120 secs
							_MAX_SAMPLING_RATE = 20;		
    2830:	84 e1       	ldi	r24, 0x14	; 20
    2832:	80 93 5f 01 	sts	0x015F, r24
    2836:	2e c3       	rjmp	.+1628   	; 0x2e94 <_receive_data+0xbcc>
					}						
					processed_counter = command_counter;
					break;

               case (unsigned char) SetCalibrationValues:                                                                    
                    if (eeprom_is_ready())
    2838:	f9 99       	sbic	0x1f, 1	; 31
    283a:	30 c3       	rjmp	.+1632   	; 0x2e9c <_receive_data+0xbd4>
                    {                                    
                        if (_atmega_a2dConvert10bit(ADC7) < 600)
    283c:	87 e0       	ldi	r24, 0x07	; 7
    283e:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
    2842:	a2 e0       	ldi	r26, 0x02	; 2
    2844:	88 35       	cpi	r24, 0x58	; 88
    2846:	9a 07       	cpc	r25, r26
    2848:	08 f4       	brcc	.+2      	; 0x284c <_receive_data+0x584>
    284a:	28 c3       	rjmp	.+1616   	; 0x2e9c <_receive_data+0xbd4>
                                break;
                        else
                        {   
							_wX1G_CAL  = m_SET_CAL_x1g(rBuffer[1], rBuffer[2]);
    284c:	60 91 91 38 	lds	r22, 0x3891
    2850:	70 e0       	ldi	r23, 0x00	; 0
    2852:	60 77       	andi	r22, 0x70	; 112
    2854:	70 70       	andi	r23, 0x00	; 0
    2856:	14 e0       	ldi	r17, 0x04	; 4
    2858:	76 95       	lsr	r23
    285a:	67 95       	ror	r22
    285c:	1a 95       	dec	r17
    285e:	e1 f7       	brne	.-8      	; 0x2858 <_receive_data+0x590>
    2860:	80 91 90 38 	lds	r24, 0x3890
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	8f 77       	andi	r24, 0x7F	; 127
    2868:	90 70       	andi	r25, 0x00	; 0
    286a:	b3 e0       	ldi	r27, 0x03	; 3
    286c:	88 0f       	add	r24, r24
    286e:	99 1f       	adc	r25, r25
    2870:	ba 95       	dec	r27
    2872:	e1 f7       	brne	.-8      	; 0x286c <_receive_data+0x5a4>
    2874:	68 2b       	or	r22, r24
    2876:	79 2b       	or	r23, r25
    2878:	70 93 74 38 	sts	0x3874, r23
    287c:	60 93 73 38 	sts	0x3873, r22
							eeprom_write_word(&_NV_X1G_CAL,_wX1G_CAL);
    2880:	85 e1       	ldi	r24, 0x15	; 21
    2882:	90 e0       	ldi	r25, 0x00	; 0
    2884:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wXN1G_CAL = m_SET_CAL_xn1g(rBuffer[2], rBuffer[3]);
    2888:	60 91 92 38 	lds	r22, 0x3892
    288c:	70 e0       	ldi	r23, 0x00	; 0
    288e:	6e 77       	andi	r22, 0x7E	; 126
    2890:	70 70       	andi	r23, 0x00	; 0
    2892:	76 95       	lsr	r23
    2894:	67 95       	ror	r22
    2896:	80 91 91 38 	lds	r24, 0x3891
    289a:	90 e0       	ldi	r25, 0x00	; 0
    289c:	8f 70       	andi	r24, 0x0F	; 15
    289e:	90 70       	andi	r25, 0x00	; 0
    28a0:	f6 e0       	ldi	r31, 0x06	; 6
    28a2:	88 0f       	add	r24, r24
    28a4:	99 1f       	adc	r25, r25
    28a6:	fa 95       	dec	r31
    28a8:	e1 f7       	brne	.-8      	; 0x28a2 <_receive_data+0x5da>
    28aa:	68 2b       	or	r22, r24
    28ac:	79 2b       	or	r23, r25
    28ae:	70 93 76 38 	sts	0x3876, r23
    28b2:	60 93 75 38 	sts	0x3875, r22
							eeprom_write_word(&_NV_XN1G_CAL,_wXN1G_CAL);
    28b6:	87 e1       	ldi	r24, 0x17	; 23
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wY1G_CAL  = m_SET_CAL_y1g(rBuffer[3], rBuffer[4], rBuffer[5]);
    28be:	60 91 93 38 	lds	r22, 0x3893
    28c2:	70 e0       	ldi	r23, 0x00	; 0
    28c4:	6f 77       	andi	r22, 0x7F	; 127
    28c6:	70 70       	andi	r23, 0x00	; 0
    28c8:	66 0f       	add	r22, r22
    28ca:	77 1f       	adc	r23, r23
    28cc:	66 0f       	add	r22, r22
    28ce:	77 1f       	adc	r23, r23
    28d0:	80 91 92 38 	lds	r24, 0x3892
    28d4:	90 e0       	ldi	r25, 0x00	; 0
    28d6:	81 70       	andi	r24, 0x01	; 1
    28d8:	90 70       	andi	r25, 0x00	; 0
    28da:	98 2f       	mov	r25, r24
    28dc:	88 27       	eor	r24, r24
    28de:	99 0f       	add	r25, r25
    28e0:	68 2b       	or	r22, r24
    28e2:	79 2b       	or	r23, r25
    28e4:	80 91 94 38 	lds	r24, 0x3894
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	80 76       	andi	r24, 0x60	; 96
    28ec:	90 70       	andi	r25, 0x00	; 0
    28ee:	45 e0       	ldi	r20, 0x05	; 5
    28f0:	96 95       	lsr	r25
    28f2:	87 95       	ror	r24
    28f4:	4a 95       	dec	r20
    28f6:	e1 f7       	brne	.-8      	; 0x28f0 <_receive_data+0x628>
    28f8:	68 2b       	or	r22, r24
    28fa:	79 2b       	or	r23, r25
    28fc:	70 93 8e 38 	sts	0x388E, r23
    2900:	60 93 8d 38 	sts	0x388D, r22
							eeprom_write_word(&_NV_Y1G_CAL,_wY1G_CAL);
    2904:	89 e1       	ldi	r24, 0x19	; 25
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wYN1G_CAL = m_SET_CAL_yn1g(rBuffer[5], rBuffer[6]);
    290c:	60 91 95 38 	lds	r22, 0x3895
    2910:	70 e0       	ldi	r23, 0x00	; 0
    2912:	6c 77       	andi	r22, 0x7C	; 124
    2914:	70 70       	andi	r23, 0x00	; 0
    2916:	76 95       	lsr	r23
    2918:	67 95       	ror	r22
    291a:	76 95       	lsr	r23
    291c:	67 95       	ror	r22
    291e:	80 91 94 38 	lds	r24, 0x3894
    2922:	90 e0       	ldi	r25, 0x00	; 0
    2924:	8f 71       	andi	r24, 0x1F	; 31
    2926:	90 70       	andi	r25, 0x00	; 0
    2928:	25 e0       	ldi	r18, 0x05	; 5
    292a:	88 0f       	add	r24, r24
    292c:	99 1f       	adc	r25, r25
    292e:	2a 95       	dec	r18
    2930:	e1 f7       	brne	.-8      	; 0x292a <_receive_data+0x662>
    2932:	68 2b       	or	r22, r24
    2934:	79 2b       	or	r23, r25
    2936:	70 93 7a 38 	sts	0x387A, r23
    293a:	60 93 79 38 	sts	0x3879, r22
							eeprom_write_word(&_NV_YN1G_CAL, _wYN1G_CAL);
    293e:	8b e1       	ldi	r24, 0x1B	; 27
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wZ1G_CAL  = m_SET_CAL_z1g(rBuffer[6], rBuffer[7], rBuffer[8]);
    2946:	60 91 96 38 	lds	r22, 0x3896
    294a:	70 e0       	ldi	r23, 0x00	; 0
    294c:	66 0f       	add	r22, r22
    294e:	77 1f       	adc	r23, r23
    2950:	70 70       	andi	r23, 0x00	; 0
    2952:	80 91 95 38 	lds	r24, 0x3895
    2956:	90 e0       	ldi	r25, 0x00	; 0
    2958:	83 70       	andi	r24, 0x03	; 3
    295a:	90 70       	andi	r25, 0x00	; 0
    295c:	98 2f       	mov	r25, r24
    295e:	88 27       	eor	r24, r24
    2960:	68 2b       	or	r22, r24
    2962:	79 2b       	or	r23, r25
    2964:	80 91 97 38 	lds	r24, 0x3897
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	80 74       	andi	r24, 0x40	; 64
    296c:	90 70       	andi	r25, 0x00	; 0
    296e:	b6 e0       	ldi	r27, 0x06	; 6
    2970:	96 95       	lsr	r25
    2972:	87 95       	ror	r24
    2974:	ba 95       	dec	r27
    2976:	e1 f7       	brne	.-8      	; 0x2970 <_receive_data+0x6a8>
    2978:	68 2b       	or	r22, r24
    297a:	79 2b       	or	r23, r25
    297c:	70 93 80 38 	sts	0x3880, r23
    2980:	60 93 7f 38 	sts	0x387F, r22
							eeprom_write_word(&_NV_Z1G_CAL, _wZ1G_CAL);
    2984:	8d e1       	ldi	r24, 0x1D	; 29
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wZN1G_CAL = m_SET_CAL_zn1g(rBuffer[8], rBuffer[8]);
    298c:	80 91 97 38 	lds	r24, 0x3897
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	bc 01       	movw	r22, r24
    2994:	68 77       	andi	r22, 0x78	; 120
    2996:	70 70       	andi	r23, 0x00	; 0
    2998:	a3 e0       	ldi	r26, 0x03	; 3
    299a:	76 95       	lsr	r23
    299c:	67 95       	ror	r22
    299e:	aa 95       	dec	r26
    29a0:	e1 f7       	brne	.-8      	; 0x299a <_receive_data+0x6d2>
    29a2:	8f 73       	andi	r24, 0x3F	; 63
    29a4:	90 70       	andi	r25, 0x00	; 0
    29a6:	f4 e0       	ldi	r31, 0x04	; 4
    29a8:	88 0f       	add	r24, r24
    29aa:	99 1f       	adc	r25, r25
    29ac:	fa 95       	dec	r31
    29ae:	e1 f7       	brne	.-8      	; 0x29a8 <_receive_data+0x6e0>
    29b0:	68 2b       	or	r22, r24
    29b2:	79 2b       	or	r23, r25
    29b4:	70 93 7e 38 	sts	0x387E, r23
    29b8:	60 93 7d 38 	sts	0x387D, r22
							eeprom_write_word(&_NV_ZN1G_CAL, _wZN1G_CAL);
    29bc:	8f e1       	ldi	r24, 0x1F	; 31
    29be:	90 e0       	ldi	r25, 0x00	; 0
    29c0:	a7 c1       	rjmp	.+846    	; 0x2d10 <_receive_data+0xa48>
                    }                                                                                                                       
                    //enable global interrupts
                    break;

                case (unsigned char) GetCalibrationValues:							                                                              
					aBuffer[0] = m_CAL_RSP_BYTE0;
    29c2:	84 ec       	ldi	r24, 0xC4	; 196
    29c4:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_CAL_RSP_BYTE1_x1g(_wX1G_CAL);                                                                   
    29c8:	80 91 73 38 	lds	r24, 0x3873
    29cc:	90 91 74 38 	lds	r25, 0x3874
    29d0:	9c 01       	movw	r18, r24
    29d2:	e3 e0       	ldi	r30, 0x03	; 3
    29d4:	36 95       	lsr	r19
    29d6:	27 95       	ror	r18
    29d8:	ea 95       	dec	r30
    29da:	e1 f7       	brne	.-8      	; 0x29d4 <_receive_data+0x70c>
    29dc:	2f 77       	andi	r18, 0x7F	; 127
    29de:	20 93 9a 38 	sts	0x389A, r18
                    aBuffer[2] = m_CAL_RSP_BYTE2_x1g(_wX1G_CAL);
					aBuffer[2]|= m_CAL_RSP_BYTE2_xn1g(_wXN1G_CAL);
    29e2:	20 91 75 38 	lds	r18, 0x3875
    29e6:	30 91 76 38 	lds	r19, 0x3876
    29ea:	a9 01       	movw	r20, r18
    29ec:	76 e0       	ldi	r23, 0x06	; 6
    29ee:	56 95       	lsr	r21
    29f0:	47 95       	ror	r20
    29f2:	7a 95       	dec	r23
    29f4:	e1 f7       	brne	.-8      	; 0x29ee <_receive_data+0x726>
    29f6:	4f 70       	andi	r20, 0x0F	; 15
                    break;

                case (unsigned char) GetCalibrationValues:							                                                              
					aBuffer[0] = m_CAL_RSP_BYTE0;
                    aBuffer[1] = m_CAL_RSP_BYTE1_x1g(_wX1G_CAL);                                                                   
                    aBuffer[2] = m_CAL_RSP_BYTE2_x1g(_wX1G_CAL);
    29f8:	82 95       	swap	r24
    29fa:	80 77       	andi	r24, 0x70	; 112
					aBuffer[2]|= m_CAL_RSP_BYTE2_xn1g(_wXN1G_CAL);
    29fc:	48 2b       	or	r20, r24
    29fe:	40 93 9b 38 	sts	0x389B, r20
                    aBuffer[3] = m_CAL_RSP_BYTE3_xn1g(_wXN1G_CAL);
					aBuffer[3]|= m_CAL_RSP_BYTE3_y1g(_wY1G_CAL);
    2a02:	80 91 8d 38 	lds	r24, 0x388D
    2a06:	90 91 8e 38 	lds	r25, 0x388E
    2a0a:	49 2f       	mov	r20, r25
    2a0c:	46 95       	lsr	r20
    2a0e:	41 70       	andi	r20, 0x01	; 1
                case (unsigned char) GetCalibrationValues:							                                                              
					aBuffer[0] = m_CAL_RSP_BYTE0;
                    aBuffer[1] = m_CAL_RSP_BYTE1_x1g(_wX1G_CAL);                                                                   
                    aBuffer[2] = m_CAL_RSP_BYTE2_x1g(_wX1G_CAL);
					aBuffer[2]|= m_CAL_RSP_BYTE2_xn1g(_wXN1G_CAL);
                    aBuffer[3] = m_CAL_RSP_BYTE3_xn1g(_wXN1G_CAL);
    2a10:	22 0f       	add	r18, r18
    2a12:	2e 77       	andi	r18, 0x7E	; 126
					aBuffer[3]|= m_CAL_RSP_BYTE3_y1g(_wY1G_CAL);
    2a14:	42 2b       	or	r20, r18
    2a16:	40 93 9c 38 	sts	0x389C, r20
                    aBuffer[4] = m_CAL_RSP_BYTE4_y1g(_wY1G_CAL);
    2a1a:	9c 01       	movw	r18, r24
    2a1c:	36 95       	lsr	r19
    2a1e:	27 95       	ror	r18
    2a20:	36 95       	lsr	r19
    2a22:	27 95       	ror	r18
    2a24:	2f 77       	andi	r18, 0x7F	; 127
    2a26:	20 93 9d 38 	sts	0x389D, r18
                    aBuffer[5] = m_CAL_RSP_BYTE5_y1g(_wY1G_CAL);
                    aBuffer[5]|= m_CAL_RSP_BYTE5_yn1g(_wYN1G_CAL);
    2a2a:	20 91 79 38 	lds	r18, 0x3879
    2a2e:	30 91 7a 38 	lds	r19, 0x387A
    2a32:	a9 01       	movw	r20, r18
    2a34:	35 e0       	ldi	r19, 0x05	; 5
    2a36:	56 95       	lsr	r21
    2a38:	47 95       	ror	r20
    2a3a:	3a 95       	dec	r19
    2a3c:	e1 f7       	brne	.-8      	; 0x2a36 <_receive_data+0x76e>
    2a3e:	4f 71       	andi	r20, 0x1F	; 31
                    aBuffer[2] = m_CAL_RSP_BYTE2_x1g(_wX1G_CAL);
					aBuffer[2]|= m_CAL_RSP_BYTE2_xn1g(_wXN1G_CAL);
                    aBuffer[3] = m_CAL_RSP_BYTE3_xn1g(_wXN1G_CAL);
					aBuffer[3]|= m_CAL_RSP_BYTE3_y1g(_wY1G_CAL);
                    aBuffer[4] = m_CAL_RSP_BYTE4_y1g(_wY1G_CAL);
                    aBuffer[5] = m_CAL_RSP_BYTE5_y1g(_wY1G_CAL);
    2a40:	82 95       	swap	r24
    2a42:	88 0f       	add	r24, r24
    2a44:	80 76       	andi	r24, 0x60	; 96
                    aBuffer[5]|= m_CAL_RSP_BYTE5_yn1g(_wYN1G_CAL);
    2a46:	48 2b       	or	r20, r24
    2a48:	40 93 9e 38 	sts	0x389E, r20
                    aBuffer[6] = m_CAL_RSP_BYTE6_yn1g(_wYN1G_CAL);
					aBuffer[6]|= m_CAL_RSP_BYTE6_z1g(_wZ1G_CAL);
    2a4c:	80 91 7f 38 	lds	r24, 0x387F
    2a50:	90 91 80 38 	lds	r25, 0x3880
    2a54:	49 2f       	mov	r20, r25
    2a56:	43 70       	andi	r20, 0x03	; 3
                    aBuffer[3] = m_CAL_RSP_BYTE3_xn1g(_wXN1G_CAL);
					aBuffer[3]|= m_CAL_RSP_BYTE3_y1g(_wY1G_CAL);
                    aBuffer[4] = m_CAL_RSP_BYTE4_y1g(_wY1G_CAL);
                    aBuffer[5] = m_CAL_RSP_BYTE5_y1g(_wY1G_CAL);
                    aBuffer[5]|= m_CAL_RSP_BYTE5_yn1g(_wYN1G_CAL);
                    aBuffer[6] = m_CAL_RSP_BYTE6_yn1g(_wYN1G_CAL);
    2a58:	22 0f       	add	r18, r18
    2a5a:	22 0f       	add	r18, r18
    2a5c:	2c 77       	andi	r18, 0x7C	; 124
					aBuffer[6]|= m_CAL_RSP_BYTE6_z1g(_wZ1G_CAL);
    2a5e:	42 2b       	or	r20, r18
    2a60:	40 93 9f 38 	sts	0x389F, r20
                    aBuffer[7] = m_CAL_RSP_BYTE7_z1g(_wZ1G_CAL);
    2a64:	9c 01       	movw	r18, r24
    2a66:	36 95       	lsr	r19
    2a68:	27 95       	ror	r18
    2a6a:	2f 77       	andi	r18, 0x7F	; 127
    2a6c:	20 93 a0 38 	sts	0x38A0, r18
                    aBuffer[8] = m_CAL_RSP_BYTE8_z1g(_wZ1G_CAL);
					aBuffer[8]|= m_CAL_RSP_BYTE8_zn1g(_wZN1G_CAL);
    2a70:	20 91 7d 38 	lds	r18, 0x387D
    2a74:	30 91 7e 38 	lds	r19, 0x387E
    2a78:	a9 01       	movw	r20, r18
    2a7a:	04 e0       	ldi	r16, 0x04	; 4
    2a7c:	56 95       	lsr	r21
    2a7e:	47 95       	ror	r20
    2a80:	0a 95       	dec	r16
    2a82:	e1 f7       	brne	.-8      	; 0x2a7c <_receive_data+0x7b4>
    2a84:	4f 73       	andi	r20, 0x3F	; 63
                    aBuffer[5] = m_CAL_RSP_BYTE5_y1g(_wY1G_CAL);
                    aBuffer[5]|= m_CAL_RSP_BYTE5_yn1g(_wYN1G_CAL);
                    aBuffer[6] = m_CAL_RSP_BYTE6_yn1g(_wYN1G_CAL);
					aBuffer[6]|= m_CAL_RSP_BYTE6_z1g(_wZ1G_CAL);
                    aBuffer[7] = m_CAL_RSP_BYTE7_z1g(_wZ1G_CAL);
                    aBuffer[8] = m_CAL_RSP_BYTE8_z1g(_wZ1G_CAL);
    2a86:	82 95       	swap	r24
    2a88:	88 0f       	add	r24, r24
    2a8a:	88 0f       	add	r24, r24
    2a8c:	80 74       	andi	r24, 0x40	; 64
					aBuffer[8]|= m_CAL_RSP_BYTE8_zn1g(_wZN1G_CAL);
    2a8e:	48 2b       	or	r20, r24
    2a90:	40 93 a1 38 	sts	0x38A1, r20
                    aBuffer[9] = m_CAL_RSP_BYTE9_zn1g(_wZN1G_CAL);
    2a94:	22 0f       	add	r18, r18
    2a96:	22 0f       	add	r18, r18
    2a98:	22 0f       	add	r18, r18
    2a9a:	28 77       	andi	r18, 0x78	; 120
    2a9c:	20 93 a2 38 	sts	0x38A2, r18
    2aa0:	6f c0       	rjmp	.+222    	; 0x2b80 <_receive_data+0x8b8>
					processed_counter = command_counter;
                    response_length = 10;                                                                               
                    break;    

                case (unsigned char) GetBatteryCalibration:							                                                              
					aBuffer[0] = m_BTCAL_RSP_BYTE0;
    2aa2:	89 ec       	ldi	r24, 0xC9	; 201
    2aa4:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_BTCAL_RSP_BYTE1_100(_wBTCAL100);                                                                   
    2aa8:	80 91 7b 38 	lds	r24, 0x387B
    2aac:	90 91 7c 38 	lds	r25, 0x387C
    2ab0:	9c 01       	movw	r18, r24
    2ab2:	13 e0       	ldi	r17, 0x03	; 3
    2ab4:	36 95       	lsr	r19
    2ab6:	27 95       	ror	r18
    2ab8:	1a 95       	dec	r17
    2aba:	e1 f7       	brne	.-8      	; 0x2ab4 <_receive_data+0x7ec>
    2abc:	2f 77       	andi	r18, 0x7F	; 127
    2abe:	20 93 9a 38 	sts	0x389A, r18
                    aBuffer[2] = m_BTCAL_RSP_BYTE2_100(_wBTCAL100);
					aBuffer[2]|= m_BTCAL_RSP_BYTE2_80(_wBTCAL80);
    2ac2:	20 91 8a 38 	lds	r18, 0x388A
    2ac6:	30 91 8b 38 	lds	r19, 0x388B
    2aca:	a9 01       	movw	r20, r18
    2acc:	b6 e0       	ldi	r27, 0x06	; 6
    2ace:	56 95       	lsr	r21
    2ad0:	47 95       	ror	r20
    2ad2:	ba 95       	dec	r27
    2ad4:	e1 f7       	brne	.-8      	; 0x2ace <_receive_data+0x806>
    2ad6:	4f 70       	andi	r20, 0x0F	; 15
                    break;    

                case (unsigned char) GetBatteryCalibration:							                                                              
					aBuffer[0] = m_BTCAL_RSP_BYTE0;
                    aBuffer[1] = m_BTCAL_RSP_BYTE1_100(_wBTCAL100);                                                                   
                    aBuffer[2] = m_BTCAL_RSP_BYTE2_100(_wBTCAL100);
    2ad8:	82 95       	swap	r24
    2ada:	80 77       	andi	r24, 0x70	; 112
					aBuffer[2]|= m_BTCAL_RSP_BYTE2_80(_wBTCAL80);
    2adc:	48 2b       	or	r20, r24
    2ade:	40 93 9b 38 	sts	0x389B, r20
                    aBuffer[3] = m_BTCAL_RSP_BYTE3_80(_wBTCAL80);
					aBuffer[3]|= m_BTCAL_RSP_BYTE3_60(_wBTCAL60);
    2ae2:	80 91 83 38 	lds	r24, 0x3883
    2ae6:	90 91 84 38 	lds	r25, 0x3884
    2aea:	49 2f       	mov	r20, r25
    2aec:	46 95       	lsr	r20
    2aee:	41 70       	andi	r20, 0x01	; 1
                case (unsigned char) GetBatteryCalibration:							                                                              
					aBuffer[0] = m_BTCAL_RSP_BYTE0;
                    aBuffer[1] = m_BTCAL_RSP_BYTE1_100(_wBTCAL100);                                                                   
                    aBuffer[2] = m_BTCAL_RSP_BYTE2_100(_wBTCAL100);
					aBuffer[2]|= m_BTCAL_RSP_BYTE2_80(_wBTCAL80);
                    aBuffer[3] = m_BTCAL_RSP_BYTE3_80(_wBTCAL80);
    2af0:	22 0f       	add	r18, r18
    2af2:	2e 77       	andi	r18, 0x7E	; 126
					aBuffer[3]|= m_BTCAL_RSP_BYTE3_60(_wBTCAL60);
    2af4:	42 2b       	or	r20, r18
    2af6:	40 93 9c 38 	sts	0x389C, r20
                    aBuffer[4] = m_BTCAL_RSP_BYTE4_60(_wBTCAL60);
    2afa:	9c 01       	movw	r18, r24
    2afc:	36 95       	lsr	r19
    2afe:	27 95       	ror	r18
    2b00:	36 95       	lsr	r19
    2b02:	27 95       	ror	r18
    2b04:	2f 77       	andi	r18, 0x7F	; 127
    2b06:	20 93 9d 38 	sts	0x389D, r18
                    aBuffer[5] = m_BTCAL_RSP_BYTE5_60(_wBTCAL60);
                    aBuffer[5]|= m_BTCAL_RSP_BYTE5_40(_wBTCAL40);
    2b0a:	20 91 81 38 	lds	r18, 0x3881
    2b0e:	30 91 82 38 	lds	r19, 0x3882
    2b12:	a9 01       	movw	r20, r18
    2b14:	f5 e0       	ldi	r31, 0x05	; 5
    2b16:	56 95       	lsr	r21
    2b18:	47 95       	ror	r20
    2b1a:	fa 95       	dec	r31
    2b1c:	e1 f7       	brne	.-8      	; 0x2b16 <_receive_data+0x84e>
    2b1e:	4f 71       	andi	r20, 0x1F	; 31
                    aBuffer[2] = m_BTCAL_RSP_BYTE2_100(_wBTCAL100);
					aBuffer[2]|= m_BTCAL_RSP_BYTE2_80(_wBTCAL80);
                    aBuffer[3] = m_BTCAL_RSP_BYTE3_80(_wBTCAL80);
					aBuffer[3]|= m_BTCAL_RSP_BYTE3_60(_wBTCAL60);
                    aBuffer[4] = m_BTCAL_RSP_BYTE4_60(_wBTCAL60);
                    aBuffer[5] = m_BTCAL_RSP_BYTE5_60(_wBTCAL60);
    2b20:	82 95       	swap	r24
    2b22:	88 0f       	add	r24, r24
    2b24:	80 76       	andi	r24, 0x60	; 96
                    aBuffer[5]|= m_BTCAL_RSP_BYTE5_40(_wBTCAL40);
    2b26:	48 2b       	or	r20, r24
    2b28:	40 93 9e 38 	sts	0x389E, r20
                    aBuffer[6] = m_BTCAL_RSP_BYTE6_40(_wBTCAL40);
					aBuffer[6]|= m_BTCAL_RSP_BYTE6_20(_wBTCAL20);
    2b2c:	80 91 77 38 	lds	r24, 0x3877
    2b30:	90 91 78 38 	lds	r25, 0x3878
    2b34:	49 2f       	mov	r20, r25
    2b36:	43 70       	andi	r20, 0x03	; 3
                    aBuffer[3] = m_BTCAL_RSP_BYTE3_80(_wBTCAL80);
					aBuffer[3]|= m_BTCAL_RSP_BYTE3_60(_wBTCAL60);
                    aBuffer[4] = m_BTCAL_RSP_BYTE4_60(_wBTCAL60);
                    aBuffer[5] = m_BTCAL_RSP_BYTE5_60(_wBTCAL60);
                    aBuffer[5]|= m_BTCAL_RSP_BYTE5_40(_wBTCAL40);
                    aBuffer[6] = m_BTCAL_RSP_BYTE6_40(_wBTCAL40);
    2b38:	22 0f       	add	r18, r18
    2b3a:	22 0f       	add	r18, r18
    2b3c:	2c 77       	andi	r18, 0x7C	; 124
					aBuffer[6]|= m_BTCAL_RSP_BYTE6_20(_wBTCAL20);
    2b3e:	42 2b       	or	r20, r18
    2b40:	40 93 9f 38 	sts	0x389F, r20
                    aBuffer[7] = m_BTCAL_RSP_BYTE7_20(_wBTCAL20);
    2b44:	9c 01       	movw	r18, r24
    2b46:	36 95       	lsr	r19
    2b48:	27 95       	ror	r18
    2b4a:	2f 77       	andi	r18, 0x7F	; 127
    2b4c:	20 93 a0 38 	sts	0x38A0, r18
                    aBuffer[8] = m_BTCAL_RSP_BYTE8_20(_wBTCAL20);
					aBuffer[8]|= m_BTCAL_RSP_BYTE8_10(_wBTCAL10);
    2b50:	20 91 87 38 	lds	r18, 0x3887
    2b54:	30 91 88 38 	lds	r19, 0x3888
    2b58:	a9 01       	movw	r20, r18
    2b5a:	74 e0       	ldi	r23, 0x04	; 4
    2b5c:	56 95       	lsr	r21
    2b5e:	47 95       	ror	r20
    2b60:	7a 95       	dec	r23
    2b62:	e1 f7       	brne	.-8      	; 0x2b5c <_receive_data+0x894>
    2b64:	4f 73       	andi	r20, 0x3F	; 63
                    aBuffer[5] = m_BTCAL_RSP_BYTE5_60(_wBTCAL60);
                    aBuffer[5]|= m_BTCAL_RSP_BYTE5_40(_wBTCAL40);
                    aBuffer[6] = m_BTCAL_RSP_BYTE6_40(_wBTCAL40);
					aBuffer[6]|= m_BTCAL_RSP_BYTE6_20(_wBTCAL20);
                    aBuffer[7] = m_BTCAL_RSP_BYTE7_20(_wBTCAL20);
                    aBuffer[8] = m_BTCAL_RSP_BYTE8_20(_wBTCAL20);
    2b66:	82 95       	swap	r24
    2b68:	88 0f       	add	r24, r24
    2b6a:	88 0f       	add	r24, r24
    2b6c:	80 74       	andi	r24, 0x40	; 64
					aBuffer[8]|= m_BTCAL_RSP_BYTE8_10(_wBTCAL10);
    2b6e:	48 2b       	or	r20, r24
    2b70:	40 93 a1 38 	sts	0x38A1, r20
                    rBuffer[9] = m_BTCAL_RSP_BYTE9_10(_wBTCAL10);
    2b74:	22 0f       	add	r18, r18
    2b76:	22 0f       	add	r18, r18
    2b78:	22 0f       	add	r18, r18
    2b7a:	28 77       	andi	r18, 0x78	; 120
    2b7c:	20 93 98 38 	sts	0x3898, r18
					processed_counter = command_counter;
    2b80:	60 93 3b 01 	sts	0x013B, r22
                    response_length = 10;                                                                               
    2b84:	8a e0       	ldi	r24, 0x0A	; 10
    2b86:	7a c1       	rjmp	.+756    	; 0x2e7c <_receive_data+0xbb4>

				case (unsigned char) SetBatteryCalibration:
				/*All of the read/write functions first make sure the EEPROM is ready to be accessed. 
				Since this may cause long delays if a write operation is still pending, timecritical 
				applications should first poll the EEPROM e. g. using eeprom_is_ready()	*/
                    if (eeprom_is_ready())
    2b88:	f9 99       	sbic	0x1f, 1	; 31
    2b8a:	88 c1       	rjmp	.+784    	; 0x2e9c <_receive_data+0xbd4>
                    {                                    
                        if (_atmega_a2dConvert10bit(ADC7) < 600) 
    2b8c:	87 e0       	ldi	r24, 0x07	; 7
    2b8e:	0e 94 2f 0a 	call	0x145e	; 0x145e <_atmega_a2dConvert10bit>
    2b92:	b2 e0       	ldi	r27, 0x02	; 2
    2b94:	88 35       	cpi	r24, 0x58	; 88
    2b96:	9b 07       	cpc	r25, r27
    2b98:	08 f4       	brcc	.+2      	; 0x2b9c <_receive_data+0x8d4>
    2b9a:	80 c1       	rjmp	.+768    	; 0x2e9c <_receive_data+0xbd4>
                	        break;
                        else
                        {   
							_wBTCAL100 = m_SET_BTCAL_100(rBuffer[1], rBuffer[2]);
    2b9c:	60 91 91 38 	lds	r22, 0x3891
    2ba0:	70 e0       	ldi	r23, 0x00	; 0
    2ba2:	60 77       	andi	r22, 0x70	; 112
    2ba4:	70 70       	andi	r23, 0x00	; 0
    2ba6:	54 e0       	ldi	r21, 0x04	; 4
    2ba8:	76 95       	lsr	r23
    2baa:	67 95       	ror	r22
    2bac:	5a 95       	dec	r21
    2bae:	e1 f7       	brne	.-8      	; 0x2ba8 <_receive_data+0x8e0>
    2bb0:	80 91 90 38 	lds	r24, 0x3890
    2bb4:	90 e0       	ldi	r25, 0x00	; 0
    2bb6:	8f 77       	andi	r24, 0x7F	; 127
    2bb8:	90 70       	andi	r25, 0x00	; 0
    2bba:	43 e0       	ldi	r20, 0x03	; 3
    2bbc:	88 0f       	add	r24, r24
    2bbe:	99 1f       	adc	r25, r25
    2bc0:	4a 95       	dec	r20
    2bc2:	e1 f7       	brne	.-8      	; 0x2bbc <_receive_data+0x8f4>
    2bc4:	68 2b       	or	r22, r24
    2bc6:	79 2b       	or	r23, r25
    2bc8:	70 93 7c 38 	sts	0x387C, r23
    2bcc:	60 93 7b 38 	sts	0x387B, r22
							eeprom_write_word(&_NV_BTCAL100, _wBTCAL100);
    2bd0:	89 e0       	ldi	r24, 0x09	; 9
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wBTCAL80  = m_SET_BTCAL_80(rBuffer[2], rBuffer[3]);
    2bd8:	60 91 92 38 	lds	r22, 0x3892
    2bdc:	70 e0       	ldi	r23, 0x00	; 0
    2bde:	6e 77       	andi	r22, 0x7E	; 126
    2be0:	70 70       	andi	r23, 0x00	; 0
    2be2:	76 95       	lsr	r23
    2be4:	67 95       	ror	r22
    2be6:	80 91 91 38 	lds	r24, 0x3891
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	8f 70       	andi	r24, 0x0F	; 15
    2bee:	90 70       	andi	r25, 0x00	; 0
    2bf0:	26 e0       	ldi	r18, 0x06	; 6
    2bf2:	88 0f       	add	r24, r24
    2bf4:	99 1f       	adc	r25, r25
    2bf6:	2a 95       	dec	r18
    2bf8:	e1 f7       	brne	.-8      	; 0x2bf2 <_receive_data+0x92a>
    2bfa:	68 2b       	or	r22, r24
    2bfc:	79 2b       	or	r23, r25
    2bfe:	70 93 8b 38 	sts	0x388B, r23
    2c02:	60 93 8a 38 	sts	0x388A, r22
							eeprom_write_word(&_NV_BTCAL80, _wBTCAL80);
    2c06:	8b e0       	ldi	r24, 0x0B	; 11
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wBTCAL60  = m_SET_BTCAL_60(rBuffer[3], rBuffer[4], rBuffer[5]);
    2c0e:	60 91 93 38 	lds	r22, 0x3893
    2c12:	70 e0       	ldi	r23, 0x00	; 0
    2c14:	6f 77       	andi	r22, 0x7F	; 127
    2c16:	70 70       	andi	r23, 0x00	; 0
    2c18:	66 0f       	add	r22, r22
    2c1a:	77 1f       	adc	r23, r23
    2c1c:	66 0f       	add	r22, r22
    2c1e:	77 1f       	adc	r23, r23
    2c20:	80 91 92 38 	lds	r24, 0x3892
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	81 70       	andi	r24, 0x01	; 1
    2c28:	90 70       	andi	r25, 0x00	; 0
    2c2a:	98 2f       	mov	r25, r24
    2c2c:	88 27       	eor	r24, r24
    2c2e:	99 0f       	add	r25, r25
    2c30:	68 2b       	or	r22, r24
    2c32:	79 2b       	or	r23, r25
    2c34:	80 91 94 38 	lds	r24, 0x3894
    2c38:	90 e0       	ldi	r25, 0x00	; 0
    2c3a:	80 76       	andi	r24, 0x60	; 96
    2c3c:	90 70       	andi	r25, 0x00	; 0
    2c3e:	b5 e0       	ldi	r27, 0x05	; 5
    2c40:	96 95       	lsr	r25
    2c42:	87 95       	ror	r24
    2c44:	ba 95       	dec	r27
    2c46:	e1 f7       	brne	.-8      	; 0x2c40 <_receive_data+0x978>
    2c48:	68 2b       	or	r22, r24
    2c4a:	79 2b       	or	r23, r25
    2c4c:	70 93 84 38 	sts	0x3884, r23
    2c50:	60 93 83 38 	sts	0x3883, r22
							eeprom_write_word(&_NV_BTCAL60, _wBTCAL60);
    2c54:	8d e0       	ldi	r24, 0x0D	; 13
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wBTCAL40  = m_SET_BTCAL_40(rBuffer[5], rBuffer[6]);
    2c5c:	60 91 95 38 	lds	r22, 0x3895
    2c60:	70 e0       	ldi	r23, 0x00	; 0
    2c62:	6c 77       	andi	r22, 0x7C	; 124
    2c64:	70 70       	andi	r23, 0x00	; 0
    2c66:	76 95       	lsr	r23
    2c68:	67 95       	ror	r22
    2c6a:	76 95       	lsr	r23
    2c6c:	67 95       	ror	r22
    2c6e:	80 91 94 38 	lds	r24, 0x3894
    2c72:	90 e0       	ldi	r25, 0x00	; 0
    2c74:	8f 71       	andi	r24, 0x1F	; 31
    2c76:	90 70       	andi	r25, 0x00	; 0
    2c78:	f5 e0       	ldi	r31, 0x05	; 5
    2c7a:	88 0f       	add	r24, r24
    2c7c:	99 1f       	adc	r25, r25
    2c7e:	fa 95       	dec	r31
    2c80:	e1 f7       	brne	.-8      	; 0x2c7a <_receive_data+0x9b2>
    2c82:	68 2b       	or	r22, r24
    2c84:	79 2b       	or	r23, r25
    2c86:	70 93 82 38 	sts	0x3882, r23
    2c8a:	60 93 81 38 	sts	0x3881, r22
							eeprom_write_word(&_NV_BTCAL40, _wBTCAL40);
    2c8e:	8f e0       	ldi	r24, 0x0F	; 15
    2c90:	90 e0       	ldi	r25, 0x00	; 0
    2c92:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wBTCAL20  = m_SET_BTCAL_20(rBuffer[6], rBuffer[7], rBuffer[8]);
    2c96:	60 91 96 38 	lds	r22, 0x3896
    2c9a:	70 e0       	ldi	r23, 0x00	; 0
    2c9c:	66 0f       	add	r22, r22
    2c9e:	77 1f       	adc	r23, r23
    2ca0:	70 70       	andi	r23, 0x00	; 0
    2ca2:	80 91 95 38 	lds	r24, 0x3895
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	83 70       	andi	r24, 0x03	; 3
    2caa:	90 70       	andi	r25, 0x00	; 0
    2cac:	98 2f       	mov	r25, r24
    2cae:	88 27       	eor	r24, r24
    2cb0:	68 2b       	or	r22, r24
    2cb2:	79 2b       	or	r23, r25
    2cb4:	80 91 97 38 	lds	r24, 0x3897
    2cb8:	90 e0       	ldi	r25, 0x00	; 0
    2cba:	80 74       	andi	r24, 0x40	; 64
    2cbc:	90 70       	andi	r25, 0x00	; 0
    2cbe:	46 e0       	ldi	r20, 0x06	; 6
    2cc0:	96 95       	lsr	r25
    2cc2:	87 95       	ror	r24
    2cc4:	4a 95       	dec	r20
    2cc6:	e1 f7       	brne	.-8      	; 0x2cc0 <_receive_data+0x9f8>
    2cc8:	68 2b       	or	r22, r24
    2cca:	79 2b       	or	r23, r25
    2ccc:	70 93 78 38 	sts	0x3878, r23
    2cd0:	60 93 77 38 	sts	0x3877, r22
							eeprom_write_word(&_NV_BTCAL20, _wBTCAL20);
    2cd4:	81 e1       	ldi	r24, 0x11	; 17
    2cd6:	90 e0       	ldi	r25, 0x00	; 0
    2cd8:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
							_wBTCAL10  = m_SET_BTCAL_10(rBuffer[8], rBuffer[8]);
    2cdc:	80 91 97 38 	lds	r24, 0x3897
    2ce0:	90 e0       	ldi	r25, 0x00	; 0
    2ce2:	bc 01       	movw	r22, r24
    2ce4:	68 77       	andi	r22, 0x78	; 120
    2ce6:	70 70       	andi	r23, 0x00	; 0
    2ce8:	33 e0       	ldi	r19, 0x03	; 3
    2cea:	76 95       	lsr	r23
    2cec:	67 95       	ror	r22
    2cee:	3a 95       	dec	r19
    2cf0:	e1 f7       	brne	.-8      	; 0x2cea <_receive_data+0xa22>
    2cf2:	8f 73       	andi	r24, 0x3F	; 63
    2cf4:	90 70       	andi	r25, 0x00	; 0
    2cf6:	24 e0       	ldi	r18, 0x04	; 4
    2cf8:	88 0f       	add	r24, r24
    2cfa:	99 1f       	adc	r25, r25
    2cfc:	2a 95       	dec	r18
    2cfe:	e1 f7       	brne	.-8      	; 0x2cf8 <_receive_data+0xa30>
    2d00:	68 2b       	or	r22, r24
    2d02:	79 2b       	or	r23, r25
    2d04:	70 93 88 38 	sts	0x3888, r23
    2d08:	60 93 87 38 	sts	0x3887, r22
							eeprom_write_word(&_NV_BTCAL10, _wBTCAL10);
    2d0c:	83 e1       	ldi	r24, 0x13	; 19
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	0e 94 92 18 	call	0x3124	; 0x3124 <__eewr_word_m1284p>
    2d14:	bf c0       	rjmp	.+382    	; 0x2e94 <_receive_data+0xbcc>
                        }                                                                                               
                    }
                    break;
						
   				case (unsigned char) GetHardwareVersion:  
			   		aBuffer[0] = m_HV_RSP_BYTE0;
    2d16:	8a ec       	ldi	r24, 0xCA	; 202
    2d18:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_HV_RSP_BYTE1(_VERSION);
    2d1c:	83 e0       	ldi	r24, 0x03	; 3
    2d1e:	a9 c0       	rjmp	.+338    	; 0x2e72 <_receive_data+0xbaa>
					processed_counter = command_counter;		
					response_length = 2;
					break;				
			
				case (unsigned char) GetFirmwareVersion:  
			   		aBuffer[0] = m_FV_RSP_BYTE0;
    2d20:	8b ec       	ldi	r24, 0xCB	; 203
    2d22:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_FV_RSP_BYTE1(_FVERSION);
    2d26:	86 e0       	ldi	r24, 0x06	; 6
    2d28:	a4 c0       	rjmp	.+328    	; 0x2e72 <_receive_data+0xbaa>
					processed_counter = command_counter;
					response_length=2;
					break;	
			
				case (unsigned char) GetTCT:  
			      	aBuffer[0] = m_TCT_RSP_BYTE0;
    2d2a:	8e ec       	ldi	r24, 0xCE	; 206
    2d2c:	80 93 99 38 	sts	0x3899, r24
					aBuffer[1] = m_TCT_RSP_BYTE1(_wTCNT2);
    2d30:	20 91 4c 01 	lds	r18, 0x014C
    2d34:	82 2f       	mov	r24, r18
    2d36:	86 95       	lsr	r24
    2d38:	80 93 9a 38 	sts	0x389A, r24
					aBuffer[2] = m_TCT_RSP_BYTE2(_wTCNT2, _wTCNT2_reps);
    2d3c:	80 91 07 01 	lds	r24, 0x0107
    2d40:	30 e0       	ldi	r19, 0x00	; 0
    2d42:	21 70       	andi	r18, 0x01	; 1
    2d44:	30 70       	andi	r19, 0x00	; 0
    2d46:	06 e0       	ldi	r16, 0x06	; 6
    2d48:	22 0f       	add	r18, r18
    2d4a:	33 1f       	adc	r19, r19
    2d4c:	0a 95       	dec	r16
    2d4e:	e1 f7       	brne	.-8      	; 0x2d48 <_receive_data+0xa80>
    2d50:	98 2f       	mov	r25, r24
    2d52:	96 95       	lsr	r25
    2d54:	96 95       	lsr	r25
    2d56:	92 2b       	or	r25, r18
    2d58:	90 93 9b 38 	sts	0x389B, r25
					aBuffer[3] = m_TCT_RSP_BYTE3(_wTCNT2_reps, _wTCNT2_last);
    2d5c:	30 91 4d 01 	lds	r19, 0x014D
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	83 70       	andi	r24, 0x03	; 3
    2d64:	90 70       	andi	r25, 0x00	; 0
    2d66:	15 e0       	ldi	r17, 0x05	; 5
    2d68:	88 0f       	add	r24, r24
    2d6a:	99 1f       	adc	r25, r25
    2d6c:	1a 95       	dec	r17
    2d6e:	e1 f7       	brne	.-8      	; 0x2d68 <_receive_data+0xaa0>
    2d70:	23 2f       	mov	r18, r19
    2d72:	26 95       	lsr	r18
    2d74:	26 95       	lsr	r18
    2d76:	26 95       	lsr	r18
    2d78:	28 2b       	or	r18, r24
    2d7a:	20 93 9c 38 	sts	0x389C, r18
					aBuffer[4] = m_TCT_RSP_BYTE4(_wTCNT2_last);
    2d7e:	83 2f       	mov	r24, r19
    2d80:	87 70       	andi	r24, 0x07	; 7
    2d82:	82 95       	swap	r24
    2d84:	80 7f       	andi	r24, 0xF0	; 240
    2d86:	80 93 9d 38 	sts	0x389D, r24
					processed_counter = command_counter;				
    2d8a:	60 93 3b 01 	sts	0x013B, r22
					response_length = 5;
    2d8e:	85 e0       	ldi	r24, 0x05	; 5
    2d90:	75 c0       	rjmp	.+234    	; 0x2e7c <_receive_data+0xbb4>
					break;
			
				case (unsigned char) SetLED:  
			      	_LED_COLOR = m_SET_LED_COLOR(rBuffer[1]);
    2d92:	20 91 90 38 	lds	r18, 0x3890
    2d96:	82 2f       	mov	r24, r18
    2d98:	90 e0       	ldi	r25, 0x00	; 0
    2d9a:	80 74       	andi	r24, 0x40	; 64
    2d9c:	90 70       	andi	r25, 0x00	; 0
    2d9e:	b6 e0       	ldi	r27, 0x06	; 6
    2da0:	95 95       	asr	r25
    2da2:	87 95       	ror	r24
    2da4:	ba 95       	dec	r27
    2da6:	e1 f7       	brne	.-8      	; 0x2da0 <_receive_data+0xad8>
    2da8:	80 93 0a 01 	sts	0x010A, r24
					_LED_TIME = m_SET_LED_TIME(rBuffer[1]);
    2dac:	2f 73       	andi	r18, 0x3F	; 63
    2dae:	20 93 09 01 	sts	0x0109, r18
					if (_LED_COLOR == 0){						
    2db2:	00 97       	sbiw	r24, 0x00	; 0
    2db4:	09 f5       	brne	.+66     	; 0x2df8 <_receive_data+0xb30>
    2db6:	00 e0       	ldi	r16, 0x00	; 0
    2db8:	10 e0       	ldi	r17, 0x00	; 0
    2dba:	18 c0       	rjmp	.+48     	; 0x2dec <_receive_data+0xb24>
						for (int j=0; j<(_LED_TIME); j++){
							_yellowled_turn_on();	
    2dbc:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <_yellowled_turn_on>
    2dc0:	8f ef       	ldi	r24, 0xFF	; 255
    2dc2:	94 e3       	ldi	r25, 0x34	; 52
    2dc4:	ac e0       	ldi	r26, 0x0C	; 12
    2dc6:	81 50       	subi	r24, 0x01	; 1
    2dc8:	90 40       	sbci	r25, 0x00	; 0
    2dca:	a0 40       	sbci	r26, 0x00	; 0
    2dcc:	e1 f7       	brne	.-8      	; 0x2dc6 <_receive_data+0xafe>
    2dce:	00 c0       	rjmp	.+0      	; 0x2dd0 <_receive_data+0xb08>
    2dd0:	00 00       	nop
							_delay_ms(500);						
							_yellowled_turn_off(); 
    2dd2:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>
    2dd6:	8f ef       	ldi	r24, 0xFF	; 255
    2dd8:	94 e3       	ldi	r25, 0x34	; 52
    2dda:	ac e0       	ldi	r26, 0x0C	; 12
    2ddc:	81 50       	subi	r24, 0x01	; 1
    2dde:	90 40       	sbci	r25, 0x00	; 0
    2de0:	a0 40       	sbci	r26, 0x00	; 0
    2de2:	e1 f7       	brne	.-8      	; 0x2ddc <_receive_data+0xb14>
    2de4:	00 c0       	rjmp	.+0      	; 0x2de6 <_receive_data+0xb1e>
    2de6:	00 00       	nop
			
				case (unsigned char) SetLED:  
			      	_LED_COLOR = m_SET_LED_COLOR(rBuffer[1]);
					_LED_TIME = m_SET_LED_TIME(rBuffer[1]);
					if (_LED_COLOR == 0){						
						for (int j=0; j<(_LED_TIME); j++){
    2de8:	0f 5f       	subi	r16, 0xFF	; 255
    2dea:	1f 4f       	sbci	r17, 0xFF	; 255
    2dec:	80 91 09 01 	lds	r24, 0x0109
    2df0:	90 e0       	ldi	r25, 0x00	; 0
    2df2:	08 17       	cp	r16, r24
    2df4:	19 07       	cpc	r17, r25
    2df6:	14 f3       	brlt	.-60     	; 0x2dbc <_receive_data+0xaf4>
							_yellowled_turn_on();	
							_delay_ms(500);						
							_yellowled_turn_off(); 
							_delay_ms(500);
						}
					} if (_LED_COLOR == 1){
    2df8:	80 91 0a 01 	lds	r24, 0x010A
    2dfc:	81 30       	cpi	r24, 0x01	; 1
    2dfe:	09 f0       	breq	.+2      	; 0x2e02 <_receive_data+0xb3a>
    2e00:	49 c0       	rjmp	.+146    	; 0x2e94 <_receive_data+0xbcc>
    2e02:	00 e0       	ldi	r16, 0x00	; 0
    2e04:	10 e0       	ldi	r17, 0x00	; 0
    2e06:	18 c0       	rjmp	.+48     	; 0x2e38 <_receive_data+0xb70>
						for (int j=0; j<(_LED_TIME); j++){
							_greenled_turn_on();	
    2e08:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <_greenled_turn_on>
    2e0c:	8f ef       	ldi	r24, 0xFF	; 255
    2e0e:	94 e3       	ldi	r25, 0x34	; 52
    2e10:	ac e0       	ldi	r26, 0x0C	; 12
    2e12:	81 50       	subi	r24, 0x01	; 1
    2e14:	90 40       	sbci	r25, 0x00	; 0
    2e16:	a0 40       	sbci	r26, 0x00	; 0
    2e18:	e1 f7       	brne	.-8      	; 0x2e12 <_receive_data+0xb4a>
    2e1a:	00 c0       	rjmp	.+0      	; 0x2e1c <_receive_data+0xb54>
    2e1c:	00 00       	nop
							_delay_ms(500);						
							_greenled_turn_off(); 
    2e1e:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>
    2e22:	8f ef       	ldi	r24, 0xFF	; 255
    2e24:	94 e3       	ldi	r25, 0x34	; 52
    2e26:	ac e0       	ldi	r26, 0x0C	; 12
    2e28:	81 50       	subi	r24, 0x01	; 1
    2e2a:	90 40       	sbci	r25, 0x00	; 0
    2e2c:	a0 40       	sbci	r26, 0x00	; 0
    2e2e:	e1 f7       	brne	.-8      	; 0x2e28 <_receive_data+0xb60>
    2e30:	00 c0       	rjmp	.+0      	; 0x2e32 <_receive_data+0xb6a>
    2e32:	00 00       	nop
							_delay_ms(500);						
							_yellowled_turn_off(); 
							_delay_ms(500);
						}
					} if (_LED_COLOR == 1){
						for (int j=0; j<(_LED_TIME); j++){
    2e34:	0f 5f       	subi	r16, 0xFF	; 255
    2e36:	1f 4f       	sbci	r17, 0xFF	; 255
    2e38:	80 91 09 01 	lds	r24, 0x0109
    2e3c:	90 e0       	ldi	r25, 0x00	; 0
    2e3e:	08 17       	cp	r16, r24
    2e40:	19 07       	cpc	r17, r25
    2e42:	14 f3       	brlt	.-60     	; 0x2e08 <_receive_data+0xb40>
    2e44:	27 c0       	rjmp	.+78     	; 0x2e94 <_receive_data+0xbcc>
					} 
					processed_counter = command_counter;
					break;
			
				case (unsigned char) ShutdownWocket:  
					shutdown_flag = 1;
    2e46:	81 e0       	ldi	r24, 0x01	; 1
    2e48:	80 93 32 01 	sts	0x0132, r24
					_bluetooth_turn_off();
    2e4c:	0e 94 de 0a 	call	0x15bc	; 0x15bc <_bluetooth_turn_off>
					_greenled_turn_off();
    2e50:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <_greenled_turn_off>
					_yellowled_turn_off();			      	
    2e54:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <_yellowled_turn_off>
    2e58:	1d c0       	rjmp	.+58     	; 0x2e94 <_receive_data+0xbcc>
					processed_counter = command_counter;
					break;
				
				case (unsigned char) ResetBluetooth:  
			      	_bluetooth_reset();
    2e5a:	0e 94 e7 0a 	call	0x15ce	; 0x15ce <_bluetooth_reset>
    2e5e:	1a c0       	rjmp	.+52     	; 0x2e94 <_receive_data+0xbcc>
				case (unsigned char) ResetWocket:  
			      	//_wocket_reset();
					/*_atmega_finalize();
					for (int j = 0; (j < 1000); j++)
						_delay_ms(5);*/
					_wocket_initialize();
    2e60:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <_wocket_initialize>
    2e64:	17 c0       	rjmp	.+46     	; 0x2e94 <_receive_data+0xbcc>
					processed_counter = command_counter;
					break;

				case (unsigned char) GetAliveTimer:  
			   		aBuffer[0] = m_ALT_RSP_BYTE0;
    2e66:	86 ec       	ldi	r24, 0xC6	; 198
    2e68:	80 93 99 38 	sts	0x3899, r24
                    aBuffer[1] = m_ALT_RSP_BYTE1(_wALT);
    2e6c:	80 91 89 38 	lds	r24, 0x3889
    2e70:	8f 77       	andi	r24, 0x7F	; 127
    2e72:	80 93 9a 38 	sts	0x389A, r24
					processed_counter = command_counter;
    2e76:	60 93 3b 01 	sts	0x013B, r22
					response_length = 2;
    2e7a:	82 e0       	ldi	r24, 0x02	; 2
    2e7c:	80 93 3c 01 	sts	0x013C, r24
					break;	
    2e80:	0d c0       	rjmp	.+26     	; 0x2e9c <_receive_data+0xbd4>
							
                case (unsigned char) SetAliveTimer:  
			   		_wALT = m_SET_ALT(rBuffer[1]);
    2e82:	60 91 90 38 	lds	r22, 0x3890
    2e86:	6f 77       	andi	r22, 0x7F	; 127
    2e88:	60 93 89 38 	sts	0x3889, r22
					eeprom_write_byte(&_NV_ALT, _wALT);
    2e8c:	82 e2       	ldi	r24, 0x22	; 34
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
					processed_counter = command_counter;
    2e94:	80 91 37 01 	lds	r24, 0x0137
    2e98:	80 93 3b 01 	sts	0x013B, r24
																					 							                              
                default:        
                    break;
            }

            if (processed_counter == command_counter)
    2e9c:	90 91 3b 01 	lds	r25, 0x013B
    2ea0:	80 91 37 01 	lds	r24, 0x0137
    2ea4:	98 17       	cp	r25, r24
    2ea6:	71 f5       	brne	.+92     	; 0x2f04 <_receive_data+0xc3c>
    2ea8:	a9 e9       	ldi	r26, 0x99	; 153
    2eaa:	ea 2e       	mov	r14, r26
    2eac:	a8 e3       	ldi	r26, 0x38	; 56
    2eae:	fa 2e       	mov	r15, r26
    2eb0:	00 e0       	ldi	r16, 0x00	; 0
    2eb2:	10 e0       	ldi	r17, 0x00	; 0
    2eb4:	07 c0       	rjmp	.+14     	; 0x2ec4 <_receive_data+0xbfc>
			{                              
                    for (int i = 0; (i < response_length); i++)                                                                                       
                     	_bluetooth_transmit_uart0_byte(aBuffer[i]);                                                                                                                                                   
    2eb6:	d7 01       	movw	r26, r14
    2eb8:	8d 91       	ld	r24, X+
    2eba:	7d 01       	movw	r14, r26
    2ebc:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
                    break;
            }

            if (processed_counter == command_counter)
			{                              
                    for (int i = 0; (i < response_length); i++)                                                                                       
    2ec0:	0f 5f       	subi	r16, 0xFF	; 255
    2ec2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ec4:	80 91 3c 01 	lds	r24, 0x013C
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	08 17       	cp	r16, r24
    2ecc:	19 07       	cpc	r17, r25
    2ece:	9c f3       	brlt	.-26     	; 0x2eb6 <_receive_data+0xbee>
    2ed0:	07 c0       	rjmp	.+14     	; 0x2ee0 <_receive_data+0xc18>
                    processed_counter = 0;                                            
                    address = 0xffff;
                    response_length = 0;                    
            }
    } //if command timed out
    else if ((command_timer >= MAX_COMMAND_TIMER))
    2ed2:	80 91 39 01 	lds	r24, 0x0139
    2ed6:	90 91 3a 01 	lds	r25, 0x013A
    2eda:	8f 3f       	cpi	r24, 0xFF	; 255
    2edc:	91 05       	cpc	r25, r1
    2ede:	90 f0       	brcs	.+36     	; 0x2f04 <_receive_data+0xc3c>
    {                            
        command_length = 0;
    2ee0:	10 92 38 01 	sts	0x0138, r1
        command_counter = 0;
    2ee4:	10 92 37 01 	sts	0x0137, r1
        command_timer = 0;
    2ee8:	10 92 3a 01 	sts	0x013A, r1
    2eec:	10 92 39 01 	sts	0x0139, r1
        processed_counter = 0;                            
    2ef0:	10 92 3b 01 	sts	0x013B, r1
        address=0xffff;
    2ef4:	8f ef       	ldi	r24, 0xFF	; 255
    2ef6:	9f ef       	ldi	r25, 0xFF	; 255
    2ef8:	90 93 05 01 	sts	0x0105, r25
    2efc:	80 93 04 01 	sts	0x0104, r24
        response_length = 0;
    2f00:	10 92 3c 01 	sts	0x013C, r1
    }
}
    2f04:	0f 90       	pop	r0
    2f06:	cf 91       	pop	r28
    2f08:	df 91       	pop	r29
    2f0a:	1f 91       	pop	r17
    2f0c:	0f 91       	pop	r16
    2f0e:	ff 90       	pop	r15
    2f10:	ef 90       	pop	r14
    2f12:	08 95       	ret

00002f14 <_send_acs>:
}

//-------------------------------------------
// sends the Activity counts
void _send_acs()
{
    2f14:	df 92       	push	r13
    2f16:	ef 92       	push	r14
    2f18:	ff 92       	push	r15
    2f1a:	0f 93       	push	r16
    2f1c:	1f 93       	push	r17
    2f1e:	cf 93       	push	r28
    2f20:	df 93       	push	r29
	unsigned short count   = 0;
	unsigned short seq_num = sseq;
    2f22:	00 91 19 01 	lds	r16, 0x0119
    2f26:	10 91 1a 01 	lds	r17, 0x011A
		num_acs = ci - si;
	else
		num_acs = ci + (AC_BUFFER_SIZE - si);
	
	//send AC offset accumulated within the minute & the overall AC sequence number
	_send_ac_offset(AC_NUMS - summary_count); 
    2f2a:	80 91 15 01 	lds	r24, 0x0115
    2f2e:	90 91 16 01 	lds	r25, 0x0116
    2f32:	20 91 67 0c 	lds	r18, 0x0C67
    2f36:	30 91 68 0c 	lds	r19, 0x0C68
    2f3a:	82 1b       	sub	r24, r18
    2f3c:	93 0b       	sbc	r25, r19
    2f3e:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <_send_ac_offset>
	_send_ac_count(cseq);		
    2f42:	80 91 17 01 	lds	r24, 0x0117
    2f46:	90 91 18 01 	lds	r25, 0x0118
    2f4a:	0e 94 ce 10 	call	0x219c	; 0x219c <_send_ac_count>

    //send the acs from start to current ac index
	for (int i = si;(i != ci);)
    2f4e:	c0 91 21 01 	lds	r28, 0x0121
    2f52:	d0 91 22 01 	lds	r29, 0x0122
	{		
		count = acount[i];
		aBuffer[0] = m_AC_RSP_BYTE0;
    2f56:	7d ec       	ldi	r23, 0xCD	; 205
    2f58:	d7 2e       	mov	r13, r23
	//send AC offset accumulated within the minute & the overall AC sequence number
	_send_ac_offset(AC_NUMS - summary_count); 
	_send_ac_count(cseq);		

    //send the acs from start to current ac index
	for (int i = si;(i != ci);)
    2f5a:	46 c0       	rjmp	.+140    	; 0x2fe8 <_send_acs+0xd4>
	{		
		count = acount[i];
    2f5c:	fe 01       	movw	r30, r28
    2f5e:	ee 0f       	add	r30, r30
    2f60:	ff 1f       	adc	r31, r31
    2f62:	e0 5a       	subi	r30, 0xA0	; 160
    2f64:	fe 4f       	sbci	r31, 0xFE	; 254
    2f66:	80 81       	ld	r24, Z
    2f68:	91 81       	ldd	r25, Z+1	; 0x01
		aBuffer[0] = m_AC_RSP_BYTE0;
    2f6a:	d0 92 99 38 	sts	0x3899, r13
    	aBuffer[1] = m_AC_RSP_BYTE1(seq_num);
    2f6e:	21 2f       	mov	r18, r17
    2f70:	26 95       	lsr	r18
    2f72:	20 93 9a 38 	sts	0x389A, r18
    	aBuffer[2] = m_AC_RSP_BYTE2(seq_num);
    2f76:	98 01       	movw	r18, r16
    2f78:	36 95       	lsr	r19
    2f7a:	27 95       	ror	r18
    2f7c:	36 95       	lsr	r19
    2f7e:	27 95       	ror	r18
    2f80:	2f 77       	andi	r18, 0x7F	; 127
    2f82:	20 93 9b 38 	sts	0x389B, r18
		aBuffer[3] = m_AC_RSP_BYTE3(seq_num,count);
    2f86:	20 2f       	mov	r18, r16
    2f88:	23 70       	andi	r18, 0x03	; 3
    2f8a:	22 95       	swap	r18
    2f8c:	22 0f       	add	r18, r18
    2f8e:	20 7e       	andi	r18, 0xE0	; 224
    2f90:	39 2f       	mov	r19, r25
    2f92:	36 95       	lsr	r19
    2f94:	36 95       	lsr	r19
    2f96:	36 95       	lsr	r19
    2f98:	23 2b       	or	r18, r19
    2f9a:	20 93 9c 38 	sts	0x389C, r18
		aBuffer[4] = m_AC_RSP_BYTE4(count);
    2f9e:	9c 01       	movw	r18, r24
    2fa0:	44 e0       	ldi	r20, 0x04	; 4
    2fa2:	36 95       	lsr	r19
    2fa4:	27 95       	ror	r18
    2fa6:	4a 95       	dec	r20
    2fa8:	e1 f7       	brne	.-8      	; 0x2fa2 <_send_acs+0x8e>
    2faa:	2f 77       	andi	r18, 0x7F	; 127
    2fac:	20 93 9d 38 	sts	0x389D, r18
		aBuffer[5] = m_AC_RSP_BYTE5(count);
    2fb0:	8f 70       	andi	r24, 0x0F	; 15
    2fb2:	88 0f       	add	r24, r24
    2fb4:	88 0f       	add	r24, r24
    2fb6:	80 93 9e 38 	sts	0x389E, r24
    2fba:	39 e9       	ldi	r19, 0x99	; 153
    2fbc:	e3 2e       	mov	r14, r19
    2fbe:	38 e3       	ldi	r19, 0x38	; 56
    2fc0:	f3 2e       	mov	r15, r19

		for (int j = 0; (j < 6); j++)                                                                                       
       		_bluetooth_transmit_uart0_byte(aBuffer[j]);
    2fc2:	f7 01       	movw	r30, r14
    2fc4:	81 91       	ld	r24, Z+
    2fc6:	7f 01       	movw	r14, r30
    2fc8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <_bluetooth_transmit_uart0_byte>
    	aBuffer[2] = m_AC_RSP_BYTE2(seq_num);
		aBuffer[3] = m_AC_RSP_BYTE3(seq_num,count);
		aBuffer[4] = m_AC_RSP_BYTE4(count);
		aBuffer[5] = m_AC_RSP_BYTE5(count);

		for (int j = 0; (j < 6); j++)                                                                                       
    2fcc:	ff e9       	ldi	r31, 0x9F	; 159
    2fce:	ef 16       	cp	r14, r31
    2fd0:	f8 e3       	ldi	r31, 0x38	; 56
    2fd2:	ff 06       	cpc	r15, r31
    2fd4:	b1 f7       	brne	.-20     	; 0x2fc2 <_send_acs+0xae>
       		_bluetooth_transmit_uart0_byte(aBuffer[j]);
			 
		i++;
    2fd6:	21 96       	adiw	r28, 0x01	; 1
		if (i == AC_BUFFER_SIZE)
    2fd8:	83 e0       	ldi	r24, 0x03	; 3
    2fda:	c0 3c       	cpi	r28, 0xC0	; 192
    2fdc:	d8 07       	cpc	r29, r24
    2fde:	11 f4       	brne	.+4      	; 0x2fe4 <_send_acs+0xd0>
			i = 0;
    2fe0:	c0 e0       	ldi	r28, 0x00	; 0
    2fe2:	d0 e0       	ldi	r29, 0x00	; 0
		seq_num++;
    2fe4:	0f 5f       	subi	r16, 0xFF	; 255
    2fe6:	1f 4f       	sbci	r17, 0xFF	; 255
	//send AC offset accumulated within the minute & the overall AC sequence number
	_send_ac_offset(AC_NUMS - summary_count); 
	_send_ac_count(cseq);		

    //send the acs from start to current ac index
	for (int i = si;(i != ci);)
    2fe8:	80 91 1f 01 	lds	r24, 0x011F
    2fec:	90 91 20 01 	lds	r25, 0x0120
    2ff0:	c8 17       	cp	r28, r24
    2ff2:	d9 07       	cpc	r29, r25
    2ff4:	09 f0       	breq	.+2      	; 0x2ff8 <_send_acs+0xe4>
    2ff6:	b2 cf       	rjmp	.-156    	; 0x2f5c <_send_acs+0x48>
			counter++;
			if (counter == 10)
				return;
		}*/
	}
	_receive_data();
    2ff8:	0e 94 64 11 	call	0x22c8	; 0x22c8 <_receive_data>
}
    2ffc:	df 91       	pop	r29
    2ffe:	cf 91       	pop	r28
    3000:	1f 91       	pop	r17
    3002:	0f 91       	pop	r16
    3004:	ff 90       	pop	r15
    3006:	ef 90       	pop	r14
    3008:	df 90       	pop	r13
    300a:	08 95       	ret

0000300c <__mulsi3>:
    300c:	62 9f       	mul	r22, r18
    300e:	d0 01       	movw	r26, r0
    3010:	73 9f       	mul	r23, r19
    3012:	f0 01       	movw	r30, r0
    3014:	82 9f       	mul	r24, r18
    3016:	e0 0d       	add	r30, r0
    3018:	f1 1d       	adc	r31, r1
    301a:	64 9f       	mul	r22, r20
    301c:	e0 0d       	add	r30, r0
    301e:	f1 1d       	adc	r31, r1
    3020:	92 9f       	mul	r25, r18
    3022:	f0 0d       	add	r31, r0
    3024:	83 9f       	mul	r24, r19
    3026:	f0 0d       	add	r31, r0
    3028:	74 9f       	mul	r23, r20
    302a:	f0 0d       	add	r31, r0
    302c:	65 9f       	mul	r22, r21
    302e:	f0 0d       	add	r31, r0
    3030:	99 27       	eor	r25, r25
    3032:	72 9f       	mul	r23, r18
    3034:	b0 0d       	add	r27, r0
    3036:	e1 1d       	adc	r30, r1
    3038:	f9 1f       	adc	r31, r25
    303a:	63 9f       	mul	r22, r19
    303c:	b0 0d       	add	r27, r0
    303e:	e1 1d       	adc	r30, r1
    3040:	f9 1f       	adc	r31, r25
    3042:	bd 01       	movw	r22, r26
    3044:	cf 01       	movw	r24, r30
    3046:	11 24       	eor	r1, r1
    3048:	08 95       	ret

0000304a <__udivmodhi4>:
    304a:	aa 1b       	sub	r26, r26
    304c:	bb 1b       	sub	r27, r27
    304e:	51 e1       	ldi	r21, 0x11	; 17
    3050:	07 c0       	rjmp	.+14     	; 0x3060 <__udivmodhi4_ep>

00003052 <__udivmodhi4_loop>:
    3052:	aa 1f       	adc	r26, r26
    3054:	bb 1f       	adc	r27, r27
    3056:	a6 17       	cp	r26, r22
    3058:	b7 07       	cpc	r27, r23
    305a:	10 f0       	brcs	.+4      	; 0x3060 <__udivmodhi4_ep>
    305c:	a6 1b       	sub	r26, r22
    305e:	b7 0b       	sbc	r27, r23

00003060 <__udivmodhi4_ep>:
    3060:	88 1f       	adc	r24, r24
    3062:	99 1f       	adc	r25, r25
    3064:	5a 95       	dec	r21
    3066:	a9 f7       	brne	.-22     	; 0x3052 <__udivmodhi4_loop>
    3068:	80 95       	com	r24
    306a:	90 95       	com	r25
    306c:	bc 01       	movw	r22, r24
    306e:	cd 01       	movw	r24, r26
    3070:	08 95       	ret

00003072 <__udivmodsi4>:
    3072:	a1 e2       	ldi	r26, 0x21	; 33
    3074:	1a 2e       	mov	r1, r26
    3076:	aa 1b       	sub	r26, r26
    3078:	bb 1b       	sub	r27, r27
    307a:	fd 01       	movw	r30, r26
    307c:	0d c0       	rjmp	.+26     	; 0x3098 <__udivmodsi4_ep>

0000307e <__udivmodsi4_loop>:
    307e:	aa 1f       	adc	r26, r26
    3080:	bb 1f       	adc	r27, r27
    3082:	ee 1f       	adc	r30, r30
    3084:	ff 1f       	adc	r31, r31
    3086:	a2 17       	cp	r26, r18
    3088:	b3 07       	cpc	r27, r19
    308a:	e4 07       	cpc	r30, r20
    308c:	f5 07       	cpc	r31, r21
    308e:	20 f0       	brcs	.+8      	; 0x3098 <__udivmodsi4_ep>
    3090:	a2 1b       	sub	r26, r18
    3092:	b3 0b       	sbc	r27, r19
    3094:	e4 0b       	sbc	r30, r20
    3096:	f5 0b       	sbc	r31, r21

00003098 <__udivmodsi4_ep>:
    3098:	66 1f       	adc	r22, r22
    309a:	77 1f       	adc	r23, r23
    309c:	88 1f       	adc	r24, r24
    309e:	99 1f       	adc	r25, r25
    30a0:	1a 94       	dec	r1
    30a2:	69 f7       	brne	.-38     	; 0x307e <__udivmodsi4_loop>
    30a4:	60 95       	com	r22
    30a6:	70 95       	com	r23
    30a8:	80 95       	com	r24
    30aa:	90 95       	com	r25
    30ac:	9b 01       	movw	r18, r22
    30ae:	ac 01       	movw	r20, r24
    30b0:	bd 01       	movw	r22, r26
    30b2:	cf 01       	movw	r24, r30
    30b4:	08 95       	ret

000030b6 <__divmodsi4>:
    30b6:	97 fb       	bst	r25, 7
    30b8:	09 2e       	mov	r0, r25
    30ba:	05 26       	eor	r0, r21
    30bc:	0e d0       	rcall	.+28     	; 0x30da <__divmodsi4_neg1>
    30be:	57 fd       	sbrc	r21, 7
    30c0:	04 d0       	rcall	.+8      	; 0x30ca <__divmodsi4_neg2>
    30c2:	d7 df       	rcall	.-82     	; 0x3072 <__udivmodsi4>
    30c4:	0a d0       	rcall	.+20     	; 0x30da <__divmodsi4_neg1>
    30c6:	00 1c       	adc	r0, r0
    30c8:	38 f4       	brcc	.+14     	; 0x30d8 <__divmodsi4_exit>

000030ca <__divmodsi4_neg2>:
    30ca:	50 95       	com	r21
    30cc:	40 95       	com	r20
    30ce:	30 95       	com	r19
    30d0:	21 95       	neg	r18
    30d2:	3f 4f       	sbci	r19, 0xFF	; 255
    30d4:	4f 4f       	sbci	r20, 0xFF	; 255
    30d6:	5f 4f       	sbci	r21, 0xFF	; 255

000030d8 <__divmodsi4_exit>:
    30d8:	08 95       	ret

000030da <__divmodsi4_neg1>:
    30da:	f6 f7       	brtc	.-4      	; 0x30d8 <__divmodsi4_exit>
    30dc:	90 95       	com	r25
    30de:	80 95       	com	r24
    30e0:	70 95       	com	r23
    30e2:	61 95       	neg	r22
    30e4:	7f 4f       	sbci	r23, 0xFF	; 255
    30e6:	8f 4f       	sbci	r24, 0xFF	; 255
    30e8:	9f 4f       	sbci	r25, 0xFF	; 255
    30ea:	08 95       	ret

000030ec <__eerd_byte_m1284p>:
    30ec:	f9 99       	sbic	0x1f, 1	; 31
    30ee:	fe cf       	rjmp	.-4      	; 0x30ec <__eerd_byte_m1284p>
    30f0:	92 bd       	out	0x22, r25	; 34
    30f2:	81 bd       	out	0x21, r24	; 33
    30f4:	f8 9a       	sbi	0x1f, 0	; 31
    30f6:	99 27       	eor	r25, r25
    30f8:	80 b5       	in	r24, 0x20	; 32
    30fa:	08 95       	ret

000030fc <__eerd_word_m1284p>:
    30fc:	a8 e1       	ldi	r26, 0x18	; 24
    30fe:	b0 e0       	ldi	r27, 0x00	; 0
    3100:	42 e0       	ldi	r20, 0x02	; 2
    3102:	50 e0       	ldi	r21, 0x00	; 0
    3104:	0c 94 99 18 	jmp	0x3132	; 0x3132 <__eerd_blraw_m1284p>

00003108 <__eewr_byte_m1284p>:
    3108:	26 2f       	mov	r18, r22

0000310a <__eewr_r18_m1284p>:
    310a:	f9 99       	sbic	0x1f, 1	; 31
    310c:	fe cf       	rjmp	.-4      	; 0x310a <__eewr_r18_m1284p>
    310e:	1f ba       	out	0x1f, r1	; 31
    3110:	92 bd       	out	0x22, r25	; 34
    3112:	81 bd       	out	0x21, r24	; 33
    3114:	20 bd       	out	0x20, r18	; 32
    3116:	0f b6       	in	r0, 0x3f	; 63
    3118:	f8 94       	cli
    311a:	fa 9a       	sbi	0x1f, 2	; 31
    311c:	f9 9a       	sbi	0x1f, 1	; 31
    311e:	0f be       	out	0x3f, r0	; 63
    3120:	01 96       	adiw	r24, 0x01	; 1
    3122:	08 95       	ret

00003124 <__eewr_word_m1284p>:
    3124:	0e 94 84 18 	call	0x3108	; 0x3108 <__eewr_byte_m1284p>
    3128:	27 2f       	mov	r18, r23
    312a:	0c 94 85 18 	jmp	0x310a	; 0x310a <__eewr_r18_m1284p>

0000312e <__eerd_block_m1284p>:
    312e:	dc 01       	movw	r26, r24
    3130:	cb 01       	movw	r24, r22

00003132 <__eerd_blraw_m1284p>:
    3132:	fc 01       	movw	r30, r24
    3134:	f9 99       	sbic	0x1f, 1	; 31
    3136:	fe cf       	rjmp	.-4      	; 0x3134 <__eerd_blraw_m1284p+0x2>
    3138:	06 c0       	rjmp	.+12     	; 0x3146 <__eerd_blraw_m1284p+0x14>
    313a:	f2 bd       	out	0x22, r31	; 34
    313c:	e1 bd       	out	0x21, r30	; 33
    313e:	f8 9a       	sbi	0x1f, 0	; 31
    3140:	31 96       	adiw	r30, 0x01	; 1
    3142:	00 b4       	in	r0, 0x20	; 32
    3144:	0d 92       	st	X+, r0
    3146:	41 50       	subi	r20, 0x01	; 1
    3148:	50 40       	sbci	r21, 0x00	; 0
    314a:	b8 f7       	brcc	.-18     	; 0x313a <__eerd_blraw_m1284p+0x8>
    314c:	08 95       	ret

0000314e <_exit>:
    314e:	f8 94       	cli

00003150 <__stop_program>:
    3150:	ff cf       	rjmp	.-2      	; 0x3150 <__stop_program>
